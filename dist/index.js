var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var a = e.indexOf("=");
  a === -1 && (a = t);
  var n = a === t ? 0 : 4 - a % 4;
  return [a, n];
}
function byteLength(e) {
  var t = getLens(e), a = t[0], n = t[1];
  return (a + n) * 3 / 4 - n;
}
function _byteLength(e, t, a) {
  return (t + a) * 3 / 4 - a;
}
function toByteArray(e) {
  var t, a = getLens(e), n = a[0], u = a[1], o = new Arr(_byteLength(e, n, u)), l = 0, h = u > 0 ? n - 4 : n, y;
  for (y = 0; y < h; y += 4)
    t = revLookup[e.charCodeAt(y)] << 18 | revLookup[e.charCodeAt(y + 1)] << 12 | revLookup[e.charCodeAt(y + 2)] << 6 | revLookup[e.charCodeAt(y + 3)], o[l++] = t >> 16 & 255, o[l++] = t >> 8 & 255, o[l++] = t & 255;
  return u === 2 && (t = revLookup[e.charCodeAt(y)] << 2 | revLookup[e.charCodeAt(y + 1)] >> 4, o[l++] = t & 255), u === 1 && (t = revLookup[e.charCodeAt(y)] << 10 | revLookup[e.charCodeAt(y + 1)] << 4 | revLookup[e.charCodeAt(y + 2)] >> 2, o[l++] = t >> 8 & 255, o[l++] = t & 255), o;
}
function tripletToBase64(e) {
  return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[e & 63];
}
function encodeChunk(e, t, a) {
  for (var n, u = [], o = t; o < a; o += 3)
    n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), u.push(tripletToBase64(n));
  return u.join("");
}
function fromByteArray(e) {
  for (var t, a = e.length, n = a % 3, u = [], o = 16383, l = 0, h = a - n; l < h; l += o)
    u.push(encodeChunk(e, l, l + o > h ? h : l + o));
  return n === 1 ? (t = e[a - 1], u.push(
    lookup[t >> 2] + lookup[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[a - 2] << 8) + e[a - 1], u.push(
    lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + "="
  )), u.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(e, t, a, n, u) {
  var o, l, h = u * 8 - n - 1, y = (1 << h) - 1, _ = y >> 1, d = -7, $ = a ? u - 1 : 0, N = a ? -1 : 1, U = e[t + $];
  for ($ += N, o = U & (1 << -d) - 1, U >>= -d, d += h; d > 0; o = o * 256 + e[t + $], $ += N, d -= 8)
    ;
  for (l = o & (1 << -d) - 1, o >>= -d, d += n; d > 0; l = l * 256 + e[t + $], $ += N, d -= 8)
    ;
  if (o === 0)
    o = 1 - _;
  else {
    if (o === y)
      return l ? NaN : (U ? -1 : 1) * (1 / 0);
    l = l + Math.pow(2, n), o = o - _;
  }
  return (U ? -1 : 1) * l * Math.pow(2, o - n);
};
ieee754.write = function(e, t, a, n, u, o) {
  var l, h, y, _ = o * 8 - u - 1, d = (1 << _) - 1, $ = d >> 1, N = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, U = n ? 0 : o - 1, V = n ? 1 : -1, Q = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (h = isNaN(t) ? 1 : 0, l = d) : (l = Math.floor(Math.log(t) / Math.LN2), t * (y = Math.pow(2, -l)) < 1 && (l--, y *= 2), l + $ >= 1 ? t += N / y : t += N * Math.pow(2, 1 - $), t * y >= 2 && (l++, y /= 2), l + $ >= d ? (h = 0, l = d) : l + $ >= 1 ? (h = (t * y - 1) * Math.pow(2, u), l = l + $) : (h = t * Math.pow(2, $ - 1) * Math.pow(2, u), l = 0)); u >= 8; e[a + U] = h & 255, U += V, h /= 256, u -= 8)
    ;
  for (l = l << u | h, _ += u; _ > 0; e[a + U] = l & 255, U += V, l /= 256, _ -= 8)
    ;
  e[a + U - V] |= Q * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var t = base64Js, a = ieee754, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = h, e.SlowBuffer = ne, e.INSPECT_MAX_BYTES = 50;
  var u = 2147483647;
  e.kMaxLength = u, h.TYPED_ARRAY_SUPPORT = o(), !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function o() {
    try {
      var ce = new Uint8Array(1), j = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(j, Uint8Array.prototype), Object.setPrototypeOf(ce, j), ce.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(h.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (h.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(h.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (h.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(ce) {
    if (ce > u)
      throw new RangeError('The value "' + ce + '" is invalid for option "size"');
    var j = new Uint8Array(ce);
    return Object.setPrototypeOf(j, h.prototype), j;
  }
  function h(ce, j, z) {
    if (typeof ce == "number") {
      if (typeof j == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return $(ce);
    }
    return y(ce, j, z);
  }
  h.poolSize = 8192;
  function y(ce, j, z) {
    if (typeof ce == "string")
      return N(ce, j);
    if (ArrayBuffer.isView(ce))
      return V(ce);
    if (ce == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ce
      );
    if (we(ce, ArrayBuffer) || ce && we(ce.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (we(ce, SharedArrayBuffer) || ce && we(ce.buffer, SharedArrayBuffer)))
      return Q(ce, j, z);
    if (typeof ce == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var oe = ce.valueOf && ce.valueOf();
    if (oe != null && oe !== ce)
      return h.from(oe, j, z);
    var Be = ie(ce);
    if (Be)
      return Be;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ce[Symbol.toPrimitive] == "function")
      return h.from(
        ce[Symbol.toPrimitive]("string"),
        j,
        z
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ce
    );
  }
  h.from = function(ce, j, z) {
    return y(ce, j, z);
  }, Object.setPrototypeOf(h.prototype, Uint8Array.prototype), Object.setPrototypeOf(h, Uint8Array);
  function _(ce) {
    if (typeof ce != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ce < 0)
      throw new RangeError('The value "' + ce + '" is invalid for option "size"');
  }
  function d(ce, j, z) {
    return _(ce), ce <= 0 ? l(ce) : j !== void 0 ? typeof z == "string" ? l(ce).fill(j, z) : l(ce).fill(j) : l(ce);
  }
  h.alloc = function(ce, j, z) {
    return d(ce, j, z);
  };
  function $(ce) {
    return _(ce), l(ce < 0 ? 0 : ee(ce) | 0);
  }
  h.allocUnsafe = function(ce) {
    return $(ce);
  }, h.allocUnsafeSlow = function(ce) {
    return $(ce);
  };
  function N(ce, j) {
    if ((typeof j != "string" || j === "") && (j = "utf8"), !h.isEncoding(j))
      throw new TypeError("Unknown encoding: " + j);
    var z = ge(ce, j) | 0, oe = l(z), Be = oe.write(ce, j);
    return Be !== z && (oe = oe.slice(0, Be)), oe;
  }
  function U(ce) {
    for (var j = ce.length < 0 ? 0 : ee(ce.length) | 0, z = l(j), oe = 0; oe < j; oe += 1)
      z[oe] = ce[oe] & 255;
    return z;
  }
  function V(ce) {
    if (we(ce, Uint8Array)) {
      var j = new Uint8Array(ce);
      return Q(j.buffer, j.byteOffset, j.byteLength);
    }
    return U(ce);
  }
  function Q(ce, j, z) {
    if (j < 0 || ce.byteLength < j)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ce.byteLength < j + (z || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var oe;
    return j === void 0 && z === void 0 ? oe = new Uint8Array(ce) : z === void 0 ? oe = new Uint8Array(ce, j) : oe = new Uint8Array(ce, j, z), Object.setPrototypeOf(oe, h.prototype), oe;
  }
  function ie(ce) {
    if (h.isBuffer(ce)) {
      var j = ee(ce.length) | 0, z = l(j);
      return z.length === 0 || ce.copy(z, 0, 0, j), z;
    }
    if (ce.length !== void 0)
      return typeof ce.length != "number" || ke(ce.length) ? l(0) : U(ce);
    if (ce.type === "Buffer" && Array.isArray(ce.data))
      return U(ce.data);
  }
  function ee(ce) {
    if (ce >= u)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + u.toString(16) + " bytes");
    return ce | 0;
  }
  function ne(ce) {
    return +ce != ce && (ce = 0), h.alloc(+ce);
  }
  h.isBuffer = function(j) {
    return j != null && j._isBuffer === !0 && j !== h.prototype;
  }, h.compare = function(j, z) {
    if (we(j, Uint8Array) && (j = h.from(j, j.offset, j.byteLength)), we(z, Uint8Array) && (z = h.from(z, z.offset, z.byteLength)), !h.isBuffer(j) || !h.isBuffer(z))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (j === z)
      return 0;
    for (var oe = j.length, Be = z.length, Te = 0, Pe = Math.min(oe, Be); Te < Pe; ++Te)
      if (j[Te] !== z[Te]) {
        oe = j[Te], Be = z[Te];
        break;
      }
    return oe < Be ? -1 : Be < oe ? 1 : 0;
  }, h.isEncoding = function(j) {
    switch (String(j).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, h.concat = function(j, z) {
    if (!Array.isArray(j))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (j.length === 0)
      return h.alloc(0);
    var oe;
    if (z === void 0)
      for (z = 0, oe = 0; oe < j.length; ++oe)
        z += j[oe].length;
    var Be = h.allocUnsafe(z), Te = 0;
    for (oe = 0; oe < j.length; ++oe) {
      var Pe = j[oe];
      if (we(Pe, Uint8Array))
        Te + Pe.length > Be.length ? h.from(Pe).copy(Be, Te) : Uint8Array.prototype.set.call(
          Be,
          Pe,
          Te
        );
      else if (h.isBuffer(Pe))
        Pe.copy(Be, Te);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Te += Pe.length;
    }
    return Be;
  };
  function ge(ce, j) {
    if (h.isBuffer(ce))
      return ce.length;
    if (ArrayBuffer.isView(ce) || we(ce, ArrayBuffer))
      return ce.byteLength;
    if (typeof ce != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ce
      );
    var z = ce.length, oe = arguments.length > 2 && arguments[2] === !0;
    if (!oe && z === 0)
      return 0;
    for (var Be = !1; ; )
      switch (j) {
        case "ascii":
        case "latin1":
        case "binary":
          return z;
        case "utf8":
        case "utf-8":
          return H(ce).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return z * 2;
        case "hex":
          return z >>> 1;
        case "base64":
          return fe(ce).length;
        default:
          if (Be)
            return oe ? -1 : H(ce).length;
          j = ("" + j).toLowerCase(), Be = !0;
      }
  }
  h.byteLength = ge;
  function be(ce, j, z) {
    var oe = !1;
    if ((j === void 0 || j < 0) && (j = 0), j > this.length || ((z === void 0 || z > this.length) && (z = this.length), z <= 0) || (z >>>= 0, j >>>= 0, z <= j))
      return "";
    for (ce || (ce = "utf8"); ; )
      switch (ce) {
        case "hex":
          return k(this, j, z);
        case "utf8":
        case "utf-8":
          return c(this, j, z);
        case "ascii":
          return x(this, j, z);
        case "latin1":
        case "binary":
          return B(this, j, z);
        case "base64":
          return E(this, j, z);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return w(this, j, z);
        default:
          if (oe)
            throw new TypeError("Unknown encoding: " + ce);
          ce = (ce + "").toLowerCase(), oe = !0;
      }
  }
  h.prototype._isBuffer = !0;
  function Ee(ce, j, z) {
    var oe = ce[j];
    ce[j] = ce[z], ce[z] = oe;
  }
  h.prototype.swap16 = function() {
    var j = this.length;
    if (j % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var z = 0; z < j; z += 2)
      Ee(this, z, z + 1);
    return this;
  }, h.prototype.swap32 = function() {
    var j = this.length;
    if (j % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var z = 0; z < j; z += 4)
      Ee(this, z, z + 3), Ee(this, z + 1, z + 2);
    return this;
  }, h.prototype.swap64 = function() {
    var j = this.length;
    if (j % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var z = 0; z < j; z += 8)
      Ee(this, z, z + 7), Ee(this, z + 1, z + 6), Ee(this, z + 2, z + 5), Ee(this, z + 3, z + 4);
    return this;
  }, h.prototype.toString = function() {
    var j = this.length;
    return j === 0 ? "" : arguments.length === 0 ? c(this, 0, j) : be.apply(this, arguments);
  }, h.prototype.toLocaleString = h.prototype.toString, h.prototype.equals = function(j) {
    if (!h.isBuffer(j))
      throw new TypeError("Argument must be a Buffer");
    return this === j ? !0 : h.compare(this, j) === 0;
  }, h.prototype.inspect = function() {
    var j = "", z = e.INSPECT_MAX_BYTES;
    return j = this.toString("hex", 0, z).replace(/(.{2})/g, "$1 ").trim(), this.length > z && (j += " ... "), "<Buffer " + j + ">";
  }, n && (h.prototype[n] = h.prototype.inspect), h.prototype.compare = function(j, z, oe, Be, Te) {
    if (we(j, Uint8Array) && (j = h.from(j, j.offset, j.byteLength)), !h.isBuffer(j))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof j
      );
    if (z === void 0 && (z = 0), oe === void 0 && (oe = j ? j.length : 0), Be === void 0 && (Be = 0), Te === void 0 && (Te = this.length), z < 0 || oe > j.length || Be < 0 || Te > this.length)
      throw new RangeError("out of range index");
    if (Be >= Te && z >= oe)
      return 0;
    if (Be >= Te)
      return -1;
    if (z >= oe)
      return 1;
    if (z >>>= 0, oe >>>= 0, Be >>>= 0, Te >>>= 0, this === j)
      return 0;
    for (var Pe = Te - Be, Ye = oe - z, He = Math.min(Pe, Ye), ot = this.slice(Be, Te), at = j.slice(z, oe), Qe = 0; Qe < He; ++Qe)
      if (ot[Qe] !== at[Qe]) {
        Pe = ot[Qe], Ye = at[Qe];
        break;
      }
    return Pe < Ye ? -1 : Ye < Pe ? 1 : 0;
  };
  function xe(ce, j, z, oe, Be) {
    if (ce.length === 0)
      return -1;
    if (typeof z == "string" ? (oe = z, z = 0) : z > 2147483647 ? z = 2147483647 : z < -2147483648 && (z = -2147483648), z = +z, ke(z) && (z = Be ? 0 : ce.length - 1), z < 0 && (z = ce.length + z), z >= ce.length) {
      if (Be)
        return -1;
      z = ce.length - 1;
    } else if (z < 0)
      if (Be)
        z = 0;
      else
        return -1;
    if (typeof j == "string" && (j = h.from(j, oe)), h.isBuffer(j))
      return j.length === 0 ? -1 : Le(ce, j, z, oe, Be);
    if (typeof j == "number")
      return j = j & 255, typeof Uint8Array.prototype.indexOf == "function" ? Be ? Uint8Array.prototype.indexOf.call(ce, j, z) : Uint8Array.prototype.lastIndexOf.call(ce, j, z) : Le(ce, [j], z, oe, Be);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Le(ce, j, z, oe, Be) {
    var Te = 1, Pe = ce.length, Ye = j.length;
    if (oe !== void 0 && (oe = String(oe).toLowerCase(), oe === "ucs2" || oe === "ucs-2" || oe === "utf16le" || oe === "utf-16le")) {
      if (ce.length < 2 || j.length < 2)
        return -1;
      Te = 2, Pe /= 2, Ye /= 2, z /= 2;
    }
    function He(It, pt) {
      return Te === 1 ? It[pt] : It.readUInt16BE(pt * Te);
    }
    var ot;
    if (Be) {
      var at = -1;
      for (ot = z; ot < Pe; ot++)
        if (He(ce, ot) === He(j, at === -1 ? 0 : ot - at)) {
          if (at === -1 && (at = ot), ot - at + 1 === Ye)
            return at * Te;
        } else
          at !== -1 && (ot -= ot - at), at = -1;
    } else
      for (z + Ye > Pe && (z = Pe - Ye), ot = z; ot >= 0; ot--) {
        for (var Qe = !0, Pt = 0; Pt < Ye; Pt++)
          if (He(ce, ot + Pt) !== He(j, Pt)) {
            Qe = !1;
            break;
          }
        if (Qe)
          return ot;
      }
    return -1;
  }
  h.prototype.includes = function(j, z, oe) {
    return this.indexOf(j, z, oe) !== -1;
  }, h.prototype.indexOf = function(j, z, oe) {
    return xe(this, j, z, oe, !0);
  }, h.prototype.lastIndexOf = function(j, z, oe) {
    return xe(this, j, z, oe, !1);
  };
  function Ne(ce, j, z, oe) {
    z = Number(z) || 0;
    var Be = ce.length - z;
    oe ? (oe = Number(oe), oe > Be && (oe = Be)) : oe = Be;
    var Te = j.length;
    oe > Te / 2 && (oe = Te / 2);
    for (var Pe = 0; Pe < oe; ++Pe) {
      var Ye = parseInt(j.substr(Pe * 2, 2), 16);
      if (ke(Ye))
        return Pe;
      ce[z + Pe] = Ye;
    }
    return Pe;
  }
  function Re(ce, j, z, oe) {
    return re(H(j, ce.length - z), ce, z, oe);
  }
  function Xe(ce, j, z, oe) {
    return re(he(j), ce, z, oe);
  }
  function pe(ce, j, z, oe) {
    return re(fe(j), ce, z, oe);
  }
  function O(ce, j, z, oe) {
    return re(me(j, ce.length - z), ce, z, oe);
  }
  h.prototype.write = function(j, z, oe, Be) {
    if (z === void 0)
      Be = "utf8", oe = this.length, z = 0;
    else if (oe === void 0 && typeof z == "string")
      Be = z, oe = this.length, z = 0;
    else if (isFinite(z))
      z = z >>> 0, isFinite(oe) ? (oe = oe >>> 0, Be === void 0 && (Be = "utf8")) : (Be = oe, oe = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var Te = this.length - z;
    if ((oe === void 0 || oe > Te) && (oe = Te), j.length > 0 && (oe < 0 || z < 0) || z > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Be || (Be = "utf8");
    for (var Pe = !1; ; )
      switch (Be) {
        case "hex":
          return Ne(this, j, z, oe);
        case "utf8":
        case "utf-8":
          return Re(this, j, z, oe);
        case "ascii":
        case "latin1":
        case "binary":
          return Xe(this, j, z, oe);
        case "base64":
          return pe(this, j, z, oe);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return O(this, j, z, oe);
        default:
          if (Pe)
            throw new TypeError("Unknown encoding: " + Be);
          Be = ("" + Be).toLowerCase(), Pe = !0;
      }
  }, h.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function E(ce, j, z) {
    return j === 0 && z === ce.length ? t.fromByteArray(ce) : t.fromByteArray(ce.slice(j, z));
  }
  function c(ce, j, z) {
    z = Math.min(ce.length, z);
    for (var oe = [], Be = j; Be < z; ) {
      var Te = ce[Be], Pe = null, Ye = Te > 239 ? 4 : Te > 223 ? 3 : Te > 191 ? 2 : 1;
      if (Be + Ye <= z) {
        var He, ot, at, Qe;
        switch (Ye) {
          case 1:
            Te < 128 && (Pe = Te);
            break;
          case 2:
            He = ce[Be + 1], (He & 192) === 128 && (Qe = (Te & 31) << 6 | He & 63, Qe > 127 && (Pe = Qe));
            break;
          case 3:
            He = ce[Be + 1], ot = ce[Be + 2], (He & 192) === 128 && (ot & 192) === 128 && (Qe = (Te & 15) << 12 | (He & 63) << 6 | ot & 63, Qe > 2047 && (Qe < 55296 || Qe > 57343) && (Pe = Qe));
            break;
          case 4:
            He = ce[Be + 1], ot = ce[Be + 2], at = ce[Be + 3], (He & 192) === 128 && (ot & 192) === 128 && (at & 192) === 128 && (Qe = (Te & 15) << 18 | (He & 63) << 12 | (ot & 63) << 6 | at & 63, Qe > 65535 && Qe < 1114112 && (Pe = Qe));
        }
      }
      Pe === null ? (Pe = 65533, Ye = 1) : Pe > 65535 && (Pe -= 65536, oe.push(Pe >>> 10 & 1023 | 55296), Pe = 56320 | Pe & 1023), oe.push(Pe), Be += Ye;
    }
    return C(oe);
  }
  var b = 4096;
  function C(ce) {
    var j = ce.length;
    if (j <= b)
      return String.fromCharCode.apply(String, ce);
    for (var z = "", oe = 0; oe < j; )
      z += String.fromCharCode.apply(
        String,
        ce.slice(oe, oe += b)
      );
    return z;
  }
  function x(ce, j, z) {
    var oe = "";
    z = Math.min(ce.length, z);
    for (var Be = j; Be < z; ++Be)
      oe += String.fromCharCode(ce[Be] & 127);
    return oe;
  }
  function B(ce, j, z) {
    var oe = "";
    z = Math.min(ce.length, z);
    for (var Be = j; Be < z; ++Be)
      oe += String.fromCharCode(ce[Be]);
    return oe;
  }
  function k(ce, j, z) {
    var oe = ce.length;
    (!j || j < 0) && (j = 0), (!z || z < 0 || z > oe) && (z = oe);
    for (var Be = "", Te = j; Te < z; ++Te)
      Be += Oe[ce[Te]];
    return Be;
  }
  function w(ce, j, z) {
    for (var oe = ce.slice(j, z), Be = "", Te = 0; Te < oe.length - 1; Te += 2)
      Be += String.fromCharCode(oe[Te] + oe[Te + 1] * 256);
    return Be;
  }
  h.prototype.slice = function(j, z) {
    var oe = this.length;
    j = ~~j, z = z === void 0 ? oe : ~~z, j < 0 ? (j += oe, j < 0 && (j = 0)) : j > oe && (j = oe), z < 0 ? (z += oe, z < 0 && (z = 0)) : z > oe && (z = oe), z < j && (z = j);
    var Be = this.subarray(j, z);
    return Object.setPrototypeOf(Be, h.prototype), Be;
  };
  function T(ce, j, z) {
    if (ce % 1 !== 0 || ce < 0)
      throw new RangeError("offset is not uint");
    if (ce + j > z)
      throw new RangeError("Trying to access beyond buffer length");
  }
  h.prototype.readUintLE = h.prototype.readUIntLE = function(j, z, oe) {
    j = j >>> 0, z = z >>> 0, oe || T(j, z, this.length);
    for (var Be = this[j], Te = 1, Pe = 0; ++Pe < z && (Te *= 256); )
      Be += this[j + Pe] * Te;
    return Be;
  }, h.prototype.readUintBE = h.prototype.readUIntBE = function(j, z, oe) {
    j = j >>> 0, z = z >>> 0, oe || T(j, z, this.length);
    for (var Be = this[j + --z], Te = 1; z > 0 && (Te *= 256); )
      Be += this[j + --z] * Te;
    return Be;
  }, h.prototype.readUint8 = h.prototype.readUInt8 = function(j, z) {
    return j = j >>> 0, z || T(j, 1, this.length), this[j];
  }, h.prototype.readUint16LE = h.prototype.readUInt16LE = function(j, z) {
    return j = j >>> 0, z || T(j, 2, this.length), this[j] | this[j + 1] << 8;
  }, h.prototype.readUint16BE = h.prototype.readUInt16BE = function(j, z) {
    return j = j >>> 0, z || T(j, 2, this.length), this[j] << 8 | this[j + 1];
  }, h.prototype.readUint32LE = h.prototype.readUInt32LE = function(j, z) {
    return j = j >>> 0, z || T(j, 4, this.length), (this[j] | this[j + 1] << 8 | this[j + 2] << 16) + this[j + 3] * 16777216;
  }, h.prototype.readUint32BE = h.prototype.readUInt32BE = function(j, z) {
    return j = j >>> 0, z || T(j, 4, this.length), this[j] * 16777216 + (this[j + 1] << 16 | this[j + 2] << 8 | this[j + 3]);
  }, h.prototype.readIntLE = function(j, z, oe) {
    j = j >>> 0, z = z >>> 0, oe || T(j, z, this.length);
    for (var Be = this[j], Te = 1, Pe = 0; ++Pe < z && (Te *= 256); )
      Be += this[j + Pe] * Te;
    return Te *= 128, Be >= Te && (Be -= Math.pow(2, 8 * z)), Be;
  }, h.prototype.readIntBE = function(j, z, oe) {
    j = j >>> 0, z = z >>> 0, oe || T(j, z, this.length);
    for (var Be = z, Te = 1, Pe = this[j + --Be]; Be > 0 && (Te *= 256); )
      Pe += this[j + --Be] * Te;
    return Te *= 128, Pe >= Te && (Pe -= Math.pow(2, 8 * z)), Pe;
  }, h.prototype.readInt8 = function(j, z) {
    return j = j >>> 0, z || T(j, 1, this.length), this[j] & 128 ? (255 - this[j] + 1) * -1 : this[j];
  }, h.prototype.readInt16LE = function(j, z) {
    j = j >>> 0, z || T(j, 2, this.length);
    var oe = this[j] | this[j + 1] << 8;
    return oe & 32768 ? oe | 4294901760 : oe;
  }, h.prototype.readInt16BE = function(j, z) {
    j = j >>> 0, z || T(j, 2, this.length);
    var oe = this[j + 1] | this[j] << 8;
    return oe & 32768 ? oe | 4294901760 : oe;
  }, h.prototype.readInt32LE = function(j, z) {
    return j = j >>> 0, z || T(j, 4, this.length), this[j] | this[j + 1] << 8 | this[j + 2] << 16 | this[j + 3] << 24;
  }, h.prototype.readInt32BE = function(j, z) {
    return j = j >>> 0, z || T(j, 4, this.length), this[j] << 24 | this[j + 1] << 16 | this[j + 2] << 8 | this[j + 3];
  }, h.prototype.readFloatLE = function(j, z) {
    return j = j >>> 0, z || T(j, 4, this.length), a.read(this, j, !0, 23, 4);
  }, h.prototype.readFloatBE = function(j, z) {
    return j = j >>> 0, z || T(j, 4, this.length), a.read(this, j, !1, 23, 4);
  }, h.prototype.readDoubleLE = function(j, z) {
    return j = j >>> 0, z || T(j, 8, this.length), a.read(this, j, !0, 52, 8);
  }, h.prototype.readDoubleBE = function(j, z) {
    return j = j >>> 0, z || T(j, 8, this.length), a.read(this, j, !1, 52, 8);
  };
  function p(ce, j, z, oe, Be, Te) {
    if (!h.isBuffer(ce))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (j > Be || j < Te)
      throw new RangeError('"value" argument is out of bounds');
    if (z + oe > ce.length)
      throw new RangeError("Index out of range");
  }
  h.prototype.writeUintLE = h.prototype.writeUIntLE = function(j, z, oe, Be) {
    if (j = +j, z = z >>> 0, oe = oe >>> 0, !Be) {
      var Te = Math.pow(2, 8 * oe) - 1;
      p(this, j, z, oe, Te, 0);
    }
    var Pe = 1, Ye = 0;
    for (this[z] = j & 255; ++Ye < oe && (Pe *= 256); )
      this[z + Ye] = j / Pe & 255;
    return z + oe;
  }, h.prototype.writeUintBE = h.prototype.writeUIntBE = function(j, z, oe, Be) {
    if (j = +j, z = z >>> 0, oe = oe >>> 0, !Be) {
      var Te = Math.pow(2, 8 * oe) - 1;
      p(this, j, z, oe, Te, 0);
    }
    var Pe = oe - 1, Ye = 1;
    for (this[z + Pe] = j & 255; --Pe >= 0 && (Ye *= 256); )
      this[z + Pe] = j / Ye & 255;
    return z + oe;
  }, h.prototype.writeUint8 = h.prototype.writeUInt8 = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 1, 255, 0), this[z] = j & 255, z + 1;
  }, h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 2, 65535, 0), this[z] = j & 255, this[z + 1] = j >>> 8, z + 2;
  }, h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 2, 65535, 0), this[z] = j >>> 8, this[z + 1] = j & 255, z + 2;
  }, h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 4, 4294967295, 0), this[z + 3] = j >>> 24, this[z + 2] = j >>> 16, this[z + 1] = j >>> 8, this[z] = j & 255, z + 4;
  }, h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 4, 4294967295, 0), this[z] = j >>> 24, this[z + 1] = j >>> 16, this[z + 2] = j >>> 8, this[z + 3] = j & 255, z + 4;
  }, h.prototype.writeIntLE = function(j, z, oe, Be) {
    if (j = +j, z = z >>> 0, !Be) {
      var Te = Math.pow(2, 8 * oe - 1);
      p(this, j, z, oe, Te - 1, -Te);
    }
    var Pe = 0, Ye = 1, He = 0;
    for (this[z] = j & 255; ++Pe < oe && (Ye *= 256); )
      j < 0 && He === 0 && this[z + Pe - 1] !== 0 && (He = 1), this[z + Pe] = (j / Ye >> 0) - He & 255;
    return z + oe;
  }, h.prototype.writeIntBE = function(j, z, oe, Be) {
    if (j = +j, z = z >>> 0, !Be) {
      var Te = Math.pow(2, 8 * oe - 1);
      p(this, j, z, oe, Te - 1, -Te);
    }
    var Pe = oe - 1, Ye = 1, He = 0;
    for (this[z + Pe] = j & 255; --Pe >= 0 && (Ye *= 256); )
      j < 0 && He === 0 && this[z + Pe + 1] !== 0 && (He = 1), this[z + Pe] = (j / Ye >> 0) - He & 255;
    return z + oe;
  }, h.prototype.writeInt8 = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 1, 127, -128), j < 0 && (j = 255 + j + 1), this[z] = j & 255, z + 1;
  }, h.prototype.writeInt16LE = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 2, 32767, -32768), this[z] = j & 255, this[z + 1] = j >>> 8, z + 2;
  }, h.prototype.writeInt16BE = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 2, 32767, -32768), this[z] = j >>> 8, this[z + 1] = j & 255, z + 2;
  }, h.prototype.writeInt32LE = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 4, 2147483647, -2147483648), this[z] = j & 255, this[z + 1] = j >>> 8, this[z + 2] = j >>> 16, this[z + 3] = j >>> 24, z + 4;
  }, h.prototype.writeInt32BE = function(j, z, oe) {
    return j = +j, z = z >>> 0, oe || p(this, j, z, 4, 2147483647, -2147483648), j < 0 && (j = 4294967295 + j + 1), this[z] = j >>> 24, this[z + 1] = j >>> 16, this[z + 2] = j >>> 8, this[z + 3] = j & 255, z + 4;
  };
  function F(ce, j, z, oe, Be, Te) {
    if (z + oe > ce.length)
      throw new RangeError("Index out of range");
    if (z < 0)
      throw new RangeError("Index out of range");
  }
  function ye(ce, j, z, oe, Be) {
    return j = +j, z = z >>> 0, Be || F(ce, j, z, 4), a.write(ce, j, z, oe, 23, 4), z + 4;
  }
  h.prototype.writeFloatLE = function(j, z, oe) {
    return ye(this, j, z, !0, oe);
  }, h.prototype.writeFloatBE = function(j, z, oe) {
    return ye(this, j, z, !1, oe);
  };
  function _e(ce, j, z, oe, Be) {
    return j = +j, z = z >>> 0, Be || F(ce, j, z, 8), a.write(ce, j, z, oe, 52, 8), z + 8;
  }
  h.prototype.writeDoubleLE = function(j, z, oe) {
    return _e(this, j, z, !0, oe);
  }, h.prototype.writeDoubleBE = function(j, z, oe) {
    return _e(this, j, z, !1, oe);
  }, h.prototype.copy = function(j, z, oe, Be) {
    if (!h.isBuffer(j))
      throw new TypeError("argument should be a Buffer");
    if (oe || (oe = 0), !Be && Be !== 0 && (Be = this.length), z >= j.length && (z = j.length), z || (z = 0), Be > 0 && Be < oe && (Be = oe), Be === oe || j.length === 0 || this.length === 0)
      return 0;
    if (z < 0)
      throw new RangeError("targetStart out of bounds");
    if (oe < 0 || oe >= this.length)
      throw new RangeError("Index out of range");
    if (Be < 0)
      throw new RangeError("sourceEnd out of bounds");
    Be > this.length && (Be = this.length), j.length - z < Be - oe && (Be = j.length - z + oe);
    var Te = Be - oe;
    return this === j && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(z, oe, Be) : Uint8Array.prototype.set.call(
      j,
      this.subarray(oe, Be),
      z
    ), Te;
  }, h.prototype.fill = function(j, z, oe, Be) {
    if (typeof j == "string") {
      if (typeof z == "string" ? (Be = z, z = 0, oe = this.length) : typeof oe == "string" && (Be = oe, oe = this.length), Be !== void 0 && typeof Be != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Be == "string" && !h.isEncoding(Be))
        throw new TypeError("Unknown encoding: " + Be);
      if (j.length === 1) {
        var Te = j.charCodeAt(0);
        (Be === "utf8" && Te < 128 || Be === "latin1") && (j = Te);
      }
    } else
      typeof j == "number" ? j = j & 255 : typeof j == "boolean" && (j = Number(j));
    if (z < 0 || this.length < z || this.length < oe)
      throw new RangeError("Out of range index");
    if (oe <= z)
      return this;
    z = z >>> 0, oe = oe === void 0 ? this.length : oe >>> 0, j || (j = 0);
    var Pe;
    if (typeof j == "number")
      for (Pe = z; Pe < oe; ++Pe)
        this[Pe] = j;
    else {
      var Ye = h.isBuffer(j) ? j : h.from(j, Be), He = Ye.length;
      if (He === 0)
        throw new TypeError('The value "' + j + '" is invalid for argument "value"');
      for (Pe = 0; Pe < oe - z; ++Pe)
        this[Pe + z] = Ye[Pe % He];
    }
    return this;
  };
  var de = /[^+/0-9A-Za-z-_]/g;
  function P(ce) {
    if (ce = ce.split("=")[0], ce = ce.trim().replace(de, ""), ce.length < 2)
      return "";
    for (; ce.length % 4 !== 0; )
      ce = ce + "=";
    return ce;
  }
  function H(ce, j) {
    j = j || 1 / 0;
    for (var z, oe = ce.length, Be = null, Te = [], Pe = 0; Pe < oe; ++Pe) {
      if (z = ce.charCodeAt(Pe), z > 55295 && z < 57344) {
        if (!Be) {
          if (z > 56319) {
            (j -= 3) > -1 && Te.push(239, 191, 189);
            continue;
          } else if (Pe + 1 === oe) {
            (j -= 3) > -1 && Te.push(239, 191, 189);
            continue;
          }
          Be = z;
          continue;
        }
        if (z < 56320) {
          (j -= 3) > -1 && Te.push(239, 191, 189), Be = z;
          continue;
        }
        z = (Be - 55296 << 10 | z - 56320) + 65536;
      } else
        Be && (j -= 3) > -1 && Te.push(239, 191, 189);
      if (Be = null, z < 128) {
        if ((j -= 1) < 0)
          break;
        Te.push(z);
      } else if (z < 2048) {
        if ((j -= 2) < 0)
          break;
        Te.push(
          z >> 6 | 192,
          z & 63 | 128
        );
      } else if (z < 65536) {
        if ((j -= 3) < 0)
          break;
        Te.push(
          z >> 12 | 224,
          z >> 6 & 63 | 128,
          z & 63 | 128
        );
      } else if (z < 1114112) {
        if ((j -= 4) < 0)
          break;
        Te.push(
          z >> 18 | 240,
          z >> 12 & 63 | 128,
          z >> 6 & 63 | 128,
          z & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Te;
  }
  function he(ce) {
    for (var j = [], z = 0; z < ce.length; ++z)
      j.push(ce.charCodeAt(z) & 255);
    return j;
  }
  function me(ce, j) {
    for (var z, oe, Be, Te = [], Pe = 0; Pe < ce.length && !((j -= 2) < 0); ++Pe)
      z = ce.charCodeAt(Pe), oe = z >> 8, Be = z % 256, Te.push(Be), Te.push(oe);
    return Te;
  }
  function fe(ce) {
    return t.toByteArray(P(ce));
  }
  function re(ce, j, z, oe) {
    for (var Be = 0; Be < oe && !(Be + z >= j.length || Be >= ce.length); ++Be)
      j[Be + z] = ce[Be];
    return Be;
  }
  function we(ce, j) {
    return ce instanceof j || ce != null && ce.constructor != null && ce.constructor.name != null && ce.constructor.name === j.name;
  }
  function ke(ce) {
    return ce !== ce;
  }
  var Oe = function() {
    for (var ce = "0123456789abcdef", j = new Array(256), z = 0; z < 16; ++z)
      for (var oe = z * 16, Be = 0; Be < 16; ++Be)
        j[oe + Be] = ce[z] + ce[Be];
    return j;
  }();
})(buffer$1);
var jsbn = { exports: {} };
(function(e, t) {
  (function() {
    var a, n = 244837814094590, u = (n & 16777215) == 15715070;
    function o(te, se, ve) {
      te != null && (typeof te == "number" ? this.fromNumber(te, se, ve) : se == null && typeof te != "string" ? this.fromString(te, 256) : this.fromString(te, se));
    }
    function l() {
      return new o(null);
    }
    function h(te, se, ve, Ae, Fe, je) {
      for (; --je >= 0; ) {
        var st = se * this[te++] + ve[Ae] + Fe;
        Fe = Math.floor(st / 67108864), ve[Ae++] = st & 67108863;
      }
      return Fe;
    }
    function y(te, se, ve, Ae, Fe, je) {
      for (var st = se & 32767, yt = se >> 15; --je >= 0; ) {
        var tr = this[te] & 32767, nr = this[te++] >> 15, fr = yt * tr + nr * st;
        tr = st * tr + ((fr & 32767) << 15) + ve[Ae] + (Fe & 1073741823), Fe = (tr >>> 30) + (fr >>> 15) + yt * nr + (Fe >>> 30), ve[Ae++] = tr & 1073741823;
      }
      return Fe;
    }
    function _(te, se, ve, Ae, Fe, je) {
      for (var st = se & 16383, yt = se >> 14; --je >= 0; ) {
        var tr = this[te] & 16383, nr = this[te++] >> 14, fr = yt * tr + nr * st;
        tr = st * tr + ((fr & 16383) << 14) + ve[Ae] + Fe, Fe = (tr >> 28) + (fr >> 14) + yt * nr, ve[Ae++] = tr & 268435455;
      }
      return Fe;
    }
    var d = typeof navigator < "u";
    d && u && navigator.appName == "Microsoft Internet Explorer" ? (o.prototype.am = y, a = 30) : d && u && navigator.appName != "Netscape" ? (o.prototype.am = h, a = 26) : (o.prototype.am = _, a = 28), o.prototype.DB = a, o.prototype.DM = (1 << a) - 1, o.prototype.DV = 1 << a;
    var $ = 52;
    o.prototype.FV = Math.pow(2, $), o.prototype.F1 = $ - a, o.prototype.F2 = 2 * a - $;
    var N = "0123456789abcdefghijklmnopqrstuvwxyz", U = new Array(), V, Q;
    for (V = "0".charCodeAt(0), Q = 0; Q <= 9; ++Q)
      U[V++] = Q;
    for (V = "a".charCodeAt(0), Q = 10; Q < 36; ++Q)
      U[V++] = Q;
    for (V = "A".charCodeAt(0), Q = 10; Q < 36; ++Q)
      U[V++] = Q;
    function ie(te) {
      return N.charAt(te);
    }
    function ee(te, se) {
      var ve = U[te.charCodeAt(se)];
      return ve ?? -1;
    }
    function ne(te) {
      for (var se = this.t - 1; se >= 0; --se)
        te[se] = this[se];
      te.t = this.t, te.s = this.s;
    }
    function ge(te) {
      this.t = 1, this.s = te < 0 ? -1 : 0, te > 0 ? this[0] = te : te < -1 ? this[0] = te + this.DV : this.t = 0;
    }
    function be(te) {
      var se = l();
      return se.fromInt(te), se;
    }
    function Ee(te, se) {
      var ve;
      if (se == 16)
        ve = 4;
      else if (se == 8)
        ve = 3;
      else if (se == 256)
        ve = 8;
      else if (se == 2)
        ve = 1;
      else if (se == 32)
        ve = 5;
      else if (se == 4)
        ve = 2;
      else {
        this.fromRadix(te, se);
        return;
      }
      this.t = 0, this.s = 0;
      for (var Ae = te.length, Fe = !1, je = 0; --Ae >= 0; ) {
        var st = ve == 8 ? te[Ae] & 255 : ee(te, Ae);
        if (st < 0) {
          te.charAt(Ae) == "-" && (Fe = !0);
          continue;
        }
        Fe = !1, je == 0 ? this[this.t++] = st : je + ve > this.DB ? (this[this.t - 1] |= (st & (1 << this.DB - je) - 1) << je, this[this.t++] = st >> this.DB - je) : this[this.t - 1] |= st << je, je += ve, je >= this.DB && (je -= this.DB);
      }
      ve == 8 && te[0] & 128 && (this.s = -1, je > 0 && (this[this.t - 1] |= (1 << this.DB - je) - 1 << je)), this.clamp(), Fe && o.ZERO.subTo(this, this);
    }
    function xe() {
      for (var te = this.s & this.DM; this.t > 0 && this[this.t - 1] == te; )
        --this.t;
    }
    function Le(te) {
      if (this.s < 0)
        return "-" + this.negate().toString(te);
      var se;
      if (te == 16)
        se = 4;
      else if (te == 8)
        se = 3;
      else if (te == 2)
        se = 1;
      else if (te == 32)
        se = 5;
      else if (te == 4)
        se = 2;
      else
        return this.toRadix(te);
      var ve = (1 << se) - 1, Ae, Fe = !1, je = "", st = this.t, yt = this.DB - st * this.DB % se;
      if (st-- > 0)
        for (yt < this.DB && (Ae = this[st] >> yt) > 0 && (Fe = !0, je = ie(Ae)); st >= 0; )
          yt < se ? (Ae = (this[st] & (1 << yt) - 1) << se - yt, Ae |= this[--st] >> (yt += this.DB - se)) : (Ae = this[st] >> (yt -= se) & ve, yt <= 0 && (yt += this.DB, --st)), Ae > 0 && (Fe = !0), Fe && (je += ie(Ae));
      return Fe ? je : "0";
    }
    function Ne() {
      var te = l();
      return o.ZERO.subTo(this, te), te;
    }
    function Re() {
      return this.s < 0 ? this.negate() : this;
    }
    function Xe(te) {
      var se = this.s - te.s;
      if (se != 0)
        return se;
      var ve = this.t;
      if (se = ve - te.t, se != 0)
        return this.s < 0 ? -se : se;
      for (; --ve >= 0; )
        if ((se = this[ve] - te[ve]) != 0)
          return se;
      return 0;
    }
    function pe(te) {
      var se = 1, ve;
      return (ve = te >>> 16) != 0 && (te = ve, se += 16), (ve = te >> 8) != 0 && (te = ve, se += 8), (ve = te >> 4) != 0 && (te = ve, se += 4), (ve = te >> 2) != 0 && (te = ve, se += 2), (ve = te >> 1) != 0 && (te = ve, se += 1), se;
    }
    function O() {
      return this.t <= 0 ? 0 : this.DB * (this.t - 1) + pe(this[this.t - 1] ^ this.s & this.DM);
    }
    function E(te, se) {
      var ve;
      for (ve = this.t - 1; ve >= 0; --ve)
        se[ve + te] = this[ve];
      for (ve = te - 1; ve >= 0; --ve)
        se[ve] = 0;
      se.t = this.t + te, se.s = this.s;
    }
    function c(te, se) {
      for (var ve = te; ve < this.t; ++ve)
        se[ve - te] = this[ve];
      se.t = Math.max(this.t - te, 0), se.s = this.s;
    }
    function b(te, se) {
      var ve = te % this.DB, Ae = this.DB - ve, Fe = (1 << Ae) - 1, je = Math.floor(te / this.DB), st = this.s << ve & this.DM, yt;
      for (yt = this.t - 1; yt >= 0; --yt)
        se[yt + je + 1] = this[yt] >> Ae | st, st = (this[yt] & Fe) << ve;
      for (yt = je - 1; yt >= 0; --yt)
        se[yt] = 0;
      se[je] = st, se.t = this.t + je + 1, se.s = this.s, se.clamp();
    }
    function C(te, se) {
      se.s = this.s;
      var ve = Math.floor(te / this.DB);
      if (ve >= this.t) {
        se.t = 0;
        return;
      }
      var Ae = te % this.DB, Fe = this.DB - Ae, je = (1 << Ae) - 1;
      se[0] = this[ve] >> Ae;
      for (var st = ve + 1; st < this.t; ++st)
        se[st - ve - 1] |= (this[st] & je) << Fe, se[st - ve] = this[st] >> Ae;
      Ae > 0 && (se[this.t - ve - 1] |= (this.s & je) << Fe), se.t = this.t - ve, se.clamp();
    }
    function x(te, se) {
      for (var ve = 0, Ae = 0, Fe = Math.min(te.t, this.t); ve < Fe; )
        Ae += this[ve] - te[ve], se[ve++] = Ae & this.DM, Ae >>= this.DB;
      if (te.t < this.t) {
        for (Ae -= te.s; ve < this.t; )
          Ae += this[ve], se[ve++] = Ae & this.DM, Ae >>= this.DB;
        Ae += this.s;
      } else {
        for (Ae += this.s; ve < te.t; )
          Ae -= te[ve], se[ve++] = Ae & this.DM, Ae >>= this.DB;
        Ae -= te.s;
      }
      se.s = Ae < 0 ? -1 : 0, Ae < -1 ? se[ve++] = this.DV + Ae : Ae > 0 && (se[ve++] = Ae), se.t = ve, se.clamp();
    }
    function B(te, se) {
      var ve = this.abs(), Ae = te.abs(), Fe = ve.t;
      for (se.t = Fe + Ae.t; --Fe >= 0; )
        se[Fe] = 0;
      for (Fe = 0; Fe < Ae.t; ++Fe)
        se[Fe + ve.t] = ve.am(0, Ae[Fe], se, Fe, 0, ve.t);
      se.s = 0, se.clamp(), this.s != te.s && o.ZERO.subTo(se, se);
    }
    function k(te) {
      for (var se = this.abs(), ve = te.t = 2 * se.t; --ve >= 0; )
        te[ve] = 0;
      for (ve = 0; ve < se.t - 1; ++ve) {
        var Ae = se.am(ve, se[ve], te, 2 * ve, 0, 1);
        (te[ve + se.t] += se.am(ve + 1, 2 * se[ve], te, 2 * ve + 1, Ae, se.t - ve - 1)) >= se.DV && (te[ve + se.t] -= se.DV, te[ve + se.t + 1] = 1);
      }
      te.t > 0 && (te[te.t - 1] += se.am(ve, se[ve], te, 2 * ve, 0, 1)), te.s = 0, te.clamp();
    }
    function w(te, se, ve) {
      var Ae = te.abs();
      if (!(Ae.t <= 0)) {
        var Fe = this.abs();
        if (Fe.t < Ae.t) {
          se != null && se.fromInt(0), ve != null && this.copyTo(ve);
          return;
        }
        ve == null && (ve = l());
        var je = l(), st = this.s, yt = te.s, tr = this.DB - pe(Ae[Ae.t - 1]);
        tr > 0 ? (Ae.lShiftTo(tr, je), Fe.lShiftTo(tr, ve)) : (Ae.copyTo(je), Fe.copyTo(ve));
        var nr = je.t, fr = je[nr - 1];
        if (fr != 0) {
          var ar = fr * (1 << this.F1) + (nr > 1 ? je[nr - 2] >> this.F2 : 0), lr = this.FV / ar, dr = (1 << this.F1) / ar, or = 1 << this.F2, ur = ve.t, pr = ur - nr, cr = se ?? l();
          for (je.dlShiftTo(pr, cr), ve.compareTo(cr) >= 0 && (ve[ve.t++] = 1, ve.subTo(cr, ve)), o.ONE.dlShiftTo(nr, cr), cr.subTo(je, je); je.t < nr; )
            je[je.t++] = 0;
          for (; --pr >= 0; ) {
            var vr = ve[--ur] == fr ? this.DM : Math.floor(ve[ur] * lr + (ve[ur - 1] + or) * dr);
            if ((ve[ur] += je.am(0, vr, ve, pr, 0, nr)) < vr)
              for (je.dlShiftTo(pr, cr), ve.subTo(cr, ve); ve[ur] < --vr; )
                ve.subTo(cr, ve);
          }
          se != null && (ve.drShiftTo(nr, se), st != yt && o.ZERO.subTo(se, se)), ve.t = nr, ve.clamp(), tr > 0 && ve.rShiftTo(tr, ve), st < 0 && o.ZERO.subTo(ve, ve);
        }
      }
    }
    function T(te) {
      var se = l();
      return this.abs().divRemTo(te, null, se), this.s < 0 && se.compareTo(o.ZERO) > 0 && te.subTo(se, se), se;
    }
    function p(te) {
      this.m = te;
    }
    function F(te) {
      return te.s < 0 || te.compareTo(this.m) >= 0 ? te.mod(this.m) : te;
    }
    function ye(te) {
      return te;
    }
    function _e(te) {
      te.divRemTo(this.m, null, te);
    }
    function de(te, se, ve) {
      te.multiplyTo(se, ve), this.reduce(ve);
    }
    function P(te, se) {
      te.squareTo(se), this.reduce(se);
    }
    p.prototype.convert = F, p.prototype.revert = ye, p.prototype.reduce = _e, p.prototype.mulTo = de, p.prototype.sqrTo = P;
    function H() {
      if (this.t < 1)
        return 0;
      var te = this[0];
      if (!(te & 1))
        return 0;
      var se = te & 3;
      return se = se * (2 - (te & 15) * se) & 15, se = se * (2 - (te & 255) * se) & 255, se = se * (2 - ((te & 65535) * se & 65535)) & 65535, se = se * (2 - te * se % this.DV) % this.DV, se > 0 ? this.DV - se : -se;
    }
    function he(te) {
      this.m = te, this.mp = te.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << te.DB - 15) - 1, this.mt2 = 2 * te.t;
    }
    function me(te) {
      var se = l();
      return te.abs().dlShiftTo(this.m.t, se), se.divRemTo(this.m, null, se), te.s < 0 && se.compareTo(o.ZERO) > 0 && this.m.subTo(se, se), se;
    }
    function fe(te) {
      var se = l();
      return te.copyTo(se), this.reduce(se), se;
    }
    function re(te) {
      for (; te.t <= this.mt2; )
        te[te.t++] = 0;
      for (var se = 0; se < this.m.t; ++se) {
        var ve = te[se] & 32767, Ae = ve * this.mpl + ((ve * this.mph + (te[se] >> 15) * this.mpl & this.um) << 15) & te.DM;
        for (ve = se + this.m.t, te[ve] += this.m.am(0, Ae, te, se, 0, this.m.t); te[ve] >= te.DV; )
          te[ve] -= te.DV, te[++ve]++;
      }
      te.clamp(), te.drShiftTo(this.m.t, te), te.compareTo(this.m) >= 0 && te.subTo(this.m, te);
    }
    function we(te, se) {
      te.squareTo(se), this.reduce(se);
    }
    function ke(te, se, ve) {
      te.multiplyTo(se, ve), this.reduce(ve);
    }
    he.prototype.convert = me, he.prototype.revert = fe, he.prototype.reduce = re, he.prototype.mulTo = ke, he.prototype.sqrTo = we;
    function Oe() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function ce(te, se) {
      if (te > 4294967295 || te < 1)
        return o.ONE;
      var ve = l(), Ae = l(), Fe = se.convert(this), je = pe(te) - 1;
      for (Fe.copyTo(ve); --je >= 0; )
        if (se.sqrTo(ve, Ae), (te & 1 << je) > 0)
          se.mulTo(Ae, Fe, ve);
        else {
          var st = ve;
          ve = Ae, Ae = st;
        }
      return se.revert(ve);
    }
    function j(te, se) {
      var ve;
      return te < 256 || se.isEven() ? ve = new p(se) : ve = new he(se), this.exp(te, ve);
    }
    o.prototype.copyTo = ne, o.prototype.fromInt = ge, o.prototype.fromString = Ee, o.prototype.clamp = xe, o.prototype.dlShiftTo = E, o.prototype.drShiftTo = c, o.prototype.lShiftTo = b, o.prototype.rShiftTo = C, o.prototype.subTo = x, o.prototype.multiplyTo = B, o.prototype.squareTo = k, o.prototype.divRemTo = w, o.prototype.invDigit = H, o.prototype.isEven = Oe, o.prototype.exp = ce, o.prototype.toString = Le, o.prototype.negate = Ne, o.prototype.abs = Re, o.prototype.compareTo = Xe, o.prototype.bitLength = O, o.prototype.mod = T, o.prototype.modPowInt = j, o.ZERO = be(0), o.ONE = be(1);
    function z() {
      var te = l();
      return this.copyTo(te), te;
    }
    function oe() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        if (this.t == 0)
          return -1;
      } else {
        if (this.t == 1)
          return this[0];
        if (this.t == 0)
          return 0;
      }
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function Be() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function Te() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function Pe(te) {
      return Math.floor(Math.LN2 * this.DB / Math.log(te));
    }
    function Ye() {
      return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1;
    }
    function He(te) {
      if (te == null && (te = 10), this.signum() == 0 || te < 2 || te > 36)
        return "0";
      var se = this.chunkSize(te), ve = Math.pow(te, se), Ae = be(ve), Fe = l(), je = l(), st = "";
      for (this.divRemTo(Ae, Fe, je); Fe.signum() > 0; )
        st = (ve + je.intValue()).toString(te).substr(1) + st, Fe.divRemTo(Ae, Fe, je);
      return je.intValue().toString(te) + st;
    }
    function ot(te, se) {
      this.fromInt(0), se == null && (se = 10);
      for (var ve = this.chunkSize(se), Ae = Math.pow(se, ve), Fe = !1, je = 0, st = 0, yt = 0; yt < te.length; ++yt) {
        var tr = ee(te, yt);
        if (tr < 0) {
          te.charAt(yt) == "-" && this.signum() == 0 && (Fe = !0);
          continue;
        }
        st = se * st + tr, ++je >= ve && (this.dMultiply(Ae), this.dAddOffset(st, 0), je = 0, st = 0);
      }
      je > 0 && (this.dMultiply(Math.pow(se, je)), this.dAddOffset(st, 0)), Fe && o.ZERO.subTo(this, this);
    }
    function at(te, se, ve) {
      if (typeof se == "number")
        if (te < 2)
          this.fromInt(1);
        else
          for (this.fromNumber(te, ve), this.testBit(te - 1) || this.bitwiseTo(o.ONE.shiftLeft(te - 1), Vt, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(se); )
            this.dAddOffset(2, 0), this.bitLength() > te && this.subTo(o.ONE.shiftLeft(te - 1), this);
      else {
        var Ae = new Array(), Fe = te & 7;
        Ae.length = (te >> 3) + 1, se.nextBytes(Ae), Fe > 0 ? Ae[0] &= (1 << Fe) - 1 : Ae[0] = 0, this.fromString(Ae, 256);
      }
    }
    function Qe() {
      var te = this.t, se = new Array();
      se[0] = this.s;
      var ve = this.DB - te * this.DB % 8, Ae, Fe = 0;
      if (te-- > 0)
        for (ve < this.DB && (Ae = this[te] >> ve) != (this.s & this.DM) >> ve && (se[Fe++] = Ae | this.s << this.DB - ve); te >= 0; )
          ve < 8 ? (Ae = (this[te] & (1 << ve) - 1) << 8 - ve, Ae |= this[--te] >> (ve += this.DB - 8)) : (Ae = this[te] >> (ve -= 8) & 255, ve <= 0 && (ve += this.DB, --te)), Ae & 128 && (Ae |= -256), Fe == 0 && (this.s & 128) != (Ae & 128) && ++Fe, (Fe > 0 || Ae != this.s) && (se[Fe++] = Ae);
      return se;
    }
    function Pt(te) {
      return this.compareTo(te) == 0;
    }
    function It(te) {
      return this.compareTo(te) < 0 ? this : te;
    }
    function pt(te) {
      return this.compareTo(te) > 0 ? this : te;
    }
    function Wt(te, se, ve) {
      var Ae, Fe, je = Math.min(te.t, this.t);
      for (Ae = 0; Ae < je; ++Ae)
        ve[Ae] = se(this[Ae], te[Ae]);
      if (te.t < this.t) {
        for (Fe = te.s & this.DM, Ae = je; Ae < this.t; ++Ae)
          ve[Ae] = se(this[Ae], Fe);
        ve.t = this.t;
      } else {
        for (Fe = this.s & this.DM, Ae = je; Ae < te.t; ++Ae)
          ve[Ae] = se(Fe, te[Ae]);
        ve.t = te.t;
      }
      ve.s = se(this.s, te.s), ve.clamp();
    }
    function Mt(te, se) {
      return te & se;
    }
    function vt(te) {
      var se = l();
      return this.bitwiseTo(te, Mt, se), se;
    }
    function Vt(te, se) {
      return te | se;
    }
    function Ct(te) {
      var se = l();
      return this.bitwiseTo(te, Vt, se), se;
    }
    function lt(te, se) {
      return te ^ se;
    }
    function zt(te) {
      var se = l();
      return this.bitwiseTo(te, lt, se), se;
    }
    function Tt(te, se) {
      return te & ~se;
    }
    function dt(te) {
      var se = l();
      return this.bitwiseTo(te, Tt, se), se;
    }
    function Yt() {
      for (var te = l(), se = 0; se < this.t; ++se)
        te[se] = this.DM & ~this[se];
      return te.t = this.t, te.s = ~this.s, te;
    }
    function Dt(te) {
      var se = l();
      return te < 0 ? this.rShiftTo(-te, se) : this.lShiftTo(te, se), se;
    }
    function bt(te) {
      var se = l();
      return te < 0 ? this.lShiftTo(-te, se) : this.rShiftTo(te, se), se;
    }
    function Jt(te) {
      if (te == 0)
        return -1;
      var se = 0;
      return te & 65535 || (te >>= 16, se += 16), te & 255 || (te >>= 8, se += 8), te & 15 || (te >>= 4, se += 4), te & 3 || (te >>= 2, se += 2), te & 1 || ++se, se;
    }
    function Bt() {
      for (var te = 0; te < this.t; ++te)
        if (this[te] != 0)
          return te * this.DB + Jt(this[te]);
      return this.s < 0 ? this.t * this.DB : -1;
    }
    function ut(te) {
      for (var se = 0; te != 0; )
        te &= te - 1, ++se;
      return se;
    }
    function Ht() {
      for (var te = 0, se = this.s & this.DM, ve = 0; ve < this.t; ++ve)
        te += ut(this[ve] ^ se);
      return te;
    }
    function Rt(te) {
      var se = Math.floor(te / this.DB);
      return se >= this.t ? this.s != 0 : (this[se] & 1 << te % this.DB) != 0;
    }
    function gt(te, se) {
      var ve = o.ONE.shiftLeft(te);
      return this.bitwiseTo(ve, se, ve), ve;
    }
    function Qt(te) {
      return this.changeBit(te, Vt);
    }
    function kt(te) {
      return this.changeBit(te, Tt);
    }
    function rt(te) {
      return this.changeBit(te, lt);
    }
    function Xt(te, se) {
      for (var ve = 0, Ae = 0, Fe = Math.min(te.t, this.t); ve < Fe; )
        Ae += this[ve] + te[ve], se[ve++] = Ae & this.DM, Ae >>= this.DB;
      if (te.t < this.t) {
        for (Ae += te.s; ve < this.t; )
          Ae += this[ve], se[ve++] = Ae & this.DM, Ae >>= this.DB;
        Ae += this.s;
      } else {
        for (Ae += this.s; ve < te.t; )
          Ae += te[ve], se[ve++] = Ae & this.DM, Ae >>= this.DB;
        Ae += te.s;
      }
      se.s = Ae < 0 ? -1 : 0, Ae > 0 ? se[ve++] = Ae : Ae < -1 && (se[ve++] = this.DV + Ae), se.t = ve, se.clamp();
    }
    function J(te) {
      var se = l();
      return this.addTo(te, se), se;
    }
    function ae(te) {
      var se = l();
      return this.subTo(te, se), se;
    }
    function ue(te) {
      var se = l();
      return this.multiplyTo(te, se), se;
    }
    function q() {
      var te = l();
      return this.squareTo(te), te;
    }
    function le(te) {
      var se = l();
      return this.divRemTo(te, se, null), se;
    }
    function Ce(te) {
      var se = l();
      return this.divRemTo(te, null, se), se;
    }
    function Se(te) {
      var se = l(), ve = l();
      return this.divRemTo(te, se, ve), new Array(se, ve);
    }
    function Ie(te) {
      this[this.t] = this.am(0, te - 1, this, 0, 0, this.t), ++this.t, this.clamp();
    }
    function Ve(te, se) {
      if (te != 0) {
        for (; this.t <= se; )
          this[this.t++] = 0;
        for (this[se] += te; this[se] >= this.DV; )
          this[se] -= this.DV, ++se >= this.t && (this[this.t++] = 0), ++this[se];
      }
    }
    function Ge() {
    }
    function qe(te) {
      return te;
    }
    function Nt(te, se, ve) {
      te.multiplyTo(se, ve);
    }
    function et(te, se) {
      te.squareTo(se);
    }
    Ge.prototype.convert = qe, Ge.prototype.revert = qe, Ge.prototype.mulTo = Nt, Ge.prototype.sqrTo = et;
    function _t(te) {
      return this.exp(te, new Ge());
    }
    function $t(te, se, ve) {
      var Ae = Math.min(this.t + te.t, se);
      for (ve.s = 0, ve.t = Ae; Ae > 0; )
        ve[--Ae] = 0;
      var Fe;
      for (Fe = ve.t - this.t; Ae < Fe; ++Ae)
        ve[Ae + this.t] = this.am(0, te[Ae], ve, Ae, 0, this.t);
      for (Fe = Math.min(te.t, se); Ae < Fe; ++Ae)
        this.am(0, te[Ae], ve, Ae, 0, se - Ae);
      ve.clamp();
    }
    function St(te, se, ve) {
      --se;
      var Ae = ve.t = this.t + te.t - se;
      for (ve.s = 0; --Ae >= 0; )
        ve[Ae] = 0;
      for (Ae = Math.max(se - this.t, 0); Ae < te.t; ++Ae)
        ve[this.t + Ae - se] = this.am(se - Ae, te[Ae], ve, 0, 0, this.t + Ae - se);
      ve.clamp(), ve.drShiftTo(1, ve);
    }
    function mt(te) {
      this.r2 = l(), this.q3 = l(), o.ONE.dlShiftTo(2 * te.t, this.r2), this.mu = this.r2.divide(te), this.m = te;
    }
    function xt(te) {
      if (te.s < 0 || te.t > 2 * this.m.t)
        return te.mod(this.m);
      if (te.compareTo(this.m) < 0)
        return te;
      var se = l();
      return te.copyTo(se), this.reduce(se), se;
    }
    function Et(te) {
      return te;
    }
    function wt(te) {
      for (te.drShiftTo(this.m.t - 1, this.r2), te.t > this.m.t + 1 && (te.t = this.m.t + 1, te.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); te.compareTo(this.r2) < 0; )
        te.dAddOffset(1, this.m.t + 1);
      for (te.subTo(this.r2, te); te.compareTo(this.m) >= 0; )
        te.subTo(this.m, te);
    }
    function tt(te, se) {
      te.squareTo(se), this.reduce(se);
    }
    function ht(te, se, ve) {
      te.multiplyTo(se, ve), this.reduce(ve);
    }
    mt.prototype.convert = xt, mt.prototype.revert = Et, mt.prototype.reduce = wt, mt.prototype.mulTo = ht, mt.prototype.sqrTo = tt;
    function Je(te, se) {
      var ve = te.bitLength(), Ae, Fe = be(1), je;
      if (ve <= 0)
        return Fe;
      ve < 18 ? Ae = 1 : ve < 48 ? Ae = 3 : ve < 144 ? Ae = 4 : ve < 768 ? Ae = 5 : Ae = 6, ve < 8 ? je = new p(se) : se.isEven() ? je = new mt(se) : je = new he(se);
      var st = new Array(), yt = 3, tr = Ae - 1, nr = (1 << Ae) - 1;
      if (st[1] = je.convert(this), Ae > 1) {
        var fr = l();
        for (je.sqrTo(st[1], fr); yt <= nr; )
          st[yt] = l(), je.mulTo(fr, st[yt - 2], st[yt]), yt += 2;
      }
      var ar = te.t - 1, lr, dr = !0, or = l(), ur;
      for (ve = pe(te[ar]) - 1; ar >= 0; ) {
        for (ve >= tr ? lr = te[ar] >> ve - tr & nr : (lr = (te[ar] & (1 << ve + 1) - 1) << tr - ve, ar > 0 && (lr |= te[ar - 1] >> this.DB + ve - tr)), yt = Ae; !(lr & 1); )
          lr >>= 1, --yt;
        if ((ve -= yt) < 0 && (ve += this.DB, --ar), dr)
          st[lr].copyTo(Fe), dr = !1;
        else {
          for (; yt > 1; )
            je.sqrTo(Fe, or), je.sqrTo(or, Fe), yt -= 2;
          yt > 0 ? je.sqrTo(Fe, or) : (ur = Fe, Fe = or, or = ur), je.mulTo(or, st[lr], Fe);
        }
        for (; ar >= 0 && !(te[ar] & 1 << ve); )
          je.sqrTo(Fe, or), ur = Fe, Fe = or, or = ur, --ve < 0 && (ve = this.DB - 1, --ar);
      }
      return je.revert(Fe);
    }
    function it(te) {
      var se = this.s < 0 ? this.negate() : this.clone(), ve = te.s < 0 ? te.negate() : te.clone();
      if (se.compareTo(ve) < 0) {
        var Ae = se;
        se = ve, ve = Ae;
      }
      var Fe = se.getLowestSetBit(), je = ve.getLowestSetBit();
      if (je < 0)
        return se;
      for (Fe < je && (je = Fe), je > 0 && (se.rShiftTo(je, se), ve.rShiftTo(je, ve)); se.signum() > 0; )
        (Fe = se.getLowestSetBit()) > 0 && se.rShiftTo(Fe, se), (Fe = ve.getLowestSetBit()) > 0 && ve.rShiftTo(Fe, ve), se.compareTo(ve) >= 0 ? (se.subTo(ve, se), se.rShiftTo(1, se)) : (ve.subTo(se, ve), ve.rShiftTo(1, ve));
      return je > 0 && ve.lShiftTo(je, ve), ve;
    }
    function nt(te) {
      if (te <= 0)
        return 0;
      var se = this.DV % te, ve = this.s < 0 ? te - 1 : 0;
      if (this.t > 0)
        if (se == 0)
          ve = this[0] % te;
        else
          for (var Ae = this.t - 1; Ae >= 0; --Ae)
            ve = (se * ve + this[Ae]) % te;
      return ve;
    }
    function Ze(te) {
      var se = te.isEven();
      if (this.isEven() && se || te.signum() == 0)
        return o.ZERO;
      for (var ve = te.clone(), Ae = this.clone(), Fe = be(1), je = be(0), st = be(0), yt = be(1); ve.signum() != 0; ) {
        for (; ve.isEven(); )
          ve.rShiftTo(1, ve), se ? ((!Fe.isEven() || !je.isEven()) && (Fe.addTo(this, Fe), je.subTo(te, je)), Fe.rShiftTo(1, Fe)) : je.isEven() || je.subTo(te, je), je.rShiftTo(1, je);
        for (; Ae.isEven(); )
          Ae.rShiftTo(1, Ae), se ? ((!st.isEven() || !yt.isEven()) && (st.addTo(this, st), yt.subTo(te, yt)), st.rShiftTo(1, st)) : yt.isEven() || yt.subTo(te, yt), yt.rShiftTo(1, yt);
        ve.compareTo(Ae) >= 0 ? (ve.subTo(Ae, ve), se && Fe.subTo(st, Fe), je.subTo(yt, je)) : (Ae.subTo(ve, Ae), se && st.subTo(Fe, st), yt.subTo(je, yt));
      }
      if (Ae.compareTo(o.ONE) != 0)
        return o.ZERO;
      if (yt.compareTo(te) >= 0)
        return yt.subtract(te);
      if (yt.signum() < 0)
        yt.addTo(te, yt);
      else
        return yt;
      return yt.signum() < 0 ? yt.add(te) : yt;
    }
    var Me = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], De = (1 << 26) / Me[Me.length - 1];
    function ze(te) {
      var se, ve = this.abs();
      if (ve.t == 1 && ve[0] <= Me[Me.length - 1]) {
        for (se = 0; se < Me.length; ++se)
          if (ve[0] == Me[se])
            return !0;
        return !1;
      }
      if (ve.isEven())
        return !1;
      for (se = 1; se < Me.length; ) {
        for (var Ae = Me[se], Fe = se + 1; Fe < Me.length && Ae < De; )
          Ae *= Me[Fe++];
        for (Ae = ve.modInt(Ae); se < Fe; )
          if (Ae % Me[se++] == 0)
            return !1;
      }
      return ve.millerRabin(te);
    }
    function Ue(te) {
      var se = this.subtract(o.ONE), ve = se.getLowestSetBit();
      if (ve <= 0)
        return !1;
      var Ae = se.shiftRight(ve);
      te = te + 1 >> 1, te > Me.length && (te = Me.length);
      for (var Fe = l(), je = 0; je < te; ++je) {
        Fe.fromInt(Me[Math.floor(Math.random() * Me.length)]);
        var st = Fe.modPow(Ae, this);
        if (st.compareTo(o.ONE) != 0 && st.compareTo(se) != 0) {
          for (var yt = 1; yt++ < ve && st.compareTo(se) != 0; )
            if (st = st.modPowInt(2, this), st.compareTo(o.ONE) == 0)
              return !1;
          if (st.compareTo(se) != 0)
            return !1;
        }
      }
      return !0;
    }
    o.prototype.chunkSize = Pe, o.prototype.toRadix = He, o.prototype.fromRadix = ot, o.prototype.fromNumber = at, o.prototype.bitwiseTo = Wt, o.prototype.changeBit = gt, o.prototype.addTo = Xt, o.prototype.dMultiply = Ie, o.prototype.dAddOffset = Ve, o.prototype.multiplyLowerTo = $t, o.prototype.multiplyUpperTo = St, o.prototype.modInt = nt, o.prototype.millerRabin = Ue, o.prototype.clone = z, o.prototype.intValue = oe, o.prototype.byteValue = Be, o.prototype.shortValue = Te, o.prototype.signum = Ye, o.prototype.toByteArray = Qe, o.prototype.equals = Pt, o.prototype.min = It, o.prototype.max = pt, o.prototype.and = vt, o.prototype.or = Ct, o.prototype.xor = zt, o.prototype.andNot = dt, o.prototype.not = Yt, o.prototype.shiftLeft = Dt, o.prototype.shiftRight = bt, o.prototype.getLowestSetBit = Bt, o.prototype.bitCount = Ht, o.prototype.testBit = Rt, o.prototype.setBit = Qt, o.prototype.clearBit = kt, o.prototype.flipBit = rt, o.prototype.add = J, o.prototype.subtract = ae, o.prototype.multiply = ue, o.prototype.divide = le, o.prototype.remainder = Ce, o.prototype.divideAndRemainder = Se, o.prototype.modPow = Je, o.prototype.modInverse = Ze, o.prototype.pow = _t, o.prototype.gcd = it, o.prototype.isProbablePrime = ze, o.prototype.square = q, o.prototype.Barrett = mt;
    var Ke, We, ct;
    function Lt(te) {
      We[ct++] ^= te & 255, We[ct++] ^= te >> 8 & 255, We[ct++] ^= te >> 16 & 255, We[ct++] ^= te >> 24 & 255, ct >= er && (ct -= er);
    }
    function Ft() {
      Lt((/* @__PURE__ */ new Date()).getTime());
    }
    if (We == null) {
      We = new Array(), ct = 0;
      var At;
      if (typeof window < "u" && window.crypto) {
        if (window.crypto.getRandomValues) {
          var $e = new Uint8Array(32);
          for (window.crypto.getRandomValues($e), At = 0; At < 32; ++At)
            We[ct++] = $e[At];
        } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
          var Ot = window.crypto.random(32);
          for (At = 0; At < Ot.length; ++At)
            We[ct++] = Ot.charCodeAt(At) & 255;
        }
      }
      for (; ct < er; )
        At = Math.floor(65536 * Math.random()), We[ct++] = At >>> 8, We[ct++] = At & 255;
      ct = 0, Ft();
    }
    function jt() {
      if (Ke == null) {
        for (Ft(), Ke = Zt(), Ke.init(We), ct = 0; ct < We.length; ++ct)
          We[ct] = 0;
        ct = 0;
      }
      return Ke.next();
    }
    function Gt(te) {
      var se;
      for (se = 0; se < te.length; ++se)
        te[se] = jt();
    }
    function Ut() {
    }
    Ut.prototype.nextBytes = Gt;
    function qt() {
      this.i = 0, this.j = 0, this.S = new Array();
    }
    function Kt(te) {
      var se, ve, Ae;
      for (se = 0; se < 256; ++se)
        this.S[se] = se;
      for (ve = 0, se = 0; se < 256; ++se)
        ve = ve + this.S[se] + te[se % te.length] & 255, Ae = this.S[se], this.S[se] = this.S[ve], this.S[ve] = Ae;
      this.i = 0, this.j = 0;
    }
    function ir() {
      var te;
      return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, te = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = te, this.S[te + this.S[this.i] & 255];
    }
    qt.prototype.init = Kt, qt.prototype.next = ir;
    function Zt() {
      return new qt();
    }
    var er = 256;
    e.exports = {
      default: o,
      BigInteger: o,
      SecureRandom: Ut
    };
  }).call(commonjsGlobal);
})(jsbn);
var jsbnExports = jsbn.exports;
let BigInteger$5 = class gr extends jsbnExports.BigInteger {
  constructor(t, a) {
    super(t.toString(), a), this.bigNum = !0;
  }
  toBuffer() {
    let t = super.toString(16);
    return t.length % 2 === 1 && (t = "0" + t), buffer$1.Buffer.from(t, "hex");
  }
  bitLength() {
    return super.bitLength();
  }
  mod(t) {
    return this.ensureBI(super.mod(this.ensureBI(t)));
  }
  add(t) {
    return this.ensureBI(super.add(this.ensureBI(t)));
  }
  mul(t) {
    return this.ensureBI(super.multiply(this.ensureBI(t)));
  }
  sub(t) {
    return this.ensureBI(super.subtract(this.ensureBI(t)));
  }
  powm(t, a) {
    return this.ensureBI(super.modPow(this.ensureBI(t), this.ensureBI(a)));
  }
  eq(t) {
    return super.equals(this.ensureBI(t));
  }
  ge(t) {
    return super.compareTo(t) >= 0;
  }
  le(t) {
    return super.compareTo(t) <= 0;
  }
  static fromBuffer(t) {
    const a = t.toString("hex");
    return new gr(a, 16);
  }
  ensureBI(t) {
    return t && typeof t == "object" && "bigNum" in t && t.bigNum ? t : new gr(t.toString());
  }
};
function hex(e) {
  return new BigInteger$5(e.split(/\s/).join(""), 16);
}
const params = {
  1024: {
    N_length_bits: 1024,
    N: hex(
      " EEAF0AB9 ADB38DD6 9C33F80A FA8FC5E8 60726187 75FF3C0B 9EA2314C9C256576 D674DF74 96EA81D3 383B4813 D692C6E0 E0D5D8E2 50B98BE48E495C1D 6089DAD1 5DC7D7B4 6154D6B6 CE8EF4AD 69B15D49 82559B297BCF1885 C529F566 660E57EC 68EDBC3C 05726CC0 2FD4CBF4 976EAA9AFD5138FE 8376435B 9FC61D2F C0EB06E3"
    ),
    g: hex("02"),
    hash: "sha1"
  },
  1536: {
    N_length_bits: 1536,
    N: hex(
      " 9DEF3CAF B939277A B1F12A86 17A47BBB DBA51DF4 99AC4C80 BEEEA9614B19CC4D 5F4F5F55 6E27CBDE 51C6A94B E4607A29 1558903B A0D0F84380B655BB 9A22E8DC DF028A7C EC67F0D0 8134B1C8 B9798914 9B609E0BE3BAB63D 47548381 DBC5B1FC 764E3F4B 53DD9DA1 158BFD3E 2B9C8CF56EDF0195 39349627 DB2FD53D 24B7C486 65772E43 7D6C7F8C E442734AF7CCB7AE 837C264A E3A9BEB8 7F8A2FE9 B8B5292E 5A021FFF 5E91479E8CE7A28C 2442C6F3 15180F93 499A234D CF76E3FE D135F9BB"
    ),
    g: hex("02"),
    hash: "sha1"
  },
  2048: {
    N_length_bits: 2048,
    N: hex(
      " AC6BDB41 324A9A9B F166DE5E 1389582F AF72B665 1987EE07 FC3192943DB56050 A37329CB B4A099ED 8193E075 7767A13D D52312AB 4B03310DCD7F48A9 DA04FD50 E8083969 EDB767B0 CF609517 9A163AB3 661A05FBD5FAAAE8 2918A996 2F0B93B8 55F97993 EC975EEA A80D740A DBF4FF747359D041 D5C33EA7 1D281E44 6B14773B CA97B43A 23FB8016 76BD207A436C6481 F1D2B907 8717461A 5B9D32E6 88F87748 544523B5 24B0D57D5EA77A27 75D2ECFA 032CFBDB F52FB378 61602790 04E57AE6 AF874E7303CE5329 9CCC041C 7BC308D8 2A5698F3 A8D0C382 71AE35F8 E9DBFBB694B5C803 D89F7AE4 35DE236D 525F5475 9B65E372 FCD68EF2 0FA7111F9E4AFF73"
    ),
    g: hex("02"),
    hash: "sha256"
  },
  3072: {
    N_length_bits: 3072,
    N: hex(
      " FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E088A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE649286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 955817183995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7DB3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D2261AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFCE0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF"
    ),
    g: hex("05"),
    hash: "sha256"
  },
  4096: {
    N_length_bits: 4096,
    N: hex(
      " FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E088A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE649286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 955817183995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7DB3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D2261AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFCE0FD108E 4B82D120 A9210801 1A723C12 A787E6D7 88719A10 BDBA5B2699C32718 6AF4E23C 1A946834 B6150BDA 2583E9CA 2AD44CE8 DBBBC2DB04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199FFFFFFFF FFFFFFFF"
    ),
    g: hex("05"),
    hash: "sha256"
  },
  6244: {
    N_length_bits: 6244,
    N: hex(
      " FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E088A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE649286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 955817183995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7DB3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D2261AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFCE0FD108E 4B82D120 A9210801 1A723C12 A787E6D7 88719A10 BDBA5B2699C32718 6AF4E23C 1A946834 B6150BDA 2583E9CA 2AD44CE8 DBBBC2DB04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 3402849236C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BD F8FF9406AD9E530E E5DB382F 413001AE B06A53ED 9027D831 179727B0 865A8918DA3EDBEB CF9B14ED 44CE6CBA CED4BB1B DB7F1447 E6CC254B 332051512BD7AF42 6FB8F401 378CD2BF 5983CA01 C64B92EC F032EA15 D1721D03F482D7CE 6E74FEF6 D55E702F 46980C82 B5A84031 900B1C9E 59E7C97FBEC7E8F3 23A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AACC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE328 06A1D58BB7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55C DA56C9EC 2EF29632387FE8D7 6E3C0468 043E8F66 3F4860EE 12BF2D5B 0B7474D6 E694F91E6DCC4024 FFFFFFFF FFFFFFFF"
    ),
    g: hex("05"),
    hash: "sha256"
  },
  8192: {
    N_length_bits: 8192,
    N: hex(
      " FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E088A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE649286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 955817183995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7DB3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D2261AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFCE0FD108E 4B82D120 A9210801 1A723C12 A787E6D7 88719A10 BDBA5B2699C32718 6AF4E23C 1A946834 B6150BDA 2583E9CA 2AD44CE8 DBBBC2DB04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 3402849236C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BD F8FF9406AD9E530E E5DB382F 413001AE B06A53ED 9027D831 179727B0 865A8918DA3EDBEB CF9B14ED 44CE6CBA CED4BB1B DB7F1447 E6CC254B 332051512BD7AF42 6FB8F401 378CD2BF 5983CA01 C64B92EC F032EA15 D1721D03F482D7CE 6E74FEF6 D55E702F 46980C82 B5A84031 900B1C9E 59E7C97FBEC7E8F3 23A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AACC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE328 06A1D58BB7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55C DA56C9EC 2EF29632387FE8D7 6E3C0468 043E8F66 3F4860EE 12BF2D5B 0B7474D6 E694F91E6DBE1159 74A3926F 12FEE5E4 38777CB6 A932DF8C D8BEC4D0 73B931BA3BC832B6 8D9DD300 741FA7BF 8AFC47ED 2576F693 6BA42466 3AAB639C5AE4F568 3423B474 2BF1C978 238F16CB E39D652D E3FDB8BE FC848AD922222E04 A4037C07 13EB57A8 1A23F0C7 3473FC64 6CEA306B 4BCBC8862F8385DD FA9D4B7F A2C087E8 79683303 ED5BDD3A 062B3CF5 B3A278A66D2A13F8 3F44F82D DF310EE0 74AB6A36 4597E899 A0255DC1 64F31CC50846851D F9AB4819 5DED7EA1 B1D510BD 7EE74D73 FAF36BC3 1ECFA268359046F4 EB879F92 4009438B 481C6CD7 889A002E D5EE382B C9190DA6FC026E47 9558E447 5677E9AA 9E3050E2 765694DF C81F56E8 80B96E7160C980DD 98EDD3DF FFFFFFFF FFFFFFFF"
    ),
    g: hex("13"),
    hash: "sha256"
  }
};
var cryptoBrowserify = {}, browser$1$1 = { exports: {} }, process = browser$1$1.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(e) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(e, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(e, 0);
  try {
    return cachedSetTimeout(e, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, e, 0);
    } catch {
      return cachedSetTimeout.call(this, e, 0);
    }
  }
}
function runClearTimeout(e) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(e);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(e);
  try {
    return cachedClearTimeout(e);
  } catch {
    try {
      return cachedClearTimeout.call(null, e);
    } catch {
      return cachedClearTimeout.call(this, e);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var e = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var t = queue.length; t; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < t; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, t = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(e);
  }
}
process.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var a = 1; a < arguments.length; a++)
      t[a - 1] = arguments[a];
  queue.push(new Item(e, t)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(e, t) {
  this.fun = e, this.array = t;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$1() {
}
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(e) {
  return [];
};
process.binding = function(e) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
function noop() {
}
var browser$c = (
  /** @type {boolean} */
  browser$1$1.exports.browser
), emitWarning = noop, binding = (
  /** @type {Function} */
  browser$1$1.exports.binding
), exit = noop, pid = 1, features = {}, kill = noop, dlopen = noop, uptime = noop, memoryUsage = noop, uvCounters = noop, platform = "browser", arch = "browser", execPath = "browser", execArgv = (
  /** @type {string[]} */
  []
), api$2 = {
  nextTick: browser$1$1.exports.nextTick,
  title: browser$1$1.exports.title,
  browser: browser$c,
  env: browser$1$1.exports.env,
  argv: browser$1$1.exports.argv,
  version: browser$1$1.exports.version,
  versions: browser$1$1.exports.versions,
  on: browser$1$1.exports.on,
  addListener: browser$1$1.exports.addListener,
  once: browser$1$1.exports.once,
  off: browser$1$1.exports.off,
  removeListener: browser$1$1.exports.removeListener,
  removeAllListeners: browser$1$1.exports.removeAllListeners,
  emit: browser$1$1.exports.emit,
  emitWarning,
  prependListener: browser$1$1.exports.prependListener,
  prependOnceListener: browser$1$1.exports.prependOnceListener,
  listeners: browser$1$1.exports.listeners,
  binding,
  cwd: browser$1$1.exports.cwd,
  chdir: browser$1$1.exports.chdir,
  umask: browser$1$1.exports.umask,
  exit,
  pid,
  features,
  kill,
  dlopen,
  uptime,
  memoryUsage,
  uvCounters,
  platform,
  arch,
  execPath,
  execArgv
};
browser$1$1.exports.addListener;
browser$1$1.exports.argv;
browser$1$1.exports.chdir;
browser$1$1.exports.cwd;
browser$1$1.exports.emit;
browser$1$1.exports.env;
browser$1$1.exports.listeners;
browser$1$1.exports.nextTick;
browser$1$1.exports.off;
browser$1$1.exports.on;
browser$1$1.exports.once;
browser$1$1.exports.prependListener;
browser$1$1.exports.prependOnceListener;
browser$1$1.exports.removeAllListeners;
browser$1$1.exports.removeListener;
browser$1$1.exports.title;
browser$1$1.exports.umask;
browser$1$1.exports.version;
browser$1$1.exports.versions;
(function(e) {
  function t() {
    var n = this || self;
    return delete e.prototype.__magic__, n;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var a = __magic__;
  return a;
})(Object);
var browser$b = { exports: {} }, safeBuffer$3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var a = buffer$1, n = a.Buffer;
  function u(l, h) {
    for (var y in l)
      h[y] = l[y];
  }
  n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = a : (u(a, t), t.Buffer = o);
  function o(l, h, y) {
    return n(l, h, y);
  }
  o.prototype = Object.create(n.prototype), u(n, o), o.from = function(l, h, y) {
    if (typeof l == "number")
      throw new TypeError("Argument must not be a number");
    return n(l, h, y);
  }, o.alloc = function(l, h, y) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    var _ = n(l);
    return h !== void 0 ? typeof y == "string" ? _.fill(h, y) : _.fill(h) : _.fill(0), _;
  }, o.allocUnsafe = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return n(l);
  }, o.allocUnsafeSlow = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return a.SlowBuffer(l);
  };
})(safeBuffer$3, safeBuffer$3.exports);
var safeBufferExports$2 = safeBuffer$3.exports, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$D = safeBufferExports$2.Buffer, crypto$3 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
crypto$3 && crypto$3.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(e, t) {
  if (e > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var a = Buffer$D.allocUnsafe(e);
  if (e > 0)
    if (e > MAX_BYTES)
      for (var n = 0; n < e; n += MAX_BYTES)
        crypto$3.getRandomValues(a.slice(n, n + MAX_BYTES));
    else
      crypto$3.getRandomValues(a);
  return typeof t == "function" ? api$2.nextTick(function() {
    t(null, a);
  }) : a;
}
var browserExports = browser$b.exports, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(t, a) {
  a && (t.super_ = a, t.prototype = Object.create(a.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(t, a) {
  if (a) {
    t.super_ = a;
    var n = function() {
    };
    n.prototype = a.prototype, t.prototype = new n(), t.prototype.constructor = t;
  }
};
var inherits_browserExports = inherits_browser.exports, toString$2 = {}.toString, isarray$2 = Array.isArray || function(e) {
  return toString$2.call(e) == "[object Array]";
}, type = TypeError, esObjectAtoms = Object, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, uri = URIError, abs$1 = Math.abs, floor$1 = Math.floor, max$2 = Math.max, min$1 = Math.min, pow$1 = Math.pow, round$1 = Math.round, _isNaN = Number.isNaN || function(t) {
  return t !== t;
}, $isNaN = _isNaN, sign$2 = function(t) {
  return $isNaN(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, gOPD$4 = Object.getOwnPropertyDescriptor, $gOPD$1 = gOPD$4;
if ($gOPD$1)
  try {
    $gOPD$1([], "length");
  } catch {
    $gOPD$1 = null;
  }
var gopd$1 = $gOPD$1, $defineProperty$3 = Object.defineProperty || !1;
if ($defineProperty$3)
  try {
    $defineProperty$3({}, "a", { value: 1 });
  } catch {
    $defineProperty$3 = !1;
  }
var esDefineProperty = $defineProperty$3, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, a = Symbol("test"), n = Object(a);
  if (typeof a == "string" || Object.prototype.toString.call(a) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
    return !1;
  var u = 42;
  t[a] = u;
  for (var o in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var l = Object.getOwnPropertySymbols(t);
  if (l.length !== 1 || l[0] !== a || !Object.prototype.propertyIsEnumerable.call(t, a))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var h = (
      /** @type {PropertyDescriptor} */
      Object.getOwnPropertyDescriptor(t, a)
    );
    if (h.value !== u || h.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols$2;
  hasRequiredHasSymbols = 1;
  var e = typeof Symbol < "u" && Symbol, t = shams$1;
  return hasSymbols$2 = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, hasSymbols$2;
}
var Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null, Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf)
    return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var e = esObjectAtoms;
  return Object_getPrototypeOf = e.getPrototypeOf || null, Object_getPrototypeOf;
}
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max$1 = Math.max, funcType = "[object Function]", concatty = function(t, a) {
  for (var n = [], u = 0; u < t.length; u += 1)
    n[u] = t[u];
  for (var o = 0; o < a.length; o += 1)
    n[o + t.length] = a[o];
  return n;
}, slicy = function(t, a) {
  for (var n = [], u = a || 0, o = 0; u < t.length; u += 1, o += 1)
    n[o] = t[u];
  return n;
}, joiny = function(e, t) {
  for (var a = "", n = 0; n < e.length; n += 1)
    a += e[n], n + 1 < e.length && (a += t);
  return a;
}, implementation$1 = function(t) {
  var a = this;
  if (typeof a != "function" || toStr$3.apply(a) !== funcType)
    throw new TypeError(ERROR_MESSAGE + a);
  for (var n = slicy(arguments, 1), u, o = function() {
    if (this instanceof u) {
      var d = a.apply(
        this,
        concatty(n, arguments)
      );
      return Object(d) === d ? d : this;
    }
    return a.apply(
      t,
      concatty(n, arguments)
    );
  }, l = max$1(0, a.length - n.length), h = [], y = 0; y < l; y++)
    h[y] = "$" + y;
  if (u = Function("binder", "return function (" + joiny(h, ",") + "){ return binder.apply(this,arguments); }")(o), a.prototype) {
    var _ = function() {
    };
    _.prototype = a.prototype, u.prototype = new _(), _.prototype = null;
  }
  return u;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, functionCall = Function.prototype.call, functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply$1 = typeof Reflect < "u" && Reflect && Reflect.apply, bind$3 = functionBind, $apply$2 = requireFunctionApply(), $call$2 = functionCall, $reflectApply = reflectApply$1, actualApply$1 = $reflectApply || bind$3.call($call$2, $apply$2), bind$2 = functionBind, $TypeError$5 = type, $call$1 = functionCall, $actualApply = actualApply$1, callBindApplyHelpers = function(t) {
  if (t.length < 1 || typeof t[0] != "function")
    throw new $TypeError$5("a function is required");
  return $actualApply(bind$2, $call$1, t);
}, callBind$2 = callBindApplyHelpers, gOPD$3 = gopd$1, hasProtoAccessor;
try {
  hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
  [].__proto__ === Array.prototype;
} catch (e) {
  if (!e || typeof e != "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS")
    throw e;
}
var desc = !!hasProtoAccessor && gOPD$3 && gOPD$3(
  Object.prototype,
  /** @type {keyof typeof Object.prototype} */
  "__proto__"
), $Object$1 = Object, $getPrototypeOf = $Object$1.getPrototypeOf, get = desc && typeof desc.get == "function" ? callBind$2([desc.get]) : typeof $getPrototypeOf == "function" ? (
  /** @type {import('./get')} */
  function(t) {
    return $getPrototypeOf(t == null ? t : $Object$1(t));
  }
) : !1, reflectGetProto = Reflect_getPrototypeOf, originalGetProto = requireObject_getPrototypeOf(), getDunderProto = get, getProto$3 = reflectGetProto ? function(t) {
  return reflectGetProto(t);
} : originalGetProto ? function(t) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new TypeError("getProto: not an object");
  return originalGetProto(t);
} : getDunderProto ? function(t) {
  return getDunderProto(t);
} : null, hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown)
    return hasown;
  hasRequiredHasown = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, a = functionBind;
  return hasown = a.call(e, t), hasown;
}
var undefined$1, $Object = esObjectAtoms, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$4 = type, $URIError = uri, abs = abs$1, floor = floor$1, max = max$2, min = min$1, pow = pow$1, round = round$1, sign$1 = sign$2, $Function = Function, getEvalledConstructor = function(e) {
  try {
    return $Function('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, $gOPD = gopd$1, $defineProperty$2 = esDefineProperty, throwTypeError = function() {
  throw new $TypeError$4();
}, ThrowTypeError = $gOPD ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols$1 = requireHasSymbols()(), getProto$2 = getProto$3, $ObjectGPO = requireObject_getPrototypeOf(), $ReflectGPO = Reflect_getPrototypeOf, $apply$1 = requireFunctionApply(), $call = functionCall, needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$2 ? undefined$1 : getProto$2(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 && getProto$2 ? getProto$2([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array > "u" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 && getProto$2 ? getProto$2(getProto$2([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols$1 || !getProto$2 ? undefined$1 : getProto$2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols$1 || !getProto$2 ? undefined$1 : getProto$2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 && getProto$2 ? getProto$2(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$4,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply$1,
  "%Object.defineProperty%": $defineProperty$2,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign$1,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto$2)
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto$2(getProto$2(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function e(t) {
  var a;
  if (t === "%AsyncFunction%")
    a = getEvalledConstructor("async function () {}");
  else if (t === "%GeneratorFunction%")
    a = getEvalledConstructor("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    a = getEvalledConstructor("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var n = e("%AsyncGeneratorFunction%");
    n && (a = n.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var u = e("%AsyncGenerator%");
    u && getProto$2 && (a = getProto$2(u.prototype));
  }
  return INTRINSICS[t] = a, a;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn$1 = requireHasown(), $concat = bind$1.call($call, Array.prototype.concat), $spliceApply = bind$1.call($apply$1, Array.prototype.splice), $replace = bind$1.call($call, String.prototype.replace), $strSlice = bind$1.call($call, String.prototype.slice), $exec$2 = bind$1.call($call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(t) {
  var a = $strSlice(t, 0, 1), n = $strSlice(t, -1);
  if (a === "%" && n !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (n === "%" && a !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var u = [];
  return $replace(t, rePropName, function(o, l, h, y) {
    u[u.length] = h ? $replace(y, reEscapeChar, "$1") : l || o;
  }), u;
}, getBaseIntrinsic = function(t, a) {
  var n = t, u;
  if (hasOwn$1(LEGACY_ALIASES, n) && (u = LEGACY_ALIASES[n], n = "%" + u[0] + "%"), hasOwn$1(INTRINSICS, n)) {
    var o = INTRINSICS[n];
    if (o === needsEval && (o = doEval(n)), typeof o > "u" && !a)
      throw new $TypeError$4("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: u,
      name: n,
      value: o
    };
  }
  throw new $SyntaxError$1("intrinsic " + t + " does not exist!");
}, getIntrinsic = function(t, a) {
  if (typeof t != "string" || t.length === 0)
    throw new $TypeError$4("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof a != "boolean")
    throw new $TypeError$4('"allowMissing" argument must be a boolean');
  if ($exec$2(/^%?[^%]*%?$/, t) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n = stringToPath(t), u = n.length > 0 ? n[0] : "", o = getBaseIntrinsic("%" + u + "%", a), l = o.name, h = o.value, y = !1, _ = o.alias;
  _ && (u = _[0], $spliceApply(n, $concat([0, 1], _)));
  for (var d = 1, $ = !0; d < n.length; d += 1) {
    var N = n[d], U = $strSlice(N, 0, 1), V = $strSlice(N, -1);
    if ((U === '"' || U === "'" || U === "`" || V === '"' || V === "'" || V === "`") && U !== V)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((N === "constructor" || !$) && (y = !0), u += "." + N, l = "%" + u + "%", hasOwn$1(INTRINSICS, l))
      h = INTRINSICS[l];
    else if (h != null) {
      if (!(N in h)) {
        if (!a)
          throw new $TypeError$4("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if ($gOPD && d + 1 >= n.length) {
        var Q = $gOPD(h, N);
        $ = !!Q, $ && "get" in Q && !("originalValue" in Q.get) ? h = Q.get : h = h[N];
      } else
        $ = hasOwn$1(h, N), h = h[N];
      $ && !y && (INTRINSICS[l] = h);
    }
  }
  return h;
}, GetIntrinsic$1 = getIntrinsic, callBindBasic = callBindApplyHelpers, $indexOf$1 = callBindBasic([GetIntrinsic$1("%String.prototype.indexOf%")]), callBound$6 = function(t, a) {
  var n = (
    /** @type {(this: unknown, ...args: unknown[]) => unknown} */
    GetIntrinsic$1(t, !!a)
  );
  return typeof n == "function" && $indexOf$1(t, ".prototype.") > -1 ? callBindBasic(
    /** @type {const} */
    [n]
  ) : n;
}, fnToStr$1 = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (e) {
    e !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(t) {
  try {
    var a = fnToStr$1.call(t);
    return constructorRegex.test(a);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(t) {
  try {
    return isES6ClassFn(t) ? !1 : (fnToStr$1.call(t), !0);
  } catch {
    return !1;
  }
}, toStr$2 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$4 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$2.call(all) === toStr$2.call(document.all) && (isDDA = function(t) {
    if ((isIE68 || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var a = toStr$2.call(t);
        return (a === ddaClass || a === ddaClass2 || a === ddaClass3 || a === objectClass) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(t) {
  if (isDDA(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    reflectApply(t, null, badArrayLike);
  } catch (a) {
    if (a !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(t) && tryFunctionObject(t);
} : function(t) {
  if (isDDA(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (hasToStringTag$4)
    return tryFunctionObject(t);
  if (isES6ClassFn(t))
    return !1;
  var a = toStr$2.call(t);
  return a !== fnClass && a !== genClass && !/^\[object HTML/.test(a) ? !1 : tryFunctionObject(t);
}, isCallable = isCallable$1, toStr$1 = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(t, a, n) {
  for (var u = 0, o = t.length; u < o; u++)
    hasOwnProperty.call(t, u) && (n == null ? a(t[u], u, t) : a.call(n, t[u], u, t));
}, forEachString = function(t, a, n) {
  for (var u = 0, o = t.length; u < o; u++)
    n == null ? a(t.charAt(u), u, t) : a.call(n, t.charAt(u), u, t);
}, forEachObject = function(t, a, n) {
  for (var u in t)
    hasOwnProperty.call(t, u) && (n == null ? a(t[u], u, t) : a.call(n, t[u], u, t));
};
function isArray$2(e) {
  return toStr$1.call(e) === "[object Array]";
}
var forEach$1 = function(t, a, n) {
  if (!isCallable(a))
    throw new TypeError("iterator must be a function");
  var u;
  arguments.length >= 3 && (u = n), isArray$2(t) ? forEachArray(t, a, u) : typeof t == "string" ? forEachString(t, a, u) : forEachObject(t, a, u);
}, possibleTypedArrayNames = [
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var t = [], a = 0; a < possibleNames.length; a++)
    typeof g$1[possibleNames[a]] == "function" && (t[t.length] = possibleNames[a]);
  return t;
}, callBind$1 = { exports: {} }, $defineProperty$1 = esDefineProperty, $SyntaxError = syntax, $TypeError$3 = type, gopd = gopd$1, defineDataProperty = function(t, a, n) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new $TypeError$3("`obj` must be an object or a function`");
  if (typeof a != "string" && typeof a != "symbol")
    throw new $TypeError$3("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$3("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$3("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$3("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$3("`loose`, if provided, must be a boolean");
  var u = arguments.length > 3 ? arguments[3] : null, o = arguments.length > 4 ? arguments[4] : null, l = arguments.length > 5 ? arguments[5] : null, h = arguments.length > 6 ? arguments[6] : !1, y = !!gopd && gopd(t, a);
  if ($defineProperty$1)
    $defineProperty$1(t, a, {
      configurable: l === null && y ? y.configurable : !l,
      enumerable: u === null && y ? y.enumerable : !u,
      value: n,
      writable: o === null && y ? y.writable : !o
    });
  else if (h || !u && !o && !l)
    t[a] = n;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = esDefineProperty, hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$2 = gopd$1, $TypeError$2 = type, $floor = GetIntrinsic("%Math.floor%"), setFunctionLength = function(t, a) {
  if (typeof t != "function")
    throw new $TypeError$2("`fn` is not a function");
  if (typeof a != "number" || a < 0 || a > 4294967295 || $floor(a) !== a)
    throw new $TypeError$2("`length` must be a positive 32-bit integer");
  var n = arguments.length > 2 && !!arguments[2], u = !0, o = !0;
  if ("length" in t && gOPD$2) {
    var l = gOPD$2(t, "length");
    l && !l.configurable && (u = !1), l && !l.writable && (o = !1);
  }
  return (u || o || !n) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    a,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    a
  )), t;
}, bind = functionBind, $apply = requireFunctionApply(), actualApply = actualApply$1, applyBind = function() {
  return actualApply(bind, $apply, arguments);
};
(function(e) {
  var t = setFunctionLength, a = esDefineProperty, n = callBindApplyHelpers, u = applyBind;
  e.exports = function(l) {
    var h = n(arguments), y = l.length - (arguments.length - 1);
    return t(
      h,
      1 + (y > 0 ? y : 0),
      !0
    );
  }, a ? a(e.exports, "apply", { value: u }) : e.exports.apply = u;
})(callBind$1);
var callBindExports = callBind$1.exports, hasSymbols = shams$1, shams = function() {
  return hasSymbols() && !!Symbol.toStringTag;
}, forEach = forEach$1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound$5 = callBound$6, gOPD$1 = gopd$1, getProto$1 = getProto$3, $toString$2 = callBound$5("Object.prototype.toString"), hasToStringTag$3 = shams(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound$5("String.prototype.slice"), $indexOf = callBound$5("Array.prototype.indexOf", !0) || function(t, a) {
  for (var n = 0; n < t.length; n += 1)
    if (t[n] === a)
      return n;
  return -1;
}, cache = { __proto__: null };
hasToStringTag$3 && gOPD$1 && getProto$1 ? forEach(typedArrays, function(e) {
  var t = new g[e]();
  if (Symbol.toStringTag in t && getProto$1) {
    var a = getProto$1(t), n = gOPD$1(a, Symbol.toStringTag);
    if (!n && a) {
      var u = getProto$1(a);
      n = gOPD$1(u, Symbol.toStringTag);
    }
    cache["$" + e] = callBind(n.get);
  }
}) : forEach(typedArrays, function(e) {
  var t = new g[e](), a = t.slice || t.set;
  a && (cache[
    /** @type {`$${import('.').TypedArrayName}`} */
    "$" + e
  ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
  // @ts-expect-error TODO FIXME
  callBind(a));
});
var tryTypedArrays = function(t) {
  var a = !1;
  return forEach(
    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(n, u) {
      if (!a)
        try {
          "$" + n(t) === u && (a = /** @type {import('.').TypedArrayName} */
          $slice(u, 1));
        } catch {
        }
    }
  ), a;
}, trySlices = function(t) {
  var a = !1;
  return forEach(
    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(n, u) {
      if (!a)
        try {
          n(t), a = /** @type {import('.').TypedArrayName} */
          $slice(u, 1);
        } catch {
        }
    }
  ), a;
}, whichTypedArray = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!hasToStringTag$3) {
    var a = $slice($toString$2(t), 8, -1);
    return $indexOf(typedArrays, a) > -1 ? a : a !== "Object" ? !1 : trySlices(t);
  }
  return gOPD$1 ? tryTypedArrays(t) : null;
}, isTypedArray$1, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray$1;
  hasRequiredIsTypedArray = 1;
  var e = whichTypedArray;
  return isTypedArray$1 = function(a) {
    return !!e(a);
  }, isTypedArray$1;
}
var $TypeError$1 = type, callBound$4 = callBound$6, $typedArrayBuffer = callBound$4("TypedArray.prototype.buffer", !0), isTypedArray = requireIsTypedArray(), typedArrayBuffer$1 = $typedArrayBuffer || function(t) {
  if (!isTypedArray(t))
    throw new $TypeError$1("Not a Typed Array");
  return t.buffer;
}, Buffer$C = safeBufferExports$2.Buffer, isArray$1 = isarray$2, typedArrayBuffer = typedArrayBuffer$1, isView$2 = ArrayBuffer.isView || function(t) {
  try {
    return typedArrayBuffer(t), !0;
  } catch {
    return !1;
  }
}, useUint8Array$2 = typeof Uint8Array < "u", useArrayBuffer$2 = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", useFromArrayBuffer = useArrayBuffer$2 && (Buffer$C.prototype instanceof Uint8Array || Buffer$C.TYPED_ARRAY_SUPPORT), toBuffer$7 = function(t, a) {
  if (Buffer$C.isBuffer(t))
    return t.constructor && !("isBuffer" in t) ? Buffer$C.from(t) : t;
  if (typeof t == "string")
    return Buffer$C.from(t, a);
  if (useArrayBuffer$2 && isView$2(t)) {
    if (t.byteLength === 0)
      return Buffer$C.alloc(0);
    if (useFromArrayBuffer) {
      var n = Buffer$C.from(t.buffer, t.byteOffset, t.byteLength);
      if (n.byteLength === t.byteLength)
        return n;
    }
    var u = t instanceof Uint8Array ? t : new Uint8Array(t.buffer, t.byteOffset, t.byteLength), o = Buffer$C.from(u);
    if (o.length === t.byteLength)
      return o;
  }
  if (useUint8Array$2 && t instanceof Uint8Array)
    return Buffer$C.from(t);
  var l = isArray$1(t);
  if (l)
    for (var h = 0; h < t.length; h += 1) {
      var y = t[h];
      if (typeof y != "number" || y < 0 || y > 255 || ~~y !== y)
        throw new RangeError("Array items must be numbers in the range 0-255.");
    }
  if (l || Buffer$C.isBuffer(t) && t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t))
    return Buffer$C.from(t);
  throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
}, Buffer$B = safeBufferExports$2.Buffer, toBuffer$6 = toBuffer$7, useUint8Array$1 = typeof Uint8Array < "u", useArrayBuffer$1 = useUint8Array$1 && typeof ArrayBuffer < "u", isView$1 = useArrayBuffer$1 && ArrayBuffer.isView, toBuffer_1$1 = function(e, t) {
  if (typeof e == "string" || Buffer$B.isBuffer(e) || useUint8Array$1 && e instanceof Uint8Array || isView$1 && isView$1(e))
    return toBuffer$6(e, t);
  throw new TypeError('The "data" argument must be a string, a Buffer, a Uint8Array, or a DataView');
}, readableBrowser$1 = { exports: {} }, processNextickArgs = { exports: {} };
typeof api$2 > "u" || !api$2.version || api$2.version.indexOf("v0.") === 0 || api$2.version.indexOf("v1.") === 0 && api$2.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: nextTick$1 } : processNextickArgs.exports = api$2;
function nextTick$1(e, t, a, n) {
  if (typeof e != "function")
    throw new TypeError('"callback" argument must be a function');
  var u = arguments.length, o, l;
  switch (u) {
    case 0:
    case 1:
      return api$2.nextTick(e);
    case 2:
      return api$2.nextTick(function() {
        e.call(null, t);
      });
    case 3:
      return api$2.nextTick(function() {
        e.call(null, t, a);
      });
    case 4:
      return api$2.nextTick(function() {
        e.call(null, t, a, n);
      });
    default:
      for (o = new Array(u - 1), l = 0; l < o.length; )
        o[l++] = arguments[l];
      return api$2.nextTick(function() {
        e.apply(null, o);
      });
  }
}
var processNextickArgsExports = processNextickArgs.exports, toString$1 = {}.toString, isarray$1 = Array.isArray || function(e) {
  return toString$1.call(e) == "[object Array]";
}, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(t, a, n) {
  return Function.prototype.apply.call(t, a, n);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t);
};
function ProcessEmitWarning(e) {
  console && console.warn && console.warn(e);
}
var NumberIsNaN = Number.isNaN || function(t) {
  return t !== t;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || NumberIsNaN(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    defaultMaxListeners = e;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || NumberIsNaN(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _getMaxListeners(e) {
  return e._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : e._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(t) {
  for (var a = [], n = 1; n < arguments.length; n++)
    a.push(arguments[n]);
  var u = t === "error", o = this._events;
  if (o !== void 0)
    u = u && o.error === void 0;
  else if (!u)
    return !1;
  if (u) {
    var l;
    if (a.length > 0 && (l = a[0]), l instanceof Error)
      throw l;
    var h = new Error("Unhandled error." + (l ? " (" + l.message + ")" : ""));
    throw h.context = l, h;
  }
  var y = o[t];
  if (y === void 0)
    return !1;
  if (typeof y == "function")
    ReflectApply(y, this, a);
  else
    for (var _ = y.length, d = arrayClone(y, _), n = 0; n < _; ++n)
      ReflectApply(d[n], this, a);
  return !0;
};
function _addListener(e, t, a, n) {
  var u, o, l;
  if (checkListener(a), o = e._events, o === void 0 ? (o = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (o.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    a.listener ? a.listener : a
  ), o = e._events), l = o[t]), l === void 0)
    l = o[t] = a, ++e._eventsCount;
  else if (typeof l == "function" ? l = o[t] = n ? [a, l] : [l, a] : n ? l.unshift(a) : l.push(a), u = _getMaxListeners(e), u > 0 && l.length > u && !l.warned) {
    l.warned = !0;
    var h = new Error("Possible EventEmitter memory leak detected. " + l.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h.name = "MaxListenersExceededWarning", h.emitter = e, h.type = t, h.count = l.length, ProcessEmitWarning(h);
  }
  return e;
}
EventEmitter.prototype.addListener = function(t, a) {
  return _addListener(this, t, a, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(t, a) {
  return _addListener(this, t, a, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(e, t, a) {
  var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: a }, u = onceWrapper.bind(n);
  return u.listener = a, n.wrapFn = u, u;
}
EventEmitter.prototype.once = function(t, a) {
  return checkListener(a), this.on(t, _onceWrap(this, t, a)), this;
};
EventEmitter.prototype.prependOnceListener = function(t, a) {
  return checkListener(a), this.prependListener(t, _onceWrap(this, t, a)), this;
};
EventEmitter.prototype.removeListener = function(t, a) {
  var n, u, o, l, h;
  if (checkListener(a), u = this._events, u === void 0)
    return this;
  if (n = u[t], n === void 0)
    return this;
  if (n === a || n.listener === a)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete u[t], u.removeListener && this.emit("removeListener", t, n.listener || a));
  else if (typeof n != "function") {
    for (o = -1, l = n.length - 1; l >= 0; l--)
      if (n[l] === a || n[l].listener === a) {
        h = n[l].listener, o = l;
        break;
      }
    if (o < 0)
      return this;
    o === 0 ? n.shift() : spliceOne(n, o), n.length === 1 && (u[t] = n[0]), u.removeListener !== void 0 && this.emit("removeListener", t, h || a);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(t) {
  var a, n, u;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var o = Object.keys(n), l;
    for (u = 0; u < o.length; ++u)
      l = o[u], l !== "removeListener" && this.removeAllListeners(l);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (a = n[t], typeof a == "function")
    this.removeListener(t, a);
  else if (a !== void 0)
    for (u = a.length - 1; u >= 0; u--)
      this.removeListener(t, a[u]);
  return this;
};
function _listeners(e, t, a) {
  var n = e._events;
  if (n === void 0)
    return [];
  var u = n[t];
  return u === void 0 ? [] : typeof u == "function" ? a ? [u.listener || u] : [u] : a ? unwrapListeners(u) : arrayClone(u, u.length);
}
EventEmitter.prototype.listeners = function(t) {
  return _listeners(this, t, !0);
};
EventEmitter.prototype.rawListeners = function(t) {
  return _listeners(this, t, !1);
};
EventEmitter.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : listenerCount.call(e, t);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(e) {
  var t = this._events;
  if (t !== void 0) {
    var a = t[e];
    if (typeof a == "function")
      return 1;
    if (a !== void 0)
      return a.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(e, t) {
  for (var a = new Array(t), n = 0; n < t; ++n)
    a[n] = e[n];
  return a;
}
function spliceOne(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function unwrapListeners(e) {
  for (var t = new Array(e.length), a = 0; a < t.length; ++a)
    t[a] = e[a].listener || e[a];
  return t;
}
function once(e, t) {
  return new Promise(function(a, n) {
    function u(l) {
      e.removeListener(t, o), n(l);
    }
    function o() {
      typeof e.removeListener == "function" && e.removeListener("error", u), a([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(e, t, o, { once: !0 }), t !== "error" && addErrorHandlerIfEventEmitter(e, u, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(e, t, a) {
  typeof e.on == "function" && eventTargetAgnosticAddListener(e, "error", t, a);
}
function eventTargetAgnosticAddListener(e, t, a, n) {
  if (typeof e.on == "function")
    n.once ? e.once(t, a) : e.on(t, a);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function u(o) {
      n.once && e.removeEventListener(t, u), a(o);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var eventsExports = events.exports, streamBrowser$2 = eventsExports.EventEmitter, safeBuffer$2 = { exports: {} };
(function(e, t) {
  var a = buffer$1, n = a.Buffer;
  function u(l, h) {
    for (var y in l)
      h[y] = l[y];
  }
  n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = a : (u(a, t), t.Buffer = o);
  function o(l, h, y) {
    return n(l, h, y);
  }
  u(n, o), o.from = function(l, h, y) {
    if (typeof l == "number")
      throw new TypeError("Argument must not be a number");
    return n(l, h, y);
  }, o.alloc = function(l, h, y) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    var _ = n(l);
    return h !== void 0 ? typeof y == "string" ? _.fill(h, y) : _.fill(h) : _.fill(0), _;
  }, o.allocUnsafe = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return n(l);
  }, o.allocUnsafeSlow = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return a.SlowBuffer(l);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, util$a = {};
function isArray(e) {
  return Array.isArray ? Array.isArray(e) : objectToString(e) === "[object Array]";
}
util$a.isArray = isArray;
function isBoolean(e) {
  return typeof e == "boolean";
}
util$a.isBoolean = isBoolean;
function isNull(e) {
  return e === null;
}
util$a.isNull = isNull;
function isNullOrUndefined(e) {
  return e == null;
}
util$a.isNullOrUndefined = isNullOrUndefined;
function isNumber(e) {
  return typeof e == "number";
}
util$a.isNumber = isNumber;
function isString(e) {
  return typeof e == "string";
}
util$a.isString = isString;
function isSymbol(e) {
  return typeof e == "symbol";
}
util$a.isSymbol = isSymbol;
function isUndefined(e) {
  return e === void 0;
}
util$a.isUndefined = isUndefined;
function isRegExp(e) {
  return objectToString(e) === "[object RegExp]";
}
util$a.isRegExp = isRegExp;
function isObject(e) {
  return typeof e == "object" && e !== null;
}
util$a.isObject = isObject;
function isDate(e) {
  return objectToString(e) === "[object Date]";
}
util$a.isDate = isDate;
function isError(e) {
  return objectToString(e) === "[object Error]" || e instanceof Error;
}
util$a.isError = isError;
function isFunction(e) {
  return typeof e == "function";
}
util$a.isFunction = isFunction;
function isPrimitive(e) {
  return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || // ES6 symbol
  typeof e > "u";
}
util$a.isPrimitive = isPrimitive;
util$a.isBuffer = buffer$1.Buffer.isBuffer;
function objectToString(e) {
  return Object.prototype.toString.call(e);
}
var util$9 = {}, types = {}, hasToStringTag$2 = shams(), callBound$3 = callBound$6, $toString$1 = callBound$3("Object.prototype.toString"), isStandardArguments = function(t) {
  return hasToStringTag$2 && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : $toString$1(t) === "[object Arguments]";
}, isLegacyArguments = function(t) {
  return isStandardArguments(t) ? !0 : t !== null && typeof t == "object" && "length" in t && typeof t.length == "number" && t.length >= 0 && $toString$1(t) !== "[object Array]" && "callee" in t && $toString$1(t.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, callBound$2 = callBound$6, hasToStringTag$1 = shams(), hasOwn = requireHasown(), gOPD = gopd$1, fn;
if (hasToStringTag$1) {
  var $exec$1 = callBound$2("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
    throw isRegexMarker;
  }, badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  typeof Symbol.toPrimitive == "symbol" && (badStringifier[Symbol.toPrimitive] = throwRegexMarker), fn = function(t) {
    if (!t || typeof t != "object")
      return !1;
    var a = (
      /** @type {NonNullable<typeof gOPD>} */
      gOPD(
        /** @type {{ lastIndex?: unknown }} */
        t,
        "lastIndex"
      )
    ), n = a && hasOwn(a, "value");
    if (!n)
      return !1;
    try {
      $exec$1(
        t,
        /** @type {string} */
        /** @type {unknown} */
        badStringifier
      );
    } catch (u) {
      return u === isRegexMarker;
    }
  };
} else {
  var $toString = callBound$2("Object.prototype.toString"), regexClass = "[object RegExp]";
  fn = function(t) {
    return !t || typeof t != "object" && typeof t != "function" ? !1 : $toString(t) === regexClass;
  };
}
var isRegex$1 = fn, callBound$1 = callBound$6, isRegex = isRegex$1, $exec = callBound$1("RegExp.prototype.exec"), $TypeError = type, safeRegexTest$1 = function(t) {
  if (!isRegex(t))
    throw new $TypeError("`regex` must be a RegExp");
  return function(n) {
    return $exec(t, n) !== null;
  };
}, generatorFunction, hasRequiredGeneratorFunction;
function requireGeneratorFunction() {
  if (hasRequiredGeneratorFunction)
    return generatorFunction;
  hasRequiredGeneratorFunction = 1;
  const e = (
    /** @type {GeneratorFunctionConstructor} */
    (function* () {
    }).constructor
  );
  return generatorFunction = () => e, generatorFunction;
}
var callBound = callBound$6, safeRegexTest = safeRegexTest$1, isFnRegex = safeRegexTest(/^\s*(?:function)?\*/), hasToStringTag = shams(), getProto = getProto$3, toStr = callBound("Object.prototype.toString"), fnToStr = callBound("Function.prototype.toString"), getGeneratorFunction = requireGeneratorFunction(), isGeneratorFunction = function(t) {
  if (typeof t != "function")
    return !1;
  if (isFnRegex(fnToStr(t)))
    return !0;
  if (!hasToStringTag) {
    var a = toStr(t);
    return a === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  var n = getGeneratorFunction();
  return n && getProto(t) === n.prototype;
};
(function(e) {
  var t = isArguments, a = isGeneratorFunction, n = whichTypedArray, u = requireIsTypedArray();
  function o(oe) {
    return oe.call.bind(oe);
  }
  var l = typeof BigInt < "u", h = typeof Symbol < "u", y = o(Object.prototype.toString), _ = o(Number.prototype.valueOf), d = o(String.prototype.valueOf), $ = o(Boolean.prototype.valueOf);
  if (l)
    var N = o(BigInt.prototype.valueOf);
  if (h)
    var U = o(Symbol.prototype.valueOf);
  function V(oe, Be) {
    if (typeof oe != "object")
      return !1;
    try {
      return Be(oe), !0;
    } catch {
      return !1;
    }
  }
  e.isArgumentsObject = t, e.isGeneratorFunction = a, e.isTypedArray = u;
  function Q(oe) {
    return typeof Promise < "u" && oe instanceof Promise || oe !== null && typeof oe == "object" && typeof oe.then == "function" && typeof oe.catch == "function";
  }
  e.isPromise = Q;
  function ie(oe) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(oe) : u(oe) || F(oe);
  }
  e.isArrayBufferView = ie;
  function ee(oe) {
    return n(oe) === "Uint8Array";
  }
  e.isUint8Array = ee;
  function ne(oe) {
    return n(oe) === "Uint8ClampedArray";
  }
  e.isUint8ClampedArray = ne;
  function ge(oe) {
    return n(oe) === "Uint16Array";
  }
  e.isUint16Array = ge;
  function be(oe) {
    return n(oe) === "Uint32Array";
  }
  e.isUint32Array = be;
  function Ee(oe) {
    return n(oe) === "Int8Array";
  }
  e.isInt8Array = Ee;
  function xe(oe) {
    return n(oe) === "Int16Array";
  }
  e.isInt16Array = xe;
  function Le(oe) {
    return n(oe) === "Int32Array";
  }
  e.isInt32Array = Le;
  function Ne(oe) {
    return n(oe) === "Float32Array";
  }
  e.isFloat32Array = Ne;
  function Re(oe) {
    return n(oe) === "Float64Array";
  }
  e.isFloat64Array = Re;
  function Xe(oe) {
    return n(oe) === "BigInt64Array";
  }
  e.isBigInt64Array = Xe;
  function pe(oe) {
    return n(oe) === "BigUint64Array";
  }
  e.isBigUint64Array = pe;
  function O(oe) {
    return y(oe) === "[object Map]";
  }
  O.working = typeof Map < "u" && O(/* @__PURE__ */ new Map());
  function E(oe) {
    return typeof Map > "u" ? !1 : O.working ? O(oe) : oe instanceof Map;
  }
  e.isMap = E;
  function c(oe) {
    return y(oe) === "[object Set]";
  }
  c.working = typeof Set < "u" && c(/* @__PURE__ */ new Set());
  function b(oe) {
    return typeof Set > "u" ? !1 : c.working ? c(oe) : oe instanceof Set;
  }
  e.isSet = b;
  function C(oe) {
    return y(oe) === "[object WeakMap]";
  }
  C.working = typeof WeakMap < "u" && C(/* @__PURE__ */ new WeakMap());
  function x(oe) {
    return typeof WeakMap > "u" ? !1 : C.working ? C(oe) : oe instanceof WeakMap;
  }
  e.isWeakMap = x;
  function B(oe) {
    return y(oe) === "[object WeakSet]";
  }
  B.working = typeof WeakSet < "u" && B(/* @__PURE__ */ new WeakSet());
  function k(oe) {
    return B(oe);
  }
  e.isWeakSet = k;
  function w(oe) {
    return y(oe) === "[object ArrayBuffer]";
  }
  w.working = typeof ArrayBuffer < "u" && w(new ArrayBuffer());
  function T(oe) {
    return typeof ArrayBuffer > "u" ? !1 : w.working ? w(oe) : oe instanceof ArrayBuffer;
  }
  e.isArrayBuffer = T;
  function p(oe) {
    return y(oe) === "[object DataView]";
  }
  p.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && p(new DataView(new ArrayBuffer(1), 0, 1));
  function F(oe) {
    return typeof DataView > "u" ? !1 : p.working ? p(oe) : oe instanceof DataView;
  }
  e.isDataView = F;
  var ye = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function _e(oe) {
    return y(oe) === "[object SharedArrayBuffer]";
  }
  function de(oe) {
    return typeof ye > "u" ? !1 : (typeof _e.working > "u" && (_e.working = _e(new ye())), _e.working ? _e(oe) : oe instanceof ye);
  }
  e.isSharedArrayBuffer = de;
  function P(oe) {
    return y(oe) === "[object AsyncFunction]";
  }
  e.isAsyncFunction = P;
  function H(oe) {
    return y(oe) === "[object Map Iterator]";
  }
  e.isMapIterator = H;
  function he(oe) {
    return y(oe) === "[object Set Iterator]";
  }
  e.isSetIterator = he;
  function me(oe) {
    return y(oe) === "[object Generator]";
  }
  e.isGeneratorObject = me;
  function fe(oe) {
    return y(oe) === "[object WebAssembly.Module]";
  }
  e.isWebAssemblyCompiledModule = fe;
  function re(oe) {
    return V(oe, _);
  }
  e.isNumberObject = re;
  function we(oe) {
    return V(oe, d);
  }
  e.isStringObject = we;
  function ke(oe) {
    return V(oe, $);
  }
  e.isBooleanObject = ke;
  function Oe(oe) {
    return l && V(oe, N);
  }
  e.isBigIntObject = Oe;
  function ce(oe) {
    return h && V(oe, U);
  }
  e.isSymbolObject = ce;
  function j(oe) {
    return re(oe) || we(oe) || ke(oe) || Oe(oe) || ce(oe);
  }
  e.isBoxedPrimitive = j;
  function z(oe) {
    return typeof Uint8Array < "u" && (T(oe) || de(oe));
  }
  e.isAnyArrayBuffer = z, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(oe) {
    Object.defineProperty(e, oe, {
      enumerable: !1,
      value: function() {
        throw new Error(oe + " is not supported in userland");
      }
    });
  });
})(types);
var isBufferBrowser = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
};
(function(e) {
  var t = Object.getOwnPropertyDescriptors || function(F) {
    for (var ye = Object.keys(F), _e = {}, de = 0; de < ye.length; de++)
      _e[ye[de]] = Object.getOwnPropertyDescriptor(F, ye[de]);
    return _e;
  }, a = /%[sdj%]/g;
  e.format = function(p) {
    if (!Ee(p)) {
      for (var F = [], ye = 0; ye < arguments.length; ye++)
        F.push(l(arguments[ye]));
      return F.join(" ");
    }
    for (var ye = 1, _e = arguments, de = _e.length, P = String(p).replace(a, function(he) {
      if (he === "%%")
        return "%";
      if (ye >= de)
        return he;
      switch (he) {
        case "%s":
          return String(_e[ye++]);
        case "%d":
          return Number(_e[ye++]);
        case "%j":
          try {
            return JSON.stringify(_e[ye++]);
          } catch {
            return "[Circular]";
          }
        default:
          return he;
      }
    }), H = _e[ye]; ye < de; H = _e[++ye])
      ne(H) || !Re(H) ? P += " " + H : P += " " + l(H);
    return P;
  }, e.deprecate = function(p, F) {
    if (typeof api$2 < "u" && api$2.noDeprecation === !0)
      return p;
    if (typeof api$2 > "u")
      return function() {
        return e.deprecate(p, F).apply(this, arguments);
      };
    var ye = !1;
    function _e() {
      if (!ye) {
        if (api$2.throwDeprecation)
          throw new Error(F);
        api$2.traceDeprecation ? console.trace(F) : console.error(F), ye = !0;
      }
      return p.apply(this, arguments);
    }
    return _e;
  };
  var n = {}, u = /^$/;
  if (api$2.env.NODE_DEBUG) {
    var o = api$2.env.NODE_DEBUG;
    o = o.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), u = new RegExp("^" + o + "$", "i");
  }
  e.debuglog = function(p) {
    if (p = p.toUpperCase(), !n[p])
      if (u.test(p)) {
        var F = api$2.pid;
        n[p] = function() {
          var ye = e.format.apply(e, arguments);
          console.error("%s %d: %s", p, F, ye);
        };
      } else
        n[p] = function() {
        };
    return n[p];
  };
  function l(p, F) {
    var ye = {
      seen: [],
      stylize: y
    };
    return arguments.length >= 3 && (ye.depth = arguments[2]), arguments.length >= 4 && (ye.colors = arguments[3]), ee(F) ? ye.showHidden = F : F && e._extend(ye, F), Le(ye.showHidden) && (ye.showHidden = !1), Le(ye.depth) && (ye.depth = 2), Le(ye.colors) && (ye.colors = !1), Le(ye.customInspect) && (ye.customInspect = !0), ye.colors && (ye.stylize = h), d(ye, p, ye.depth);
  }
  e.inspect = l, l.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, l.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function h(p, F) {
    var ye = l.styles[F];
    return ye ? "\x1B[" + l.colors[ye][0] + "m" + p + "\x1B[" + l.colors[ye][1] + "m" : p;
  }
  function y(p, F) {
    return p;
  }
  function _(p) {
    var F = {};
    return p.forEach(function(ye, _e) {
      F[ye] = !0;
    }), F;
  }
  function d(p, F, ye) {
    if (p.customInspect && F && O(F.inspect) && // Filter out the util module, it's inspect function is special
    F.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
    !(F.constructor && F.constructor.prototype === F)) {
      var _e = F.inspect(ye, p);
      return Ee(_e) || (_e = d(p, _e, ye)), _e;
    }
    var de = $(p, F);
    if (de)
      return de;
    var P = Object.keys(F), H = _(P);
    if (p.showHidden && (P = Object.getOwnPropertyNames(F)), pe(F) && (P.indexOf("message") >= 0 || P.indexOf("description") >= 0))
      return N(F);
    if (P.length === 0) {
      if (O(F)) {
        var he = F.name ? ": " + F.name : "";
        return p.stylize("[Function" + he + "]", "special");
      }
      if (Ne(F))
        return p.stylize(RegExp.prototype.toString.call(F), "regexp");
      if (Xe(F))
        return p.stylize(Date.prototype.toString.call(F), "date");
      if (pe(F))
        return N(F);
    }
    var me = "", fe = !1, re = ["{", "}"];
    if (ie(F) && (fe = !0, re = ["[", "]"]), O(F)) {
      var we = F.name ? ": " + F.name : "";
      me = " [Function" + we + "]";
    }
    if (Ne(F) && (me = " " + RegExp.prototype.toString.call(F)), Xe(F) && (me = " " + Date.prototype.toUTCString.call(F)), pe(F) && (me = " " + N(F)), P.length === 0 && (!fe || F.length == 0))
      return re[0] + me + re[1];
    if (ye < 0)
      return Ne(F) ? p.stylize(RegExp.prototype.toString.call(F), "regexp") : p.stylize("[Object]", "special");
    p.seen.push(F);
    var ke;
    return fe ? ke = U(p, F, ye, H, P) : ke = P.map(function(Oe) {
      return V(p, F, ye, H, Oe, fe);
    }), p.seen.pop(), Q(ke, me, re);
  }
  function $(p, F) {
    if (Le(F))
      return p.stylize("undefined", "undefined");
    if (Ee(F)) {
      var ye = "'" + JSON.stringify(F).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return p.stylize(ye, "string");
    }
    if (be(F))
      return p.stylize("" + F, "number");
    if (ee(F))
      return p.stylize("" + F, "boolean");
    if (ne(F))
      return p.stylize("null", "null");
  }
  function N(p) {
    return "[" + Error.prototype.toString.call(p) + "]";
  }
  function U(p, F, ye, _e, de) {
    for (var P = [], H = 0, he = F.length; H < he; ++H)
      B(F, String(H)) ? P.push(V(
        p,
        F,
        ye,
        _e,
        String(H),
        !0
      )) : P.push("");
    return de.forEach(function(me) {
      me.match(/^\d+$/) || P.push(V(
        p,
        F,
        ye,
        _e,
        me,
        !0
      ));
    }), P;
  }
  function V(p, F, ye, _e, de, P) {
    var H, he, me;
    if (me = Object.getOwnPropertyDescriptor(F, de) || { value: F[de] }, me.get ? me.set ? he = p.stylize("[Getter/Setter]", "special") : he = p.stylize("[Getter]", "special") : me.set && (he = p.stylize("[Setter]", "special")), B(_e, de) || (H = "[" + de + "]"), he || (p.seen.indexOf(me.value) < 0 ? (ne(ye) ? he = d(p, me.value, null) : he = d(p, me.value, ye - 1), he.indexOf(`
`) > -1 && (P ? he = he.split(`
`).map(function(fe) {
      return "  " + fe;
    }).join(`
`).slice(2) : he = `
` + he.split(`
`).map(function(fe) {
      return "   " + fe;
    }).join(`
`))) : he = p.stylize("[Circular]", "special")), Le(H)) {
      if (P && de.match(/^\d+$/))
        return he;
      H = JSON.stringify("" + de), H.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (H = H.slice(1, -1), H = p.stylize(H, "name")) : (H = H.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), H = p.stylize(H, "string"));
    }
    return H + ": " + he;
  }
  function Q(p, F, ye) {
    var _e = p.reduce(function(de, P) {
      return P.indexOf(`
`) >= 0, de + P.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return _e > 60 ? ye[0] + (F === "" ? "" : F + `
 `) + " " + p.join(`,
  `) + " " + ye[1] : ye[0] + F + " " + p.join(", ") + " " + ye[1];
  }
  e.types = types;
  function ie(p) {
    return Array.isArray(p);
  }
  e.isArray = ie;
  function ee(p) {
    return typeof p == "boolean";
  }
  e.isBoolean = ee;
  function ne(p) {
    return p === null;
  }
  e.isNull = ne;
  function ge(p) {
    return p == null;
  }
  e.isNullOrUndefined = ge;
  function be(p) {
    return typeof p == "number";
  }
  e.isNumber = be;
  function Ee(p) {
    return typeof p == "string";
  }
  e.isString = Ee;
  function xe(p) {
    return typeof p == "symbol";
  }
  e.isSymbol = xe;
  function Le(p) {
    return p === void 0;
  }
  e.isUndefined = Le;
  function Ne(p) {
    return Re(p) && c(p) === "[object RegExp]";
  }
  e.isRegExp = Ne, e.types.isRegExp = Ne;
  function Re(p) {
    return typeof p == "object" && p !== null;
  }
  e.isObject = Re;
  function Xe(p) {
    return Re(p) && c(p) === "[object Date]";
  }
  e.isDate = Xe, e.types.isDate = Xe;
  function pe(p) {
    return Re(p) && (c(p) === "[object Error]" || p instanceof Error);
  }
  e.isError = pe, e.types.isNativeError = pe;
  function O(p) {
    return typeof p == "function";
  }
  e.isFunction = O;
  function E(p) {
    return p === null || typeof p == "boolean" || typeof p == "number" || typeof p == "string" || typeof p == "symbol" || // ES6 symbol
    typeof p > "u";
  }
  e.isPrimitive = E, e.isBuffer = isBufferBrowser;
  function c(p) {
    return Object.prototype.toString.call(p);
  }
  function b(p) {
    return p < 10 ? "0" + p.toString(10) : p.toString(10);
  }
  var C = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function x() {
    var p = /* @__PURE__ */ new Date(), F = [
      b(p.getHours()),
      b(p.getMinutes()),
      b(p.getSeconds())
    ].join(":");
    return [p.getDate(), C[p.getMonth()], F].join(" ");
  }
  e.log = function() {
    console.log("%s - %s", x(), e.format.apply(e, arguments));
  }, e.inherits = inherits_browserExports, e._extend = function(p, F) {
    if (!F || !Re(F))
      return p;
    for (var ye = Object.keys(F), _e = ye.length; _e--; )
      p[ye[_e]] = F[ye[_e]];
    return p;
  };
  function B(p, F) {
    return Object.prototype.hasOwnProperty.call(p, F);
  }
  var k = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e.promisify = function(F) {
    if (typeof F != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (k && F[k]) {
      var ye = F[k];
      if (typeof ye != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(ye, k, {
        value: ye,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), ye;
    }
    function ye() {
      for (var _e, de, P = new Promise(function(me, fe) {
        _e = me, de = fe;
      }), H = [], he = 0; he < arguments.length; he++)
        H.push(arguments[he]);
      H.push(function(me, fe) {
        me ? de(me) : _e(fe);
      });
      try {
        F.apply(this, H);
      } catch (me) {
        de(me);
      }
      return P;
    }
    return Object.setPrototypeOf(ye, Object.getPrototypeOf(F)), k && Object.defineProperty(ye, k, {
      value: ye,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      ye,
      t(F)
    );
  }, e.promisify.custom = k;
  function w(p, F) {
    if (!p) {
      var ye = new Error("Promise was rejected with a falsy value");
      ye.reason = p, p = ye;
    }
    return F(p);
  }
  function T(p) {
    if (typeof p != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function F() {
      for (var ye = [], _e = 0; _e < arguments.length; _e++)
        ye.push(arguments[_e]);
      var de = ye.pop();
      if (typeof de != "function")
        throw new TypeError("The last argument must be of type Function");
      var P = this, H = function() {
        return de.apply(P, arguments);
      };
      p.apply(this, ye).then(
        function(he) {
          api$2.nextTick(H.bind(null, null, he));
        },
        function(he) {
          api$2.nextTick(w.bind(null, he, H));
        }
      );
    }
    return Object.setPrototypeOf(F, Object.getPrototypeOf(p)), Object.defineProperties(
      F,
      t(p)
    ), F;
  }
  e.callbackify = T;
})(util$9);
var BufferList$1 = { exports: {} }, hasRequiredBufferList$1;
function requireBufferList$1() {
  return hasRequiredBufferList$1 || (hasRequiredBufferList$1 = 1, function(e) {
    function t(o, l) {
      if (!(o instanceof l))
        throw new TypeError("Cannot call a class as a function");
    }
    var a = safeBufferExports$1.Buffer, n = util$9;
    function u(o, l, h) {
      o.copy(l, h);
    }
    e.exports = function() {
      function o() {
        t(this, o), this.head = null, this.tail = null, this.length = 0;
      }
      return o.prototype.push = function(h) {
        var y = { data: h, next: null };
        this.length > 0 ? this.tail.next = y : this.head = y, this.tail = y, ++this.length;
      }, o.prototype.unshift = function(h) {
        var y = { data: h, next: this.head };
        this.length === 0 && (this.tail = y), this.head = y, ++this.length;
      }, o.prototype.shift = function() {
        if (this.length !== 0) {
          var h = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, h;
        }
      }, o.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, o.prototype.join = function(h) {
        if (this.length === 0)
          return "";
        for (var y = this.head, _ = "" + y.data; y = y.next; )
          _ += h + y.data;
        return _;
      }, o.prototype.concat = function(h) {
        if (this.length === 0)
          return a.alloc(0);
        for (var y = a.allocUnsafe(h >>> 0), _ = this.head, d = 0; _; )
          u(_.data, y, d), d += _.data.length, _ = _.next;
        return y;
      }, o;
    }(), n && n.inspect && n.inspect.custom && (e.exports.prototype[n.inspect.custom] = function() {
      var o = n.inspect({ length: this.length });
      return this.constructor.name + " " + o;
    });
  }(BufferList$1)), BufferList$1.exports;
}
var pna$1 = processNextickArgsExports;
function destroy$1(e, t) {
  var a = this, n = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
  return n || u ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, pna$1.nextTick(emitErrorNT$1, this, e)) : pna$1.nextTick(emitErrorNT$1, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(o) {
    !t && o ? a._writableState ? a._writableState.errorEmitted || (a._writableState.errorEmitted = !0, pna$1.nextTick(emitErrorNT$1, a, o)) : pna$1.nextTick(emitErrorNT$1, a, o) : t && t(o);
  }), this);
}
function undestroy$1() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT$1(e, t) {
  e.emit("error", t);
}
var destroy_1$2 = {
  destroy: destroy$1,
  undestroy: undestroy$1
}, browser$a = deprecate;
function deprecate(e, t) {
  if (config("noDeprecation"))
    return e;
  var a = !1;
  function n() {
    if (!a) {
      if (config("throwDeprecation"))
        throw new Error(t);
      config("traceDeprecation") ? console.trace(t) : console.warn(t), a = !0;
    }
    return e.apply(this, arguments);
  }
  return n;
}
function config(e) {
  try {
    if (!commonjsGlobal.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = commonjsGlobal.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var _stream_writable$2, hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2)
    return _stream_writable$2;
  hasRequired_stream_writable$2 = 1;
  var e = processNextickArgsExports;
  _stream_writable$2 = Q;
  function t(x) {
    var B = this;
    this.next = null, this.entry = null, this.finish = function() {
      C(B, x);
    };
  }
  var a = !api$2.browser && ["v0.10", "v0.9."].indexOf(api$2.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, n;
  Q.WritableState = U;
  var u = Object.create(util$a);
  u.inherits = inherits_browserExports;
  var o = {
    deprecate: browser$a
  }, l = streamBrowser$2, h = safeBufferExports$1.Buffer, y = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(x) {
    return h.from(x);
  }
  function d(x) {
    return h.isBuffer(x) || x instanceof y;
  }
  var $ = destroy_1$2;
  u.inherits(Q, l);
  function N() {
  }
  function U(x, B) {
    n = n || require_stream_duplex$2(), x = x || {};
    var k = B instanceof n;
    this.objectMode = !!x.objectMode, k && (this.objectMode = this.objectMode || !!x.writableObjectMode);
    var w = x.highWaterMark, T = x.writableHighWaterMark, p = this.objectMode ? 16 : 16 * 1024;
    w || w === 0 ? this.highWaterMark = w : k && (T || T === 0) ? this.highWaterMark = T : this.highWaterMark = p, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var F = x.decodeStrings === !1;
    this.decodeStrings = !F, this.defaultEncoding = x.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ye) {
      Le(B, ye);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  U.prototype.getBuffer = function() {
    for (var B = this.bufferedRequest, k = []; B; )
      k.push(B), B = B.next;
    return k;
  }, function() {
    try {
      Object.defineProperty(U.prototype, "buffer", {
        get: o.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var V;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (V = Function.prototype[Symbol.hasInstance], Object.defineProperty(Q, Symbol.hasInstance, {
    value: function(x) {
      return V.call(this, x) ? !0 : this !== Q ? !1 : x && x._writableState instanceof U;
    }
  })) : V = function(x) {
    return x instanceof this;
  };
  function Q(x) {
    if (n = n || require_stream_duplex$2(), !V.call(Q, this) && !(this instanceof n))
      return new Q(x);
    this._writableState = new U(x, this), this.writable = !0, x && (typeof x.write == "function" && (this._write = x.write), typeof x.writev == "function" && (this._writev = x.writev), typeof x.destroy == "function" && (this._destroy = x.destroy), typeof x.final == "function" && (this._final = x.final)), l.call(this);
  }
  Q.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function ie(x, B) {
    var k = new Error("write after end");
    x.emit("error", k), e.nextTick(B, k);
  }
  function ee(x, B, k, w) {
    var T = !0, p = !1;
    return k === null ? p = new TypeError("May not write null values to stream") : typeof k != "string" && k !== void 0 && !B.objectMode && (p = new TypeError("Invalid non-string/buffer chunk")), p && (x.emit("error", p), e.nextTick(w, p), T = !1), T;
  }
  Q.prototype.write = function(x, B, k) {
    var w = this._writableState, T = !1, p = !w.objectMode && d(x);
    return p && !h.isBuffer(x) && (x = _(x)), typeof B == "function" && (k = B, B = null), p ? B = "buffer" : B || (B = w.defaultEncoding), typeof k != "function" && (k = N), w.ended ? ie(this, k) : (p || ee(this, w, x, k)) && (w.pendingcb++, T = ge(this, w, p, x, B, k)), T;
  }, Q.prototype.cork = function() {
    var x = this._writableState;
    x.corked++;
  }, Q.prototype.uncork = function() {
    var x = this._writableState;
    x.corked && (x.corked--, !x.writing && !x.corked && !x.bufferProcessing && x.bufferedRequest && Xe(this, x));
  }, Q.prototype.setDefaultEncoding = function(B) {
    if (typeof B == "string" && (B = B.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((B + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + B);
    return this._writableState.defaultEncoding = B, this;
  };
  function ne(x, B, k) {
    return !x.objectMode && x.decodeStrings !== !1 && typeof B == "string" && (B = h.from(B, k)), B;
  }
  Object.defineProperty(Q.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ge(x, B, k, w, T, p) {
    if (!k) {
      var F = ne(B, w, T);
      w !== F && (k = !0, T = "buffer", w = F);
    }
    var ye = B.objectMode ? 1 : w.length;
    B.length += ye;
    var _e = B.length < B.highWaterMark;
    if (_e || (B.needDrain = !0), B.writing || B.corked) {
      var de = B.lastBufferedRequest;
      B.lastBufferedRequest = {
        chunk: w,
        encoding: T,
        isBuf: k,
        callback: p,
        next: null
      }, de ? de.next = B.lastBufferedRequest : B.bufferedRequest = B.lastBufferedRequest, B.bufferedRequestCount += 1;
    } else
      be(x, B, !1, ye, w, T, p);
    return _e;
  }
  function be(x, B, k, w, T, p, F) {
    B.writelen = w, B.writecb = F, B.writing = !0, B.sync = !0, k ? x._writev(T, B.onwrite) : x._write(T, p, B.onwrite), B.sync = !1;
  }
  function Ee(x, B, k, w, T) {
    --B.pendingcb, k ? (e.nextTick(T, w), e.nextTick(c, x, B), x._writableState.errorEmitted = !0, x.emit("error", w)) : (T(w), x._writableState.errorEmitted = !0, x.emit("error", w), c(x, B));
  }
  function xe(x) {
    x.writing = !1, x.writecb = null, x.length -= x.writelen, x.writelen = 0;
  }
  function Le(x, B) {
    var k = x._writableState, w = k.sync, T = k.writecb;
    if (xe(k), B)
      Ee(x, k, w, B, T);
    else {
      var p = pe(k);
      !p && !k.corked && !k.bufferProcessing && k.bufferedRequest && Xe(x, k), w ? a(Ne, x, k, p, T) : Ne(x, k, p, T);
    }
  }
  function Ne(x, B, k, w) {
    k || Re(x, B), B.pendingcb--, w(), c(x, B);
  }
  function Re(x, B) {
    B.length === 0 && B.needDrain && (B.needDrain = !1, x.emit("drain"));
  }
  function Xe(x, B) {
    B.bufferProcessing = !0;
    var k = B.bufferedRequest;
    if (x._writev && k && k.next) {
      var w = B.bufferedRequestCount, T = new Array(w), p = B.corkedRequestsFree;
      p.entry = k;
      for (var F = 0, ye = !0; k; )
        T[F] = k, k.isBuf || (ye = !1), k = k.next, F += 1;
      T.allBuffers = ye, be(x, B, !0, B.length, T, "", p.finish), B.pendingcb++, B.lastBufferedRequest = null, p.next ? (B.corkedRequestsFree = p.next, p.next = null) : B.corkedRequestsFree = new t(B), B.bufferedRequestCount = 0;
    } else {
      for (; k; ) {
        var _e = k.chunk, de = k.encoding, P = k.callback, H = B.objectMode ? 1 : _e.length;
        if (be(x, B, !1, H, _e, de, P), k = k.next, B.bufferedRequestCount--, B.writing)
          break;
      }
      k === null && (B.lastBufferedRequest = null);
    }
    B.bufferedRequest = k, B.bufferProcessing = !1;
  }
  Q.prototype._write = function(x, B, k) {
    k(new Error("_write() is not implemented"));
  }, Q.prototype._writev = null, Q.prototype.end = function(x, B, k) {
    var w = this._writableState;
    typeof x == "function" ? (k = x, x = null, B = null) : typeof B == "function" && (k = B, B = null), x != null && this.write(x, B), w.corked && (w.corked = 1, this.uncork()), w.ending || b(this, w, k);
  };
  function pe(x) {
    return x.ending && x.length === 0 && x.bufferedRequest === null && !x.finished && !x.writing;
  }
  function O(x, B) {
    x._final(function(k) {
      B.pendingcb--, k && x.emit("error", k), B.prefinished = !0, x.emit("prefinish"), c(x, B);
    });
  }
  function E(x, B) {
    !B.prefinished && !B.finalCalled && (typeof x._final == "function" ? (B.pendingcb++, B.finalCalled = !0, e.nextTick(O, x, B)) : (B.prefinished = !0, x.emit("prefinish")));
  }
  function c(x, B) {
    var k = pe(B);
    return k && (E(x, B), B.pendingcb === 0 && (B.finished = !0, x.emit("finish"))), k;
  }
  function b(x, B, k) {
    B.ending = !0, c(x, B), k && (B.finished ? e.nextTick(k) : x.once("finish", k)), B.ended = !0, x.writable = !1;
  }
  function C(x, B, k) {
    var w = x.entry;
    for (x.entry = null; w; ) {
      var T = w.callback;
      B.pendingcb--, T(k), w = w.next;
    }
    B.corkedRequestsFree.next = x;
  }
  return Object.defineProperty(Q.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(x) {
      this._writableState && (this._writableState.destroyed = x);
    }
  }), Q.prototype.destroy = $.destroy, Q.prototype._undestroy = $.undestroy, Q.prototype._destroy = function(x, B) {
    this.end(), B(x);
  }, _stream_writable$2;
}
var _stream_duplex$2, hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2)
    return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var e = processNextickArgsExports, t = Object.keys || function($) {
    var N = [];
    for (var U in $)
      N.push(U);
    return N;
  };
  _stream_duplex$2 = y;
  var a = Object.create(util$a);
  a.inherits = inherits_browserExports;
  var n = require_stream_readable$2(), u = require_stream_writable$2();
  a.inherits(y, n);
  for (var o = t(u.prototype), l = 0; l < o.length; l++) {
    var h = o[l];
    y.prototype[h] || (y.prototype[h] = u.prototype[h]);
  }
  function y($) {
    if (!(this instanceof y))
      return new y($);
    n.call(this, $), u.call(this, $), $ && $.readable === !1 && (this.readable = !1), $ && $.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, $ && $.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", _);
  }
  Object.defineProperty(y.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function _() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(d, this);
  }
  function d($) {
    $.end();
  }
  return Object.defineProperty(y.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function($) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = $, this._writableState.destroyed = $);
    }
  }), y.prototype._destroy = function($, N) {
    this.push(null), this.end(), e.nextTick(N, $);
  }, _stream_duplex$2;
}
var string_decoder = {}, Buffer$A = safeBufferExports$2.Buffer, isEncoding = Buffer$A.isEncoding || function(e) {
  switch (e = "" + e, e && e.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(e) {
  if (!e)
    return "utf8";
  for (var t; ; )
    switch (e) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return e;
      default:
        if (t)
          return;
        e = ("" + e).toLowerCase(), t = !0;
    }
}
function normalizeEncoding(e) {
  var t = _normalizeEncoding(e);
  if (typeof t != "string" && (Buffer$A.isEncoding === isEncoding || !isEncoding(e)))
    throw new Error("Unknown encoding: " + e);
  return t || e;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(e) {
  this.encoding = normalizeEncoding(e);
  var t;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, t = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, t = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, t = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$A.allocUnsafe(t);
}
StringDecoder$1.prototype.write = function(e) {
  if (e.length === 0)
    return "";
  var t, a;
  if (this.lastNeed) {
    if (t = this.fillLast(e), t === void 0)
      return "";
    a = this.lastNeed, this.lastNeed = 0;
  } else
    a = 0;
  return a < e.length ? t ? t + this.text(e, a) : this.text(e, a) : t || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(e) {
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
};
function utf8CheckByte(e) {
  return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(e, t, a) {
  var n = t.length - 1;
  if (n < a)
    return 0;
  var u = utf8CheckByte(t[n]);
  return u >= 0 ? (u > 0 && (e.lastNeed = u - 1), u) : --n < a || u === -2 ? 0 : (u = utf8CheckByte(t[n]), u >= 0 ? (u > 0 && (e.lastNeed = u - 2), u) : --n < a || u === -2 ? 0 : (u = utf8CheckByte(t[n]), u >= 0 ? (u > 0 && (u === 2 ? u = 0 : e.lastNeed = u - 3), u) : 0));
}
function utf8CheckExtraBytes(e, t, a) {
  if ((t[0] & 192) !== 128)
    return e.lastNeed = 0, "";
  if (e.lastNeed > 1 && t.length > 1) {
    if ((t[1] & 192) !== 128)
      return e.lastNeed = 1, "";
    if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
      return e.lastNeed = 2, "";
  }
}
function utf8FillLast(e) {
  var t = this.lastTotal - this.lastNeed, a = utf8CheckExtraBytes(this, e);
  if (a !== void 0)
    return a;
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
}
function utf8Text(e, t) {
  var a = utf8CheckIncomplete(this, e, t);
  if (!this.lastNeed)
    return e.toString("utf8", t);
  this.lastTotal = a;
  var n = e.length - (a - this.lastNeed);
  return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
}
function utf8End(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + "" : t;
}
function utf16Text(e, t) {
  if ((e.length - t) % 2 === 0) {
    var a = e.toString("utf16le", t);
    if (a) {
      var n = a.charCodeAt(a.length - 1);
      if (n >= 55296 && n <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], a.slice(0, -1);
    }
    return a;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
}
function utf16End(e) {
  var t = e && e.length ? this.write(e) : "";
  if (this.lastNeed) {
    var a = this.lastTotal - this.lastNeed;
    return t + this.lastChar.toString("utf16le", 0, a);
  }
  return t;
}
function base64Text(e, t) {
  var a = (e.length - t) % 3;
  return a === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - a, this.lastTotal = 3, a === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - a));
}
function base64End(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}
function simpleWrite(e) {
  return e.toString(this.encoding);
}
function simpleEnd(e) {
  return e && e.length ? this.write(e) : "";
}
var _stream_readable$2, hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2)
    return _stream_readable$2;
  hasRequired_stream_readable$2 = 1;
  var e = processNextickArgsExports;
  _stream_readable$2 = ne;
  var t = isarray$1, a;
  ne.ReadableState = ee, eventsExports.EventEmitter;
  var n = function(P, H) {
    return P.listeners(H).length;
  }, u = streamBrowser$2, o = safeBufferExports$1.Buffer, l = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function h(P) {
    return o.from(P);
  }
  function y(P) {
    return o.isBuffer(P) || P instanceof l;
  }
  var _ = Object.create(util$a);
  _.inherits = inherits_browserExports;
  var d = util$9, $ = void 0;
  d && d.debuglog ? $ = d.debuglog("stream") : $ = function() {
  };
  var N = requireBufferList$1(), U = destroy_1$2, V;
  _.inherits(ne, u);
  var Q = ["error", "close", "destroy", "pause", "resume"];
  function ie(P, H, he) {
    if (typeof P.prependListener == "function")
      return P.prependListener(H, he);
    !P._events || !P._events[H] ? P.on(H, he) : t(P._events[H]) ? P._events[H].unshift(he) : P._events[H] = [he, P._events[H]];
  }
  function ee(P, H) {
    a = a || require_stream_duplex$2(), P = P || {};
    var he = H instanceof a;
    this.objectMode = !!P.objectMode, he && (this.objectMode = this.objectMode || !!P.readableObjectMode);
    var me = P.highWaterMark, fe = P.readableHighWaterMark, re = this.objectMode ? 16 : 16 * 1024;
    me || me === 0 ? this.highWaterMark = me : he && (fe || fe === 0) ? this.highWaterMark = fe : this.highWaterMark = re, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new N(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = P.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, P.encoding && (V || (V = string_decoder.StringDecoder), this.decoder = new V(P.encoding), this.encoding = P.encoding);
  }
  function ne(P) {
    if (a = a || require_stream_duplex$2(), !(this instanceof ne))
      return new ne(P);
    this._readableState = new ee(P, this), this.readable = !0, P && (typeof P.read == "function" && (this._read = P.read), typeof P.destroy == "function" && (this._destroy = P.destroy)), u.call(this);
  }
  Object.defineProperty(ne.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(P) {
      this._readableState && (this._readableState.destroyed = P);
    }
  }), ne.prototype.destroy = U.destroy, ne.prototype._undestroy = U.undestroy, ne.prototype._destroy = function(P, H) {
    this.push(null), H(P);
  }, ne.prototype.push = function(P, H) {
    var he = this._readableState, me;
    return he.objectMode ? me = !0 : typeof P == "string" && (H = H || he.defaultEncoding, H !== he.encoding && (P = o.from(P, H), H = ""), me = !0), ge(this, P, H, !1, me);
  }, ne.prototype.unshift = function(P) {
    return ge(this, P, null, !0, !1);
  };
  function ge(P, H, he, me, fe) {
    var re = P._readableState;
    if (H === null)
      re.reading = !1, Xe(P, re);
    else {
      var we;
      fe || (we = Ee(re, H)), we ? P.emit("error", we) : re.objectMode || H && H.length > 0 ? (typeof H != "string" && !re.objectMode && Object.getPrototypeOf(H) !== o.prototype && (H = h(H)), me ? re.endEmitted ? P.emit("error", new Error("stream.unshift() after end event")) : be(P, re, H, !0) : re.ended ? P.emit("error", new Error("stream.push() after EOF")) : (re.reading = !1, re.decoder && !he ? (H = re.decoder.write(H), re.objectMode || H.length !== 0 ? be(P, re, H, !1) : E(P, re)) : be(P, re, H, !1))) : me || (re.reading = !1);
    }
    return xe(re);
  }
  function be(P, H, he, me) {
    H.flowing && H.length === 0 && !H.sync ? (P.emit("data", he), P.read(0)) : (H.length += H.objectMode ? 1 : he.length, me ? H.buffer.unshift(he) : H.buffer.push(he), H.needReadable && pe(P)), E(P, H);
  }
  function Ee(P, H) {
    var he;
    return !y(H) && typeof H != "string" && H !== void 0 && !P.objectMode && (he = new TypeError("Invalid non-string/buffer chunk")), he;
  }
  function xe(P) {
    return !P.ended && (P.needReadable || P.length < P.highWaterMark || P.length === 0);
  }
  ne.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ne.prototype.setEncoding = function(P) {
    return V || (V = string_decoder.StringDecoder), this._readableState.decoder = new V(P), this._readableState.encoding = P, this;
  };
  var Le = 8388608;
  function Ne(P) {
    return P >= Le ? P = Le : (P--, P |= P >>> 1, P |= P >>> 2, P |= P >>> 4, P |= P >>> 8, P |= P >>> 16, P++), P;
  }
  function Re(P, H) {
    return P <= 0 || H.length === 0 && H.ended ? 0 : H.objectMode ? 1 : P !== P ? H.flowing && H.length ? H.buffer.head.data.length : H.length : (P > H.highWaterMark && (H.highWaterMark = Ne(P)), P <= H.length ? P : H.ended ? H.length : (H.needReadable = !0, 0));
  }
  ne.prototype.read = function(P) {
    $("read", P), P = parseInt(P, 10);
    var H = this._readableState, he = P;
    if (P !== 0 && (H.emittedReadable = !1), P === 0 && H.needReadable && (H.length >= H.highWaterMark || H.ended))
      return $("read: emitReadable", H.length, H.ended), H.length === 0 && H.ended ? ye(this) : pe(this), null;
    if (P = Re(P, H), P === 0 && H.ended)
      return H.length === 0 && ye(this), null;
    var me = H.needReadable;
    $("need readable", me), (H.length === 0 || H.length - P < H.highWaterMark) && (me = !0, $("length less than watermark", me)), H.ended || H.reading ? (me = !1, $("reading or ended", me)) : me && ($("do read"), H.reading = !0, H.sync = !0, H.length === 0 && (H.needReadable = !0), this._read(H.highWaterMark), H.sync = !1, H.reading || (P = Re(he, H)));
    var fe;
    return P > 0 ? fe = w(P, H) : fe = null, fe === null ? (H.needReadable = !0, P = 0) : H.length -= P, H.length === 0 && (H.ended || (H.needReadable = !0), he !== P && H.ended && ye(this)), fe !== null && this.emit("data", fe), fe;
  };
  function Xe(P, H) {
    if (!H.ended) {
      if (H.decoder) {
        var he = H.decoder.end();
        he && he.length && (H.buffer.push(he), H.length += H.objectMode ? 1 : he.length);
      }
      H.ended = !0, pe(P);
    }
  }
  function pe(P) {
    var H = P._readableState;
    H.needReadable = !1, H.emittedReadable || ($("emitReadable", H.flowing), H.emittedReadable = !0, H.sync ? e.nextTick(O, P) : O(P));
  }
  function O(P) {
    $("emit readable"), P.emit("readable"), k(P);
  }
  function E(P, H) {
    H.readingMore || (H.readingMore = !0, e.nextTick(c, P, H));
  }
  function c(P, H) {
    for (var he = H.length; !H.reading && !H.flowing && !H.ended && H.length < H.highWaterMark && ($("maybeReadMore read 0"), P.read(0), he !== H.length); )
      he = H.length;
    H.readingMore = !1;
  }
  ne.prototype._read = function(P) {
    this.emit("error", new Error("_read() is not implemented"));
  }, ne.prototype.pipe = function(P, H) {
    var he = this, me = this._readableState;
    switch (me.pipesCount) {
      case 0:
        me.pipes = P;
        break;
      case 1:
        me.pipes = [me.pipes, P];
        break;
      default:
        me.pipes.push(P);
        break;
    }
    me.pipesCount += 1, $("pipe count=%d opts=%j", me.pipesCount, H);
    var fe = (!H || H.end !== !1) && P !== api$2.stdout && P !== api$2.stderr, re = fe ? ke : Ye;
    me.endEmitted ? e.nextTick(re) : he.once("end", re), P.on("unpipe", we);
    function we(He, ot) {
      $("onunpipe"), He === he && ot && ot.hasUnpiped === !1 && (ot.hasUnpiped = !0, j());
    }
    function ke() {
      $("onend"), P.end();
    }
    var Oe = b(he);
    P.on("drain", Oe);
    var ce = !1;
    function j() {
      $("cleanup"), P.removeListener("close", Te), P.removeListener("finish", Pe), P.removeListener("drain", Oe), P.removeListener("error", Be), P.removeListener("unpipe", we), he.removeListener("end", ke), he.removeListener("end", Ye), he.removeListener("data", oe), ce = !0, me.awaitDrain && (!P._writableState || P._writableState.needDrain) && Oe();
    }
    var z = !1;
    he.on("data", oe);
    function oe(He) {
      $("ondata"), z = !1;
      var ot = P.write(He);
      ot === !1 && !z && ((me.pipesCount === 1 && me.pipes === P || me.pipesCount > 1 && de(me.pipes, P) !== -1) && !ce && ($("false write response, pause", me.awaitDrain), me.awaitDrain++, z = !0), he.pause());
    }
    function Be(He) {
      $("onerror", He), Ye(), P.removeListener("error", Be), n(P, "error") === 0 && P.emit("error", He);
    }
    ie(P, "error", Be);
    function Te() {
      P.removeListener("finish", Pe), Ye();
    }
    P.once("close", Te);
    function Pe() {
      $("onfinish"), P.removeListener("close", Te), Ye();
    }
    P.once("finish", Pe);
    function Ye() {
      $("unpipe"), he.unpipe(P);
    }
    return P.emit("pipe", he), me.flowing || ($("pipe resume"), he.resume()), P;
  };
  function b(P) {
    return function() {
      var H = P._readableState;
      $("pipeOnDrain", H.awaitDrain), H.awaitDrain && H.awaitDrain--, H.awaitDrain === 0 && n(P, "data") && (H.flowing = !0, k(P));
    };
  }
  ne.prototype.unpipe = function(P) {
    var H = this._readableState, he = { hasUnpiped: !1 };
    if (H.pipesCount === 0)
      return this;
    if (H.pipesCount === 1)
      return P && P !== H.pipes ? this : (P || (P = H.pipes), H.pipes = null, H.pipesCount = 0, H.flowing = !1, P && P.emit("unpipe", this, he), this);
    if (!P) {
      var me = H.pipes, fe = H.pipesCount;
      H.pipes = null, H.pipesCount = 0, H.flowing = !1;
      for (var re = 0; re < fe; re++)
        me[re].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var we = de(H.pipes, P);
    return we === -1 ? this : (H.pipes.splice(we, 1), H.pipesCount -= 1, H.pipesCount === 1 && (H.pipes = H.pipes[0]), P.emit("unpipe", this, he), this);
  }, ne.prototype.on = function(P, H) {
    var he = u.prototype.on.call(this, P, H);
    if (P === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (P === "readable") {
      var me = this._readableState;
      !me.endEmitted && !me.readableListening && (me.readableListening = me.needReadable = !0, me.emittedReadable = !1, me.reading ? me.length && pe(this) : e.nextTick(C, this));
    }
    return he;
  }, ne.prototype.addListener = ne.prototype.on;
  function C(P) {
    $("readable nexttick read 0"), P.read(0);
  }
  ne.prototype.resume = function() {
    var P = this._readableState;
    return P.flowing || ($("resume"), P.flowing = !0, x(this, P)), this;
  };
  function x(P, H) {
    H.resumeScheduled || (H.resumeScheduled = !0, e.nextTick(B, P, H));
  }
  function B(P, H) {
    H.reading || ($("resume read 0"), P.read(0)), H.resumeScheduled = !1, H.awaitDrain = 0, P.emit("resume"), k(P), H.flowing && !H.reading && P.read(0);
  }
  ne.prototype.pause = function() {
    return $("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && ($("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function k(P) {
    var H = P._readableState;
    for ($("flow", H.flowing); H.flowing && P.read() !== null; )
      ;
  }
  ne.prototype.wrap = function(P) {
    var H = this, he = this._readableState, me = !1;
    P.on("end", function() {
      if ($("wrapped end"), he.decoder && !he.ended) {
        var we = he.decoder.end();
        we && we.length && H.push(we);
      }
      H.push(null);
    }), P.on("data", function(we) {
      if ($("wrapped data"), he.decoder && (we = he.decoder.write(we)), !(he.objectMode && we == null) && !(!he.objectMode && (!we || !we.length))) {
        var ke = H.push(we);
        ke || (me = !0, P.pause());
      }
    });
    for (var fe in P)
      this[fe] === void 0 && typeof P[fe] == "function" && (this[fe] = function(we) {
        return function() {
          return P[we].apply(P, arguments);
        };
      }(fe));
    for (var re = 0; re < Q.length; re++)
      P.on(Q[re], this.emit.bind(this, Q[re]));
    return this._read = function(we) {
      $("wrapped _read", we), me && (me = !1, P.resume());
    }, this;
  }, Object.defineProperty(ne.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), ne._fromList = w;
  function w(P, H) {
    if (H.length === 0)
      return null;
    var he;
    return H.objectMode ? he = H.buffer.shift() : !P || P >= H.length ? (H.decoder ? he = H.buffer.join("") : H.buffer.length === 1 ? he = H.buffer.head.data : he = H.buffer.concat(H.length), H.buffer.clear()) : he = T(P, H.buffer, H.decoder), he;
  }
  function T(P, H, he) {
    var me;
    return P < H.head.data.length ? (me = H.head.data.slice(0, P), H.head.data = H.head.data.slice(P)) : P === H.head.data.length ? me = H.shift() : me = he ? p(P, H) : F(P, H), me;
  }
  function p(P, H) {
    var he = H.head, me = 1, fe = he.data;
    for (P -= fe.length; he = he.next; ) {
      var re = he.data, we = P > re.length ? re.length : P;
      if (we === re.length ? fe += re : fe += re.slice(0, P), P -= we, P === 0) {
        we === re.length ? (++me, he.next ? H.head = he.next : H.head = H.tail = null) : (H.head = he, he.data = re.slice(we));
        break;
      }
      ++me;
    }
    return H.length -= me, fe;
  }
  function F(P, H) {
    var he = o.allocUnsafe(P), me = H.head, fe = 1;
    for (me.data.copy(he), P -= me.data.length; me = me.next; ) {
      var re = me.data, we = P > re.length ? re.length : P;
      if (re.copy(he, he.length - P, 0, we), P -= we, P === 0) {
        we === re.length ? (++fe, me.next ? H.head = me.next : H.head = H.tail = null) : (H.head = me, me.data = re.slice(we));
        break;
      }
      ++fe;
    }
    return H.length -= fe, he;
  }
  function ye(P) {
    var H = P._readableState;
    if (H.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    H.endEmitted || (H.ended = !0, e.nextTick(_e, H, P));
  }
  function _e(P, H) {
    !P.endEmitted && P.length === 0 && (P.endEmitted = !0, H.readable = !1, H.emit("end"));
  }
  function de(P, H) {
    for (var he = 0, me = P.length; he < me; he++)
      if (P[he] === H)
        return he;
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2 = Transform$9, Duplex$1 = require_stream_duplex$2(), util$8 = Object.create(util$a);
util$8.inherits = inherits_browserExports;
util$8.inherits(Transform$9, Duplex$1);
function afterTransform$1(e, t) {
  var a = this._transformState;
  a.transforming = !1;
  var n = a.writecb;
  if (!n)
    return this.emit("error", new Error("write callback called multiple times"));
  a.writechunk = null, a.writecb = null, t != null && this.push(t), n(e);
  var u = this._readableState;
  u.reading = !1, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
}
function Transform$9(e) {
  if (!(this instanceof Transform$9))
    return new Transform$9(e);
  Duplex$1.call(this, e), this._transformState = {
    afterTransform: afterTransform$1.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", prefinish$1);
}
function prefinish$1() {
  var e = this;
  typeof this._flush == "function" ? this._flush(function(t, a) {
    done$1(e, t, a);
  }) : done$1(this, null, null);
}
Transform$9.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Duplex$1.prototype.push.call(this, e, t);
};
Transform$9.prototype._transform = function(e, t, a) {
  throw new Error("_transform() is not implemented");
};
Transform$9.prototype._write = function(e, t, a) {
  var n = this._transformState;
  if (n.writecb = a, n.writechunk = e, n.writeencoding = t, !n.transforming) {
    var u = this._readableState;
    (n.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
  }
};
Transform$9.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Transform$9.prototype._destroy = function(e, t) {
  var a = this;
  Duplex$1.prototype._destroy.call(this, e, function(n) {
    t(n), a.emit("close");
  });
};
function done$1(e, t, a) {
  if (t)
    return e.emit("error", t);
  if (a != null && e.push(a), e._writableState.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (e._transformState.transforming)
    throw new Error("Calling transform done when still transforming");
  return e.push(null);
}
var _stream_passthrough$2 = PassThrough$1, Transform$8 = _stream_transform$2, util$7 = Object.create(util$a);
util$7.inherits = inherits_browserExports;
util$7.inherits(PassThrough$1, Transform$8);
function PassThrough$1(e) {
  if (!(this instanceof PassThrough$1))
    return new PassThrough$1(e);
  Transform$8.call(this, e);
}
PassThrough$1.prototype._transform = function(e, t, a) {
  a(null, e);
};
(function(e, t) {
  t = e.exports = require_stream_readable$2(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable$2(), t.Duplex = require_stream_duplex$2(), t.Transform = _stream_transform$2, t.PassThrough = _stream_passthrough$2;
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports, Buffer$z = safeBufferExports$2.Buffer, toBuffer$5 = toBuffer_1$1, Transform$7 = readableBrowserExports$1.Transform, inherits$q = inherits_browserExports;
function HashBase$2(e) {
  Transform$7.call(this), this._block = Buffer$z.allocUnsafe(e), this._blockSize = e, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$q(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(e, t, a) {
  var n = null;
  try {
    this.update(e, t);
  } catch (u) {
    n = u;
  }
  a(n);
};
HashBase$2.prototype._flush = function(e) {
  var t = null;
  try {
    this.push(this.digest());
  } catch (a) {
    t = a;
  }
  e(t);
};
HashBase$2.prototype.update = function(e, t) {
  if (this._finalized)
    throw new Error("Digest already called");
  for (var a = toBuffer$5(e, t), n = this._block, u = 0; this._blockOffset + a.length - u >= this._blockSize; ) {
    for (var o = this._blockOffset; o < this._blockSize; )
      n[o] = a[u], o += 1, u += 1;
    this._update(), this._blockOffset = 0;
  }
  for (; u < a.length; )
    n[this._blockOffset] = a[u], this._blockOffset += 1, u += 1;
  for (var l = 0, h = a.length * 8; h > 0; ++l)
    this._length[l] += h, h = this._length[l] / 4294967296 | 0, h > 0 && (this._length[l] -= 4294967296 * h);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(e) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var t = this._digest();
  e !== void 0 && (t = t.toString(e)), this._block.fill(0), this._blockOffset = 0;
  for (var a = 0; a < 4; ++a)
    this._length[a] = 0;
  return t;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$p = inherits_browserExports, HashBase$1 = hashBase, Buffer$y = safeBufferExports$2.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$p(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var e = ARRAY16$1, t = 0; t < 16; ++t)
    e[t] = this._block.readInt32LE(t * 4);
  var a = this._a, n = this._b, u = this._c, o = this._d;
  a = fnF(a, n, u, o, e[0], 3614090360, 7), o = fnF(o, a, n, u, e[1], 3905402710, 12), u = fnF(u, o, a, n, e[2], 606105819, 17), n = fnF(n, u, o, a, e[3], 3250441966, 22), a = fnF(a, n, u, o, e[4], 4118548399, 7), o = fnF(o, a, n, u, e[5], 1200080426, 12), u = fnF(u, o, a, n, e[6], 2821735955, 17), n = fnF(n, u, o, a, e[7], 4249261313, 22), a = fnF(a, n, u, o, e[8], 1770035416, 7), o = fnF(o, a, n, u, e[9], 2336552879, 12), u = fnF(u, o, a, n, e[10], 4294925233, 17), n = fnF(n, u, o, a, e[11], 2304563134, 22), a = fnF(a, n, u, o, e[12], 1804603682, 7), o = fnF(o, a, n, u, e[13], 4254626195, 12), u = fnF(u, o, a, n, e[14], 2792965006, 17), n = fnF(n, u, o, a, e[15], 1236535329, 22), a = fnG(a, n, u, o, e[1], 4129170786, 5), o = fnG(o, a, n, u, e[6], 3225465664, 9), u = fnG(u, o, a, n, e[11], 643717713, 14), n = fnG(n, u, o, a, e[0], 3921069994, 20), a = fnG(a, n, u, o, e[5], 3593408605, 5), o = fnG(o, a, n, u, e[10], 38016083, 9), u = fnG(u, o, a, n, e[15], 3634488961, 14), n = fnG(n, u, o, a, e[4], 3889429448, 20), a = fnG(a, n, u, o, e[9], 568446438, 5), o = fnG(o, a, n, u, e[14], 3275163606, 9), u = fnG(u, o, a, n, e[3], 4107603335, 14), n = fnG(n, u, o, a, e[8], 1163531501, 20), a = fnG(a, n, u, o, e[13], 2850285829, 5), o = fnG(o, a, n, u, e[2], 4243563512, 9), u = fnG(u, o, a, n, e[7], 1735328473, 14), n = fnG(n, u, o, a, e[12], 2368359562, 20), a = fnH(a, n, u, o, e[5], 4294588738, 4), o = fnH(o, a, n, u, e[8], 2272392833, 11), u = fnH(u, o, a, n, e[11], 1839030562, 16), n = fnH(n, u, o, a, e[14], 4259657740, 23), a = fnH(a, n, u, o, e[1], 2763975236, 4), o = fnH(o, a, n, u, e[4], 1272893353, 11), u = fnH(u, o, a, n, e[7], 4139469664, 16), n = fnH(n, u, o, a, e[10], 3200236656, 23), a = fnH(a, n, u, o, e[13], 681279174, 4), o = fnH(o, a, n, u, e[0], 3936430074, 11), u = fnH(u, o, a, n, e[3], 3572445317, 16), n = fnH(n, u, o, a, e[6], 76029189, 23), a = fnH(a, n, u, o, e[9], 3654602809, 4), o = fnH(o, a, n, u, e[12], 3873151461, 11), u = fnH(u, o, a, n, e[15], 530742520, 16), n = fnH(n, u, o, a, e[2], 3299628645, 23), a = fnI(a, n, u, o, e[0], 4096336452, 6), o = fnI(o, a, n, u, e[7], 1126891415, 10), u = fnI(u, o, a, n, e[14], 2878612391, 15), n = fnI(n, u, o, a, e[5], 4237533241, 21), a = fnI(a, n, u, o, e[12], 1700485571, 6), o = fnI(o, a, n, u, e[3], 2399980690, 10), u = fnI(u, o, a, n, e[10], 4293915773, 15), n = fnI(n, u, o, a, e[1], 2240044497, 21), a = fnI(a, n, u, o, e[8], 1873313359, 6), o = fnI(o, a, n, u, e[15], 4264355552, 10), u = fnI(u, o, a, n, e[6], 2734768916, 15), n = fnI(n, u, o, a, e[13], 1309151649, 21), a = fnI(a, n, u, o, e[4], 4149444226, 6), o = fnI(o, a, n, u, e[11], 3174756917, 10), u = fnI(u, o, a, n, e[2], 718787259, 15), n = fnI(n, u, o, a, e[9], 3951481745, 21), this._a = this._a + a | 0, this._b = this._b + n | 0, this._c = this._c + u | 0, this._d = this._d + o | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = Buffer$y.allocUnsafe(16);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e;
};
function rotl$1(e, t) {
  return e << t | e >>> 32 - t;
}
function fnF(e, t, a, n, u, o, l) {
  return rotl$1(e + (t & a | ~t & n) + u + o | 0, l) + t | 0;
}
function fnG(e, t, a, n, u, o, l) {
  return rotl$1(e + (t & n | a & ~n) + u + o | 0, l) + t | 0;
}
function fnH(e, t, a, n, u, o, l) {
  return rotl$1(e + (t ^ a ^ n) + u + o | 0, l) + t | 0;
}
function fnI(e, t, a, n, u, o, l) {
  return rotl$1(e + (a ^ (t | ~n)) + u + o | 0, l) + t | 0;
}
var md5_js = MD5$3, Buffer$x = buffer$1.Buffer, inherits$o = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function rotl(e, t) {
  return e << t | e >>> 32 - t;
}
function fn1(e, t, a, n, u, o, l, h) {
  return rotl(e + (t ^ a ^ n) + o + l | 0, h) + u | 0;
}
function fn2(e, t, a, n, u, o, l, h) {
  return rotl(e + (t & a | ~t & n) + o + l | 0, h) + u | 0;
}
function fn3(e, t, a, n, u, o, l, h) {
  return rotl(e + ((t | ~a) ^ n) + o + l | 0, h) + u | 0;
}
function fn4(e, t, a, n, u, o, l, h) {
  return rotl(e + (t & n | a & ~n) + o + l | 0, h) + u | 0;
}
function fn5(e, t, a, n, u, o, l, h) {
  return rotl(e + (t ^ (a | ~n)) + o + l | 0, h) + u | 0;
}
function RIPEMD160$4() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$o(RIPEMD160$4, HashBase);
RIPEMD160$4.prototype._update = function() {
  for (var e = ARRAY16, t = 0; t < 16; ++t)
    e[t] = this._block.readInt32LE(t * 4);
  for (var a = this._a | 0, n = this._b | 0, u = this._c | 0, o = this._d | 0, l = this._e | 0, h = this._a | 0, y = this._b | 0, _ = this._c | 0, d = this._d | 0, $ = this._e | 0, N = 0; N < 80; N += 1) {
    var U, V;
    N < 16 ? (U = fn1(a, n, u, o, l, e[zl[N]], hl[0], sl[N]), V = fn5(h, y, _, d, $, e[zr[N]], hr[0], sr[N])) : N < 32 ? (U = fn2(a, n, u, o, l, e[zl[N]], hl[1], sl[N]), V = fn4(h, y, _, d, $, e[zr[N]], hr[1], sr[N])) : N < 48 ? (U = fn3(a, n, u, o, l, e[zl[N]], hl[2], sl[N]), V = fn3(h, y, _, d, $, e[zr[N]], hr[2], sr[N])) : N < 64 ? (U = fn4(a, n, u, o, l, e[zl[N]], hl[3], sl[N]), V = fn2(h, y, _, d, $, e[zr[N]], hr[3], sr[N])) : (U = fn5(a, n, u, o, l, e[zl[N]], hl[4], sl[N]), V = fn1(h, y, _, d, $, e[zr[N]], hr[4], sr[N])), a = l, l = o, o = rotl(u, 10), u = n, n = U, h = $, $ = d, d = rotl(_, 10), _ = y, y = V;
  }
  var Q = this._b + u + d | 0;
  this._b = this._c + o + $ | 0, this._c = this._d + l + h | 0, this._d = this._e + a + y | 0, this._e = this._a + n + _ | 0, this._a = Q;
};
RIPEMD160$4.prototype._digest = function() {
  this._block[this._blockOffset] = 128, this._blockOffset += 1, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = Buffer$x.alloc ? Buffer$x.alloc(20) : new Buffer$x(20);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e.writeInt32LE(this._e, 16), e;
};
var ripemd160 = RIPEMD160$4, sha_js = { exports: {} }, Buffer$w = safeBufferExports$2.Buffer, toBuffer$4 = toBuffer$7;
function Hash$7(e, t) {
  this._block = Buffer$w.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0;
}
Hash$7.prototype.update = function(e, t) {
  e = toBuffer$4(e, t || "utf8");
  for (var a = this._block, n = this._blockSize, u = e.length, o = this._len, l = 0; l < u; ) {
    for (var h = o % n, y = Math.min(u - l, n - h), _ = 0; _ < y; _++)
      a[h + _] = e[l + _];
    o += y, l += y, o % n === 0 && this._update(a);
  }
  return this._len += u, this;
};
Hash$7.prototype.digest = function(e) {
  var t = this._len % this._blockSize;
  this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var a = this._len * 8;
  if (a <= 4294967295)
    this._block.writeUInt32BE(a, this._blockSize - 4);
  else {
    var n = (a & 4294967295) >>> 0, u = (a - n) / 4294967296;
    this._block.writeUInt32BE(u, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
  }
  this._update(this._block);
  var o = this._hash();
  return e ? o.toString(e) : o;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$4 = Hash$7, inherits$n = inherits_browserExports, Hash$6 = hash$4, Buffer$v = safeBufferExports$2.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$n(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(e) {
  return e << 5 | e >>> 27;
}
function rotl30$1(e) {
  return e << 30 | e >>> 2;
}
function ft$1(e, t, a, n) {
  return e === 0 ? t & a | ~t & n : e === 2 ? t & a | t & n | a & n : t ^ a ^ n;
}
Sha.prototype._update = function(e) {
  for (var t = this._w, a = this._a | 0, n = this._b | 0, u = this._c | 0, o = this._d | 0, l = this._e | 0, h = 0; h < 16; ++h)
    t[h] = e.readInt32BE(h * 4);
  for (; h < 80; ++h)
    t[h] = t[h - 3] ^ t[h - 8] ^ t[h - 14] ^ t[h - 16];
  for (var y = 0; y < 80; ++y) {
    var _ = ~~(y / 20), d = rotl5$1(a) + ft$1(_, n, u, o) + l + t[y] + K$4[_] | 0;
    l = o, o = u, u = rotl30$1(n), n = a, a = d;
  }
  this._a = a + this._a | 0, this._b = n + this._b | 0, this._c = u + this._c | 0, this._d = o + this._d | 0, this._e = l + this._e | 0;
};
Sha.prototype._hash = function() {
  var e = Buffer$v.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var sha$4 = Sha, inherits$m = inherits_browserExports, Hash$5 = hash$4, Buffer$u = safeBufferExports$2.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$m(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(e) {
  return e << 1 | e >>> 31;
}
function rotl5(e) {
  return e << 5 | e >>> 27;
}
function rotl30(e) {
  return e << 30 | e >>> 2;
}
function ft(e, t, a, n) {
  return e === 0 ? t & a | ~t & n : e === 2 ? t & a | t & n | a & n : t ^ a ^ n;
}
Sha1.prototype._update = function(e) {
  for (var t = this._w, a = this._a | 0, n = this._b | 0, u = this._c | 0, o = this._d | 0, l = this._e | 0, h = 0; h < 16; ++h)
    t[h] = e.readInt32BE(h * 4);
  for (; h < 80; ++h)
    t[h] = rotl1(t[h - 3] ^ t[h - 8] ^ t[h - 14] ^ t[h - 16]);
  for (var y = 0; y < 80; ++y) {
    var _ = ~~(y / 20), d = rotl5(a) + ft(_, n, u, o) + l + t[y] + K$3[_] | 0;
    l = o, o = u, u = rotl30(n), n = a, a = d;
  }
  this._a = a + this._a | 0, this._b = n + this._b | 0, this._c = u + this._c | 0, this._d = o + this._d | 0, this._e = l + this._e | 0;
};
Sha1.prototype._hash = function() {
  var e = Buffer$u.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var sha1$1 = Sha1, inherits$l = inherits_browserExports, Hash$4 = hash$4, Buffer$t = safeBufferExports$2.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$l(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(e, t, a) {
  return a ^ e & (t ^ a);
}
function maj$1(e, t, a) {
  return e & t | a & (e | t);
}
function sigma0$1(e) {
  return (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10);
}
function sigma1$1(e) {
  return (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
}
function gamma0(e) {
  return (e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3;
}
function gamma1(e) {
  return (e >>> 17 | e << 15) ^ (e >>> 19 | e << 13) ^ e >>> 10;
}
Sha256$1.prototype._update = function(e) {
  for (var t = this._w, a = this._a | 0, n = this._b | 0, u = this._c | 0, o = this._d | 0, l = this._e | 0, h = this._f | 0, y = this._g | 0, _ = this._h | 0, d = 0; d < 16; ++d)
    t[d] = e.readInt32BE(d * 4);
  for (; d < 64; ++d)
    t[d] = gamma1(t[d - 2]) + t[d - 7] + gamma0(t[d - 15]) + t[d - 16] | 0;
  for (var $ = 0; $ < 64; ++$) {
    var N = _ + sigma1$1(l) + ch(l, h, y) + K$2[$] + t[$] | 0, U = sigma0$1(a) + maj$1(a, n, u) | 0;
    _ = y, y = h, h = l, l = o + N | 0, o = u, u = n, n = a, a = N + U | 0;
  }
  this._a = a + this._a | 0, this._b = n + this._b | 0, this._c = u + this._c | 0, this._d = o + this._d | 0, this._e = l + this._e | 0, this._f = h + this._f | 0, this._g = y + this._g | 0, this._h = _ + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var e = Buffer$t.allocUnsafe(32);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e.writeInt32BE(this._h, 28), e;
};
var sha256$2 = Sha256$1, inherits$k = inherits_browserExports, Sha256 = sha256$2, Hash$3 = hash$4, Buffer$s = safeBufferExports$2.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$k(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var e = Buffer$s.allocUnsafe(28);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e;
};
var sha224$1 = Sha224, inherits$j = inherits_browserExports, Hash$2 = hash$4, Buffer$r = safeBufferExports$2.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$j(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(e, t, a) {
  return a ^ e & (t ^ a);
}
function maj(e, t, a) {
  return e & t | a & (e | t);
}
function sigma0(e, t) {
  return (e >>> 28 | t << 4) ^ (t >>> 2 | e << 30) ^ (t >>> 7 | e << 25);
}
function sigma1(e, t) {
  return (e >>> 14 | t << 18) ^ (e >>> 18 | t << 14) ^ (t >>> 9 | e << 23);
}
function Gamma0(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ e >>> 7;
}
function Gamma0l(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ (e >>> 7 | t << 25);
}
function Gamma1(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ e >>> 6;
}
function Gamma1l(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ (e >>> 6 | t << 26);
}
function getCarry(e, t) {
  return e >>> 0 < t >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(e) {
  for (var t = this._w, a = this._ah | 0, n = this._bh | 0, u = this._ch | 0, o = this._dh | 0, l = this._eh | 0, h = this._fh | 0, y = this._gh | 0, _ = this._hh | 0, d = this._al | 0, $ = this._bl | 0, N = this._cl | 0, U = this._dl | 0, V = this._el | 0, Q = this._fl | 0, ie = this._gl | 0, ee = this._hl | 0, ne = 0; ne < 32; ne += 2)
    t[ne] = e.readInt32BE(ne * 4), t[ne + 1] = e.readInt32BE(ne * 4 + 4);
  for (; ne < 160; ne += 2) {
    var ge = t[ne - 30], be = t[ne - 15 * 2 + 1], Ee = Gamma0(ge, be), xe = Gamma0l(be, ge);
    ge = t[ne - 2 * 2], be = t[ne - 2 * 2 + 1];
    var Le = Gamma1(ge, be), Ne = Gamma1l(be, ge), Re = t[ne - 7 * 2], Xe = t[ne - 7 * 2 + 1], pe = t[ne - 16 * 2], O = t[ne - 16 * 2 + 1], E = xe + Xe | 0, c = Ee + Re + getCarry(E, xe) | 0;
    E = E + Ne | 0, c = c + Le + getCarry(E, Ne) | 0, E = E + O | 0, c = c + pe + getCarry(E, O) | 0, t[ne] = c, t[ne + 1] = E;
  }
  for (var b = 0; b < 160; b += 2) {
    c = t[b], E = t[b + 1];
    var C = maj(a, n, u), x = maj(d, $, N), B = sigma0(a, d), k = sigma0(d, a), w = sigma1(l, V), T = sigma1(V, l), p = K$1[b], F = K$1[b + 1], ye = Ch(l, h, y), _e = Ch(V, Q, ie), de = ee + T | 0, P = _ + w + getCarry(de, ee) | 0;
    de = de + _e | 0, P = P + ye + getCarry(de, _e) | 0, de = de + F | 0, P = P + p + getCarry(de, F) | 0, de = de + E | 0, P = P + c + getCarry(de, E) | 0;
    var H = k + x | 0, he = B + C + getCarry(H, k) | 0;
    _ = y, ee = ie, y = h, ie = Q, h = l, Q = V, V = U + de | 0, l = o + P + getCarry(V, U) | 0, o = u, U = N, u = n, N = $, n = a, $ = d, d = de + H | 0, a = P + he + getCarry(d, de) | 0;
  }
  this._al = this._al + d | 0, this._bl = this._bl + $ | 0, this._cl = this._cl + N | 0, this._dl = this._dl + U | 0, this._el = this._el + V | 0, this._fl = this._fl + Q | 0, this._gl = this._gl + ie | 0, this._hl = this._hl + ee | 0, this._ah = this._ah + a + getCarry(this._al, d) | 0, this._bh = this._bh + n + getCarry(this._bl, $) | 0, this._ch = this._ch + u + getCarry(this._cl, N) | 0, this._dh = this._dh + o + getCarry(this._dl, U) | 0, this._eh = this._eh + l + getCarry(this._el, V) | 0, this._fh = this._fh + h + getCarry(this._fl, Q) | 0, this._gh = this._gh + y + getCarry(this._gl, ie) | 0, this._hh = this._hh + _ + getCarry(this._hl, ee) | 0;
};
Sha512.prototype._hash = function() {
  var e = Buffer$r.allocUnsafe(64);
  function t(a, n, u) {
    e.writeInt32BE(a, u), e.writeInt32BE(n, u + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), e;
};
var sha512$3 = Sha512, inherits$i = inherits_browserExports, SHA512$2 = sha512$3, Hash$1 = hash$4, Buffer$q = safeBufferExports$2.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$i(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var e = Buffer$q.allocUnsafe(48);
  function t(a, n, u) {
    e.writeInt32BE(a, u), e.writeInt32BE(n, u + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), e;
};
var sha384$2 = Sha384;
(function(e) {
  e.exports = function(a) {
    var n = a.toLowerCase(), u = e.exports[n];
    if (!u)
      throw new Error(n + " is not supported (we accept pull requests)");
    return new u();
  }, e.exports.sha = sha$4, e.exports.sha1 = sha1$1, e.exports.sha224 = sha224$1, e.exports.sha256 = sha256$2, e.exports.sha384 = sha384$2, e.exports.sha512 = sha512$3;
})(sha_js);
var sha_jsExports = sha_js.exports, streamBrowser$1, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function e(V, Q) {
    var ie = Object.keys(V);
    if (Object.getOwnPropertySymbols) {
      var ee = Object.getOwnPropertySymbols(V);
      Q && (ee = ee.filter(function(ne) {
        return Object.getOwnPropertyDescriptor(V, ne).enumerable;
      })), ie.push.apply(ie, ee);
    }
    return ie;
  }
  function t(V) {
    for (var Q = 1; Q < arguments.length; Q++) {
      var ie = arguments[Q] != null ? arguments[Q] : {};
      Q % 2 ? e(Object(ie), !0).forEach(function(ee) {
        a(V, ee, ie[ee]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(V, Object.getOwnPropertyDescriptors(ie)) : e(Object(ie)).forEach(function(ee) {
        Object.defineProperty(V, ee, Object.getOwnPropertyDescriptor(ie, ee));
      });
    }
    return V;
  }
  function a(V, Q, ie) {
    return Q = l(Q), Q in V ? Object.defineProperty(V, Q, { value: ie, enumerable: !0, configurable: !0, writable: !0 }) : V[Q] = ie, V;
  }
  function n(V, Q) {
    if (!(V instanceof Q))
      throw new TypeError("Cannot call a class as a function");
  }
  function u(V, Q) {
    for (var ie = 0; ie < Q.length; ie++) {
      var ee = Q[ie];
      ee.enumerable = ee.enumerable || !1, ee.configurable = !0, "value" in ee && (ee.writable = !0), Object.defineProperty(V, l(ee.key), ee);
    }
  }
  function o(V, Q, ie) {
    return Q && u(V.prototype, Q), ie && u(V, ie), Object.defineProperty(V, "prototype", { writable: !1 }), V;
  }
  function l(V) {
    var Q = h(V, "string");
    return typeof Q == "symbol" ? Q : String(Q);
  }
  function h(V, Q) {
    if (typeof V != "object" || V === null)
      return V;
    var ie = V[Symbol.toPrimitive];
    if (ie !== void 0) {
      var ee = ie.call(V, Q || "default");
      if (typeof ee != "object")
        return ee;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Q === "string" ? String : Number)(V);
  }
  var y = buffer$1, _ = y.Buffer, d = util$9, $ = d.inspect, N = $ && $.custom || "inspect";
  function U(V, Q, ie) {
    _.prototype.copy.call(V, Q, ie);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function V() {
      n(this, V), this.head = null, this.tail = null, this.length = 0;
    }
    return o(V, [{
      key: "push",
      value: function(ie) {
        var ee = {
          data: ie,
          next: null
        };
        this.length > 0 ? this.tail.next = ee : this.head = ee, this.tail = ee, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ie) {
        var ee = {
          data: ie,
          next: this.head
        };
        this.length === 0 && (this.tail = ee), this.head = ee, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ie = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ie;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ie) {
        if (this.length === 0)
          return "";
        for (var ee = this.head, ne = "" + ee.data; ee = ee.next; )
          ne += ie + ee.data;
        return ne;
      }
    }, {
      key: "concat",
      value: function(ie) {
        if (this.length === 0)
          return _.alloc(0);
        for (var ee = _.allocUnsafe(ie >>> 0), ne = this.head, ge = 0; ne; )
          U(ne.data, ee, ge), ge += ne.data.length, ne = ne.next;
        return ee;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ie, ee) {
        var ne;
        return ie < this.head.data.length ? (ne = this.head.data.slice(0, ie), this.head.data = this.head.data.slice(ie)) : ie === this.head.data.length ? ne = this.shift() : ne = ee ? this._getString(ie) : this._getBuffer(ie), ne;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ie) {
        var ee = this.head, ne = 1, ge = ee.data;
        for (ie -= ge.length; ee = ee.next; ) {
          var be = ee.data, Ee = ie > be.length ? be.length : ie;
          if (Ee === be.length ? ge += be : ge += be.slice(0, ie), ie -= Ee, ie === 0) {
            Ee === be.length ? (++ne, ee.next ? this.head = ee.next : this.head = this.tail = null) : (this.head = ee, ee.data = be.slice(Ee));
            break;
          }
          ++ne;
        }
        return this.length -= ne, ge;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ie) {
        var ee = _.allocUnsafe(ie), ne = this.head, ge = 1;
        for (ne.data.copy(ee), ie -= ne.data.length; ne = ne.next; ) {
          var be = ne.data, Ee = ie > be.length ? be.length : ie;
          if (be.copy(ee, ee.length - ie, 0, Ee), ie -= Ee, ie === 0) {
            Ee === be.length ? (++ge, ne.next ? this.head = ne.next : this.head = this.tail = null) : (this.head = ne, ne.data = be.slice(Ee));
            break;
          }
          ++ge;
        }
        return this.length -= ge, ee;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: N,
      value: function(ie, ee) {
        return $(this, t(t({}, ee), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), V;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1$1;
  hasRequiredDestroy = 1;
  function e(l, h) {
    var y = this, _ = this._readableState && this._readableState.destroyed, d = this._writableState && this._writableState.destroyed;
    return _ || d ? (h ? h(l) : l && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, api$2.nextTick(u, this, l)) : api$2.nextTick(u, this, l)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(l || null, function($) {
      !h && $ ? y._writableState ? y._writableState.errorEmitted ? api$2.nextTick(a, y) : (y._writableState.errorEmitted = !0, api$2.nextTick(t, y, $)) : api$2.nextTick(t, y, $) : h ? (api$2.nextTick(a, y), h($)) : api$2.nextTick(a, y);
    }), this);
  }
  function t(l, h) {
    u(l, h), a(l);
  }
  function a(l) {
    l._writableState && !l._writableState.emitClose || l._readableState && !l._readableState.emitClose || l.emit("close");
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function u(l, h) {
    l.emit("error", h);
  }
  function o(l, h) {
    var y = l._readableState, _ = l._writableState;
    y && y.autoDestroy || _ && _.autoDestroy ? l.destroy(h) : l.emit("error", h);
  }
  return destroy_1$1 = {
    destroy: e,
    undestroy: n,
    errorOrDestroy: o
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser)
    return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function e(h, y) {
    h.prototype = Object.create(y.prototype), h.prototype.constructor = h, h.__proto__ = y;
  }
  var t = {};
  function a(h, y, _) {
    _ || (_ = Error);
    function d(N, U, V) {
      return typeof y == "string" ? y : y(N, U, V);
    }
    var $ = /* @__PURE__ */ function(N) {
      e(U, N);
      function U(V, Q, ie) {
        return N.call(this, d(V, Q, ie)) || this;
      }
      return U;
    }(_);
    $.prototype.name = _.name, $.prototype.code = h, t[h] = $;
  }
  function n(h, y) {
    if (Array.isArray(h)) {
      var _ = h.length;
      return h = h.map(function(d) {
        return String(d);
      }), _ > 2 ? "one of ".concat(y, " ").concat(h.slice(0, _ - 1).join(", "), ", or ") + h[_ - 1] : _ === 2 ? "one of ".concat(y, " ").concat(h[0], " or ").concat(h[1]) : "of ".concat(y, " ").concat(h[0]);
    } else
      return "of ".concat(y, " ").concat(String(h));
  }
  function u(h, y, _) {
    return h.substr(!_ || _ < 0 ? 0 : +_, y.length) === y;
  }
  function o(h, y, _) {
    return (_ === void 0 || _ > h.length) && (_ = h.length), h.substring(_ - y.length, _) === y;
  }
  function l(h, y, _) {
    return typeof _ != "number" && (_ = 0), _ + y.length > h.length ? !1 : h.indexOf(y, _) !== -1;
  }
  return a("ERR_INVALID_OPT_VALUE", function(h, y) {
    return 'The value "' + y + '" is invalid for option "' + h + '"';
  }, TypeError), a("ERR_INVALID_ARG_TYPE", function(h, y, _) {
    var d;
    typeof y == "string" && u(y, "not ") ? (d = "must not be", y = y.replace(/^not /, "")) : d = "must be";
    var $;
    if (o(h, " argument"))
      $ = "The ".concat(h, " ").concat(d, " ").concat(n(y, "type"));
    else {
      var N = l(h, ".") ? "property" : "argument";
      $ = 'The "'.concat(h, '" ').concat(N, " ").concat(d, " ").concat(n(y, "type"));
    }
    return $ += ". Received type ".concat(typeof _), $;
  }, TypeError), a("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), a("ERR_METHOD_NOT_IMPLEMENTED", function(h) {
    return "The " + h + " method is not implemented";
  }), a("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), a("ERR_STREAM_DESTROYED", function(h) {
    return "Cannot call " + h + " after a stream was destroyed";
  }), a("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), a("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), a("ERR_STREAM_WRITE_AFTER_END", "write after end"), a("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), a("ERR_UNKNOWN_ENCODING", function(h) {
    return "Unknown encoding: " + h;
  }, TypeError), a("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = t, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state;
  hasRequiredState = 1;
  var e = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function t(n, u, o) {
    return n.highWaterMark != null ? n.highWaterMark : u ? n[o] : null;
  }
  function a(n, u, o, l) {
    var h = t(u, l, o);
    if (h != null) {
      if (!(isFinite(h) && Math.floor(h) === h) || h < 0) {
        var y = l ? o : "highWaterMark";
        throw new e(y, h);
      }
      return Math.floor(h);
    }
    return n.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: a
  }, state;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1)
    return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Ne;
  function e(de) {
    var P = this;
    this.next = null, this.entry = null, this.finish = function() {
      _e(P, de);
    };
  }
  var t;
  Ne.WritableState = xe;
  var a = {
    deprecate: browser$a
  }, n = requireStreamBrowser(), u = buffer$1.Buffer, o = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function l(de) {
    return u.from(de);
  }
  function h(de) {
    return u.isBuffer(de) || de instanceof o;
  }
  var y = requireDestroy(), _ = requireState(), d = _.getHighWaterMark, $ = requireErrorsBrowser().codes, N = $.ERR_INVALID_ARG_TYPE, U = $.ERR_METHOD_NOT_IMPLEMENTED, V = $.ERR_MULTIPLE_CALLBACK, Q = $.ERR_STREAM_CANNOT_PIPE, ie = $.ERR_STREAM_DESTROYED, ee = $.ERR_STREAM_NULL_VALUES, ne = $.ERR_STREAM_WRITE_AFTER_END, ge = $.ERR_UNKNOWN_ENCODING, be = y.errorOrDestroy;
  inherits_browserExports(Ne, n);
  function Ee() {
  }
  function xe(de, P, H) {
    t = t || require_stream_duplex$1(), de = de || {}, typeof H != "boolean" && (H = P instanceof t), this.objectMode = !!de.objectMode, H && (this.objectMode = this.objectMode || !!de.writableObjectMode), this.highWaterMark = d(this, de, "writableHighWaterMark", H), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var he = de.decodeStrings === !1;
    this.decodeStrings = !he, this.defaultEncoding = de.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(me) {
      C(P, me);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = de.emitClose !== !1, this.autoDestroy = !!de.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  xe.prototype.getBuffer = function() {
    for (var P = this.bufferedRequest, H = []; P; )
      H.push(P), P = P.next;
    return H;
  }, function() {
    try {
      Object.defineProperty(xe.prototype, "buffer", {
        get: a.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Le;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Le = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ne, Symbol.hasInstance, {
    value: function(P) {
      return Le.call(this, P) ? !0 : this !== Ne ? !1 : P && P._writableState instanceof xe;
    }
  })) : Le = function(P) {
    return P instanceof this;
  };
  function Ne(de) {
    t = t || require_stream_duplex$1();
    var P = this instanceof t;
    if (!P && !Le.call(Ne, this))
      return new Ne(de);
    this._writableState = new xe(de, this, P), this.writable = !0, de && (typeof de.write == "function" && (this._write = de.write), typeof de.writev == "function" && (this._writev = de.writev), typeof de.destroy == "function" && (this._destroy = de.destroy), typeof de.final == "function" && (this._final = de.final)), n.call(this);
  }
  Ne.prototype.pipe = function() {
    be(this, new Q());
  };
  function Re(de, P) {
    var H = new ne();
    be(de, H), api$2.nextTick(P, H);
  }
  function Xe(de, P, H, he) {
    var me;
    return H === null ? me = new ee() : typeof H != "string" && !P.objectMode && (me = new N("chunk", ["string", "Buffer"], H)), me ? (be(de, me), api$2.nextTick(he, me), !1) : !0;
  }
  Ne.prototype.write = function(de, P, H) {
    var he = this._writableState, me = !1, fe = !he.objectMode && h(de);
    return fe && !u.isBuffer(de) && (de = l(de)), typeof P == "function" && (H = P, P = null), fe ? P = "buffer" : P || (P = he.defaultEncoding), typeof H != "function" && (H = Ee), he.ending ? Re(this, H) : (fe || Xe(this, he, de, H)) && (he.pendingcb++, me = O(this, he, fe, de, P, H)), me;
  }, Ne.prototype.cork = function() {
    this._writableState.corked++;
  }, Ne.prototype.uncork = function() {
    var de = this._writableState;
    de.corked && (de.corked--, !de.writing && !de.corked && !de.bufferProcessing && de.bufferedRequest && k(this, de));
  }, Ne.prototype.setDefaultEncoding = function(P) {
    if (typeof P == "string" && (P = P.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((P + "").toLowerCase()) > -1))
      throw new ge(P);
    return this._writableState.defaultEncoding = P, this;
  }, Object.defineProperty(Ne.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function pe(de, P, H) {
    return !de.objectMode && de.decodeStrings !== !1 && typeof P == "string" && (P = u.from(P, H)), P;
  }
  Object.defineProperty(Ne.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function O(de, P, H, he, me, fe) {
    if (!H) {
      var re = pe(P, he, me);
      he !== re && (H = !0, me = "buffer", he = re);
    }
    var we = P.objectMode ? 1 : he.length;
    P.length += we;
    var ke = P.length < P.highWaterMark;
    if (ke || (P.needDrain = !0), P.writing || P.corked) {
      var Oe = P.lastBufferedRequest;
      P.lastBufferedRequest = {
        chunk: he,
        encoding: me,
        isBuf: H,
        callback: fe,
        next: null
      }, Oe ? Oe.next = P.lastBufferedRequest : P.bufferedRequest = P.lastBufferedRequest, P.bufferedRequestCount += 1;
    } else
      E(de, P, !1, we, he, me, fe);
    return ke;
  }
  function E(de, P, H, he, me, fe, re) {
    P.writelen = he, P.writecb = re, P.writing = !0, P.sync = !0, P.destroyed ? P.onwrite(new ie("write")) : H ? de._writev(me, P.onwrite) : de._write(me, fe, P.onwrite), P.sync = !1;
  }
  function c(de, P, H, he, me) {
    --P.pendingcb, H ? (api$2.nextTick(me, he), api$2.nextTick(F, de, P), de._writableState.errorEmitted = !0, be(de, he)) : (me(he), de._writableState.errorEmitted = !0, be(de, he), F(de, P));
  }
  function b(de) {
    de.writing = !1, de.writecb = null, de.length -= de.writelen, de.writelen = 0;
  }
  function C(de, P) {
    var H = de._writableState, he = H.sync, me = H.writecb;
    if (typeof me != "function")
      throw new V();
    if (b(H), P)
      c(de, H, he, P, me);
    else {
      var fe = w(H) || de.destroyed;
      !fe && !H.corked && !H.bufferProcessing && H.bufferedRequest && k(de, H), he ? api$2.nextTick(x, de, H, fe, me) : x(de, H, fe, me);
    }
  }
  function x(de, P, H, he) {
    H || B(de, P), P.pendingcb--, he(), F(de, P);
  }
  function B(de, P) {
    P.length === 0 && P.needDrain && (P.needDrain = !1, de.emit("drain"));
  }
  function k(de, P) {
    P.bufferProcessing = !0;
    var H = P.bufferedRequest;
    if (de._writev && H && H.next) {
      var he = P.bufferedRequestCount, me = new Array(he), fe = P.corkedRequestsFree;
      fe.entry = H;
      for (var re = 0, we = !0; H; )
        me[re] = H, H.isBuf || (we = !1), H = H.next, re += 1;
      me.allBuffers = we, E(de, P, !0, P.length, me, "", fe.finish), P.pendingcb++, P.lastBufferedRequest = null, fe.next ? (P.corkedRequestsFree = fe.next, fe.next = null) : P.corkedRequestsFree = new e(P), P.bufferedRequestCount = 0;
    } else {
      for (; H; ) {
        var ke = H.chunk, Oe = H.encoding, ce = H.callback, j = P.objectMode ? 1 : ke.length;
        if (E(de, P, !1, j, ke, Oe, ce), H = H.next, P.bufferedRequestCount--, P.writing)
          break;
      }
      H === null && (P.lastBufferedRequest = null);
    }
    P.bufferedRequest = H, P.bufferProcessing = !1;
  }
  Ne.prototype._write = function(de, P, H) {
    H(new U("_write()"));
  }, Ne.prototype._writev = null, Ne.prototype.end = function(de, P, H) {
    var he = this._writableState;
    return typeof de == "function" ? (H = de, de = null, P = null) : typeof P == "function" && (H = P, P = null), de != null && this.write(de, P), he.corked && (he.corked = 1, this.uncork()), he.ending || ye(this, he, H), this;
  }, Object.defineProperty(Ne.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function w(de) {
    return de.ending && de.length === 0 && de.bufferedRequest === null && !de.finished && !de.writing;
  }
  function T(de, P) {
    de._final(function(H) {
      P.pendingcb--, H && be(de, H), P.prefinished = !0, de.emit("prefinish"), F(de, P);
    });
  }
  function p(de, P) {
    !P.prefinished && !P.finalCalled && (typeof de._final == "function" && !P.destroyed ? (P.pendingcb++, P.finalCalled = !0, api$2.nextTick(T, de, P)) : (P.prefinished = !0, de.emit("prefinish")));
  }
  function F(de, P) {
    var H = w(P);
    if (H && (p(de, P), P.pendingcb === 0 && (P.finished = !0, de.emit("finish"), P.autoDestroy))) {
      var he = de._readableState;
      (!he || he.autoDestroy && he.endEmitted) && de.destroy();
    }
    return H;
  }
  function ye(de, P, H) {
    P.ending = !0, F(de, P), H && (P.finished ? api$2.nextTick(H) : de.once("finish", H)), P.ended = !0, de.writable = !1;
  }
  function _e(de, P, H) {
    var he = de.entry;
    for (de.entry = null; he; ) {
      var me = he.callback;
      P.pendingcb--, me(H), he = he.next;
    }
    P.corkedRequestsFree.next = de;
  }
  return Object.defineProperty(Ne.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(P) {
      this._writableState && (this._writableState.destroyed = P);
    }
  }), Ne.prototype.destroy = y.destroy, Ne.prototype._undestroy = y.undestroy, Ne.prototype._destroy = function(de, P) {
    P(de);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1)
    return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var e = Object.keys || function(_) {
    var d = [];
    for (var $ in _)
      d.push($);
    return d;
  };
  _stream_duplex$1 = l;
  var t = require_stream_readable$1(), a = require_stream_writable$1();
  inherits_browserExports(l, t);
  for (var n = e(a.prototype), u = 0; u < n.length; u++) {
    var o = n[u];
    l.prototype[o] || (l.prototype[o] = a.prototype[o]);
  }
  function l(_) {
    if (!(this instanceof l))
      return new l(_);
    t.call(this, _), a.call(this, _), this.allowHalfOpen = !0, _ && (_.readable === !1 && (this.readable = !1), _.writable === !1 && (this.writable = !1), _.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", h)));
  }
  Object.defineProperty(l.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(l.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(l.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function h() {
    this._writableState.ended || api$2.nextTick(y, this);
  }
  function y(_) {
    _.end();
  }
  return Object.defineProperty(l.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(d) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = d, this._writableState.destroyed = d);
    }
  }), _stream_duplex$1;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream)
    return endOfStream;
  hasRequiredEndOfStream = 1;
  var e = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(o) {
    var l = !1;
    return function() {
      if (!l) {
        l = !0;
        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++)
          y[_] = arguments[_];
        o.apply(this, y);
      }
    };
  }
  function a() {
  }
  function n(o) {
    return o.setHeader && typeof o.abort == "function";
  }
  function u(o, l, h) {
    if (typeof l == "function")
      return u(o, null, l);
    l || (l = {}), h = t(h || a);
    var y = l.readable || l.readable !== !1 && o.readable, _ = l.writable || l.writable !== !1 && o.writable, d = function() {
      o.writable || N();
    }, $ = o._writableState && o._writableState.finished, N = function() {
      _ = !1, $ = !0, y || h.call(o);
    }, U = o._readableState && o._readableState.endEmitted, V = function() {
      y = !1, U = !0, _ || h.call(o);
    }, Q = function(ge) {
      h.call(o, ge);
    }, ie = function() {
      var ge;
      if (y && !U)
        return (!o._readableState || !o._readableState.ended) && (ge = new e()), h.call(o, ge);
      if (_ && !$)
        return (!o._writableState || !o._writableState.ended) && (ge = new e()), h.call(o, ge);
    }, ee = function() {
      o.req.on("finish", N);
    };
    return n(o) ? (o.on("complete", N), o.on("abort", ie), o.req ? ee() : o.on("request", ee)) : _ && !o._writableState && (o.on("end", d), o.on("close", d)), o.on("end", V), o.on("finish", N), l.error !== !1 && o.on("error", Q), o.on("close", ie), function() {
      o.removeListener("complete", N), o.removeListener("abort", ie), o.removeListener("request", ee), o.req && o.req.removeListener("finish", N), o.removeListener("end", d), o.removeListener("close", d), o.removeListener("finish", N), o.removeListener("end", V), o.removeListener("error", Q), o.removeListener("close", ie);
    };
  }
  return endOfStream = u, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var e;
  function t(ge, be, Ee) {
    return be = a(be), be in ge ? Object.defineProperty(ge, be, { value: Ee, enumerable: !0, configurable: !0, writable: !0 }) : ge[be] = Ee, ge;
  }
  function a(ge) {
    var be = n(ge, "string");
    return typeof be == "symbol" ? be : String(be);
  }
  function n(ge, be) {
    if (typeof ge != "object" || ge === null)
      return ge;
    var Ee = ge[Symbol.toPrimitive];
    if (Ee !== void 0) {
      var xe = Ee.call(ge, be || "default");
      if (typeof xe != "object")
        return xe;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (be === "string" ? String : Number)(ge);
  }
  var u = requireEndOfStream(), o = Symbol("lastResolve"), l = Symbol("lastReject"), h = Symbol("error"), y = Symbol("ended"), _ = Symbol("lastPromise"), d = Symbol("handlePromise"), $ = Symbol("stream");
  function N(ge, be) {
    return {
      value: ge,
      done: be
    };
  }
  function U(ge) {
    var be = ge[o];
    if (be !== null) {
      var Ee = ge[$].read();
      Ee !== null && (ge[_] = null, ge[o] = null, ge[l] = null, be(N(Ee, !1)));
    }
  }
  function V(ge) {
    api$2.nextTick(U, ge);
  }
  function Q(ge, be) {
    return function(Ee, xe) {
      ge.then(function() {
        if (be[y]) {
          Ee(N(void 0, !0));
          return;
        }
        be[d](Ee, xe);
      }, xe);
    };
  }
  var ie = Object.getPrototypeOf(function() {
  }), ee = Object.setPrototypeOf((e = {
    get stream() {
      return this[$];
    },
    next: function() {
      var be = this, Ee = this[h];
      if (Ee !== null)
        return Promise.reject(Ee);
      if (this[y])
        return Promise.resolve(N(void 0, !0));
      if (this[$].destroyed)
        return new Promise(function(Re, Xe) {
          api$2.nextTick(function() {
            be[h] ? Xe(be[h]) : Re(N(void 0, !0));
          });
        });
      var xe = this[_], Le;
      if (xe)
        Le = new Promise(Q(xe, this));
      else {
        var Ne = this[$].read();
        if (Ne !== null)
          return Promise.resolve(N(Ne, !1));
        Le = new Promise(this[d]);
      }
      return this[_] = Le, Le;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var be = this;
    return new Promise(function(Ee, xe) {
      be[$].destroy(null, function(Le) {
        if (Le) {
          xe(Le);
          return;
        }
        Ee(N(void 0, !0));
      });
    });
  }), e), ie), ne = function(be) {
    var Ee, xe = Object.create(ee, (Ee = {}, t(Ee, $, {
      value: be,
      writable: !0
    }), t(Ee, o, {
      value: null,
      writable: !0
    }), t(Ee, l, {
      value: null,
      writable: !0
    }), t(Ee, h, {
      value: null,
      writable: !0
    }), t(Ee, y, {
      value: be._readableState.endEmitted,
      writable: !0
    }), t(Ee, d, {
      value: function(Ne, Re) {
        var Xe = xe[$].read();
        Xe ? (xe[_] = null, xe[o] = null, xe[l] = null, Ne(N(Xe, !1))) : (xe[o] = Ne, xe[l] = Re);
      },
      writable: !0
    }), Ee));
    return xe[_] = null, u(be, function(Le) {
      if (Le && Le.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Ne = xe[l];
        Ne !== null && (xe[_] = null, xe[o] = null, xe[l] = null, Ne(Le)), xe[h] = Le;
        return;
      }
      var Re = xe[o];
      Re !== null && (xe[_] = null, xe[o] = null, xe[l] = null, Re(N(void 0, !0))), xe[y] = !0;
    }), be.on("readable", V.bind(null, xe)), xe;
  };
  return async_iterator = ne, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1)
    return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Re;
  var e;
  Re.ReadableState = Ne, eventsExports.EventEmitter;
  var t = function(re, we) {
    return re.listeners(we).length;
  }, a = requireStreamBrowser(), n = buffer$1.Buffer, u = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(fe) {
    return n.from(fe);
  }
  function l(fe) {
    return n.isBuffer(fe) || fe instanceof u;
  }
  var h = util$9, y;
  h && h.debuglog ? y = h.debuglog("stream") : y = function() {
  };
  var _ = requireBuffer_list(), d = requireDestroy(), $ = requireState(), N = $.getHighWaterMark, U = requireErrorsBrowser().codes, V = U.ERR_INVALID_ARG_TYPE, Q = U.ERR_STREAM_PUSH_AFTER_EOF, ie = U.ERR_METHOD_NOT_IMPLEMENTED, ee = U.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ne, ge, be;
  inherits_browserExports(Re, a);
  var Ee = d.errorOrDestroy, xe = ["error", "close", "destroy", "pause", "resume"];
  function Le(fe, re, we) {
    if (typeof fe.prependListener == "function")
      return fe.prependListener(re, we);
    !fe._events || !fe._events[re] ? fe.on(re, we) : Array.isArray(fe._events[re]) ? fe._events[re].unshift(we) : fe._events[re] = [we, fe._events[re]];
  }
  function Ne(fe, re, we) {
    e = e || require_stream_duplex$1(), fe = fe || {}, typeof we != "boolean" && (we = re instanceof e), this.objectMode = !!fe.objectMode, we && (this.objectMode = this.objectMode || !!fe.readableObjectMode), this.highWaterMark = N(this, fe, "readableHighWaterMark", we), this.buffer = new _(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = fe.emitClose !== !1, this.autoDestroy = !!fe.autoDestroy, this.destroyed = !1, this.defaultEncoding = fe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, fe.encoding && (ne || (ne = string_decoder.StringDecoder), this.decoder = new ne(fe.encoding), this.encoding = fe.encoding);
  }
  function Re(fe) {
    if (e = e || require_stream_duplex$1(), !(this instanceof Re))
      return new Re(fe);
    var re = this instanceof e;
    this._readableState = new Ne(fe, this, re), this.readable = !0, fe && (typeof fe.read == "function" && (this._read = fe.read), typeof fe.destroy == "function" && (this._destroy = fe.destroy)), a.call(this);
  }
  Object.defineProperty(Re.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(re) {
      this._readableState && (this._readableState.destroyed = re);
    }
  }), Re.prototype.destroy = d.destroy, Re.prototype._undestroy = d.undestroy, Re.prototype._destroy = function(fe, re) {
    re(fe);
  }, Re.prototype.push = function(fe, re) {
    var we = this._readableState, ke;
    return we.objectMode ? ke = !0 : typeof fe == "string" && (re = re || we.defaultEncoding, re !== we.encoding && (fe = n.from(fe, re), re = ""), ke = !0), Xe(this, fe, re, !1, ke);
  }, Re.prototype.unshift = function(fe) {
    return Xe(this, fe, null, !0, !1);
  };
  function Xe(fe, re, we, ke, Oe) {
    y("readableAddChunk", re);
    var ce = fe._readableState;
    if (re === null)
      ce.reading = !1, C(fe, ce);
    else {
      var j;
      if (Oe || (j = O(ce, re)), j)
        Ee(fe, j);
      else if (ce.objectMode || re && re.length > 0)
        if (typeof re != "string" && !ce.objectMode && Object.getPrototypeOf(re) !== n.prototype && (re = o(re)), ke)
          ce.endEmitted ? Ee(fe, new ee()) : pe(fe, ce, re, !0);
        else if (ce.ended)
          Ee(fe, new Q());
        else {
          if (ce.destroyed)
            return !1;
          ce.reading = !1, ce.decoder && !we ? (re = ce.decoder.write(re), ce.objectMode || re.length !== 0 ? pe(fe, ce, re, !1) : k(fe, ce)) : pe(fe, ce, re, !1);
        }
      else
        ke || (ce.reading = !1, k(fe, ce));
    }
    return !ce.ended && (ce.length < ce.highWaterMark || ce.length === 0);
  }
  function pe(fe, re, we, ke) {
    re.flowing && re.length === 0 && !re.sync ? (re.awaitDrain = 0, fe.emit("data", we)) : (re.length += re.objectMode ? 1 : we.length, ke ? re.buffer.unshift(we) : re.buffer.push(we), re.needReadable && x(fe)), k(fe, re);
  }
  function O(fe, re) {
    var we;
    return !l(re) && typeof re != "string" && re !== void 0 && !fe.objectMode && (we = new V("chunk", ["string", "Buffer", "Uint8Array"], re)), we;
  }
  Re.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Re.prototype.setEncoding = function(fe) {
    ne || (ne = string_decoder.StringDecoder);
    var re = new ne(fe);
    this._readableState.decoder = re, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var we = this._readableState.buffer.head, ke = ""; we !== null; )
      ke += re.write(we.data), we = we.next;
    return this._readableState.buffer.clear(), ke !== "" && this._readableState.buffer.push(ke), this._readableState.length = ke.length, this;
  };
  var E = 1073741824;
  function c(fe) {
    return fe >= E ? fe = E : (fe--, fe |= fe >>> 1, fe |= fe >>> 2, fe |= fe >>> 4, fe |= fe >>> 8, fe |= fe >>> 16, fe++), fe;
  }
  function b(fe, re) {
    return fe <= 0 || re.length === 0 && re.ended ? 0 : re.objectMode ? 1 : fe !== fe ? re.flowing && re.length ? re.buffer.head.data.length : re.length : (fe > re.highWaterMark && (re.highWaterMark = c(fe)), fe <= re.length ? fe : re.ended ? re.length : (re.needReadable = !0, 0));
  }
  Re.prototype.read = function(fe) {
    y("read", fe), fe = parseInt(fe, 10);
    var re = this._readableState, we = fe;
    if (fe !== 0 && (re.emittedReadable = !1), fe === 0 && re.needReadable && ((re.highWaterMark !== 0 ? re.length >= re.highWaterMark : re.length > 0) || re.ended))
      return y("read: emitReadable", re.length, re.ended), re.length === 0 && re.ended ? H(this) : x(this), null;
    if (fe = b(fe, re), fe === 0 && re.ended)
      return re.length === 0 && H(this), null;
    var ke = re.needReadable;
    y("need readable", ke), (re.length === 0 || re.length - fe < re.highWaterMark) && (ke = !0, y("length less than watermark", ke)), re.ended || re.reading ? (ke = !1, y("reading or ended", ke)) : ke && (y("do read"), re.reading = !0, re.sync = !0, re.length === 0 && (re.needReadable = !0), this._read(re.highWaterMark), re.sync = !1, re.reading || (fe = b(we, re)));
    var Oe;
    return fe > 0 ? Oe = P(fe, re) : Oe = null, Oe === null ? (re.needReadable = re.length <= re.highWaterMark, fe = 0) : (re.length -= fe, re.awaitDrain = 0), re.length === 0 && (re.ended || (re.needReadable = !0), we !== fe && re.ended && H(this)), Oe !== null && this.emit("data", Oe), Oe;
  };
  function C(fe, re) {
    if (y("onEofChunk"), !re.ended) {
      if (re.decoder) {
        var we = re.decoder.end();
        we && we.length && (re.buffer.push(we), re.length += re.objectMode ? 1 : we.length);
      }
      re.ended = !0, re.sync ? x(fe) : (re.needReadable = !1, re.emittedReadable || (re.emittedReadable = !0, B(fe)));
    }
  }
  function x(fe) {
    var re = fe._readableState;
    y("emitReadable", re.needReadable, re.emittedReadable), re.needReadable = !1, re.emittedReadable || (y("emitReadable", re.flowing), re.emittedReadable = !0, api$2.nextTick(B, fe));
  }
  function B(fe) {
    var re = fe._readableState;
    y("emitReadable_", re.destroyed, re.length, re.ended), !re.destroyed && (re.length || re.ended) && (fe.emit("readable"), re.emittedReadable = !1), re.needReadable = !re.flowing && !re.ended && re.length <= re.highWaterMark, de(fe);
  }
  function k(fe, re) {
    re.readingMore || (re.readingMore = !0, api$2.nextTick(w, fe, re));
  }
  function w(fe, re) {
    for (; !re.reading && !re.ended && (re.length < re.highWaterMark || re.flowing && re.length === 0); ) {
      var we = re.length;
      if (y("maybeReadMore read 0"), fe.read(0), we === re.length)
        break;
    }
    re.readingMore = !1;
  }
  Re.prototype._read = function(fe) {
    Ee(this, new ie("_read()"));
  }, Re.prototype.pipe = function(fe, re) {
    var we = this, ke = this._readableState;
    switch (ke.pipesCount) {
      case 0:
        ke.pipes = fe;
        break;
      case 1:
        ke.pipes = [ke.pipes, fe];
        break;
      default:
        ke.pipes.push(fe);
        break;
    }
    ke.pipesCount += 1, y("pipe count=%d opts=%j", ke.pipesCount, re);
    var Oe = (!re || re.end !== !1) && fe !== api$2.stdout && fe !== api$2.stderr, ce = Oe ? z : at;
    ke.endEmitted ? api$2.nextTick(ce) : we.once("end", ce), fe.on("unpipe", j);
    function j(Qe, Pt) {
      y("onunpipe"), Qe === we && Pt && Pt.hasUnpiped === !1 && (Pt.hasUnpiped = !0, Te());
    }
    function z() {
      y("onend"), fe.end();
    }
    var oe = T(we);
    fe.on("drain", oe);
    var Be = !1;
    function Te() {
      y("cleanup"), fe.removeListener("close", He), fe.removeListener("finish", ot), fe.removeListener("drain", oe), fe.removeListener("error", Ye), fe.removeListener("unpipe", j), we.removeListener("end", z), we.removeListener("end", at), we.removeListener("data", Pe), Be = !0, ke.awaitDrain && (!fe._writableState || fe._writableState.needDrain) && oe();
    }
    we.on("data", Pe);
    function Pe(Qe) {
      y("ondata");
      var Pt = fe.write(Qe);
      y("dest.write", Pt), Pt === !1 && ((ke.pipesCount === 1 && ke.pipes === fe || ke.pipesCount > 1 && me(ke.pipes, fe) !== -1) && !Be && (y("false write response, pause", ke.awaitDrain), ke.awaitDrain++), we.pause());
    }
    function Ye(Qe) {
      y("onerror", Qe), at(), fe.removeListener("error", Ye), t(fe, "error") === 0 && Ee(fe, Qe);
    }
    Le(fe, "error", Ye);
    function He() {
      fe.removeListener("finish", ot), at();
    }
    fe.once("close", He);
    function ot() {
      y("onfinish"), fe.removeListener("close", He), at();
    }
    fe.once("finish", ot);
    function at() {
      y("unpipe"), we.unpipe(fe);
    }
    return fe.emit("pipe", we), ke.flowing || (y("pipe resume"), we.resume()), fe;
  };
  function T(fe) {
    return function() {
      var we = fe._readableState;
      y("pipeOnDrain", we.awaitDrain), we.awaitDrain && we.awaitDrain--, we.awaitDrain === 0 && t(fe, "data") && (we.flowing = !0, de(fe));
    };
  }
  Re.prototype.unpipe = function(fe) {
    var re = this._readableState, we = {
      hasUnpiped: !1
    };
    if (re.pipesCount === 0)
      return this;
    if (re.pipesCount === 1)
      return fe && fe !== re.pipes ? this : (fe || (fe = re.pipes), re.pipes = null, re.pipesCount = 0, re.flowing = !1, fe && fe.emit("unpipe", this, we), this);
    if (!fe) {
      var ke = re.pipes, Oe = re.pipesCount;
      re.pipes = null, re.pipesCount = 0, re.flowing = !1;
      for (var ce = 0; ce < Oe; ce++)
        ke[ce].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var j = me(re.pipes, fe);
    return j === -1 ? this : (re.pipes.splice(j, 1), re.pipesCount -= 1, re.pipesCount === 1 && (re.pipes = re.pipes[0]), fe.emit("unpipe", this, we), this);
  }, Re.prototype.on = function(fe, re) {
    var we = a.prototype.on.call(this, fe, re), ke = this._readableState;
    return fe === "data" ? (ke.readableListening = this.listenerCount("readable") > 0, ke.flowing !== !1 && this.resume()) : fe === "readable" && !ke.endEmitted && !ke.readableListening && (ke.readableListening = ke.needReadable = !0, ke.flowing = !1, ke.emittedReadable = !1, y("on readable", ke.length, ke.reading), ke.length ? x(this) : ke.reading || api$2.nextTick(F, this)), we;
  }, Re.prototype.addListener = Re.prototype.on, Re.prototype.removeListener = function(fe, re) {
    var we = a.prototype.removeListener.call(this, fe, re);
    return fe === "readable" && api$2.nextTick(p, this), we;
  }, Re.prototype.removeAllListeners = function(fe) {
    var re = a.prototype.removeAllListeners.apply(this, arguments);
    return (fe === "readable" || fe === void 0) && api$2.nextTick(p, this), re;
  };
  function p(fe) {
    var re = fe._readableState;
    re.readableListening = fe.listenerCount("readable") > 0, re.resumeScheduled && !re.paused ? re.flowing = !0 : fe.listenerCount("data") > 0 && fe.resume();
  }
  function F(fe) {
    y("readable nexttick read 0"), fe.read(0);
  }
  Re.prototype.resume = function() {
    var fe = this._readableState;
    return fe.flowing || (y("resume"), fe.flowing = !fe.readableListening, ye(this, fe)), fe.paused = !1, this;
  };
  function ye(fe, re) {
    re.resumeScheduled || (re.resumeScheduled = !0, api$2.nextTick(_e, fe, re));
  }
  function _e(fe, re) {
    y("resume", re.reading), re.reading || fe.read(0), re.resumeScheduled = !1, fe.emit("resume"), de(fe), re.flowing && !re.reading && fe.read(0);
  }
  Re.prototype.pause = function() {
    return y("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (y("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function de(fe) {
    var re = fe._readableState;
    for (y("flow", re.flowing); re.flowing && fe.read() !== null; )
      ;
  }
  Re.prototype.wrap = function(fe) {
    var re = this, we = this._readableState, ke = !1;
    fe.on("end", function() {
      if (y("wrapped end"), we.decoder && !we.ended) {
        var j = we.decoder.end();
        j && j.length && re.push(j);
      }
      re.push(null);
    }), fe.on("data", function(j) {
      if (y("wrapped data"), we.decoder && (j = we.decoder.write(j)), !(we.objectMode && j == null) && !(!we.objectMode && (!j || !j.length))) {
        var z = re.push(j);
        z || (ke = !0, fe.pause());
      }
    });
    for (var Oe in fe)
      this[Oe] === void 0 && typeof fe[Oe] == "function" && (this[Oe] = function(z) {
        return function() {
          return fe[z].apply(fe, arguments);
        };
      }(Oe));
    for (var ce = 0; ce < xe.length; ce++)
      fe.on(xe[ce], this.emit.bind(this, xe[ce]));
    return this._read = function(j) {
      y("wrapped _read", j), ke && (ke = !1, fe.resume());
    }, this;
  }, typeof Symbol == "function" && (Re.prototype[Symbol.asyncIterator] = function() {
    return ge === void 0 && (ge = requireAsync_iterator()), ge(this);
  }), Object.defineProperty(Re.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Re.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Re.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(re) {
      this._readableState && (this._readableState.flowing = re);
    }
  }), Re._fromList = P, Object.defineProperty(Re.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function P(fe, re) {
    if (re.length === 0)
      return null;
    var we;
    return re.objectMode ? we = re.buffer.shift() : !fe || fe >= re.length ? (re.decoder ? we = re.buffer.join("") : re.buffer.length === 1 ? we = re.buffer.first() : we = re.buffer.concat(re.length), re.buffer.clear()) : we = re.buffer.consume(fe, re.decoder), we;
  }
  function H(fe) {
    var re = fe._readableState;
    y("endReadable", re.endEmitted), re.endEmitted || (re.ended = !0, api$2.nextTick(he, re, fe));
  }
  function he(fe, re) {
    if (y("endReadableNT", fe.endEmitted, fe.length), !fe.endEmitted && fe.length === 0 && (fe.endEmitted = !0, re.readable = !1, re.emit("end"), fe.autoDestroy)) {
      var we = re._writableState;
      (!we || we.autoDestroy && we.finished) && re.destroy();
    }
  }
  typeof Symbol == "function" && (Re.from = function(fe, re) {
    return be === void 0 && (be = requireFromBrowser()), be(Re, fe, re);
  });
  function me(fe, re) {
    for (var we = 0, ke = fe.length; we < ke; we++)
      if (fe[we] === re)
        return we;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform$1;
  hasRequired_stream_transform = 1, _stream_transform$1 = h;
  var e = requireErrorsBrowser().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, a = e.ERR_MULTIPLE_CALLBACK, n = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, u = e.ERR_TRANSFORM_WITH_LENGTH_0, o = require_stream_duplex$1();
  inherits_browserExports(h, o);
  function l(d, $) {
    var N = this._transformState;
    N.transforming = !1;
    var U = N.writecb;
    if (U === null)
      return this.emit("error", new a());
    N.writechunk = null, N.writecb = null, $ != null && this.push($), U(d);
    var V = this._readableState;
    V.reading = !1, (V.needReadable || V.length < V.highWaterMark) && this._read(V.highWaterMark);
  }
  function h(d) {
    if (!(this instanceof h))
      return new h(d);
    o.call(this, d), this._transformState = {
      afterTransform: l.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, d && (typeof d.transform == "function" && (this._transform = d.transform), typeof d.flush == "function" && (this._flush = d.flush)), this.on("prefinish", y);
  }
  function y() {
    var d = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function($, N) {
      _(d, $, N);
    }) : _(this, null, null);
  }
  h.prototype.push = function(d, $) {
    return this._transformState.needTransform = !1, o.prototype.push.call(this, d, $);
  }, h.prototype._transform = function(d, $, N) {
    N(new t("_transform()"));
  }, h.prototype._write = function(d, $, N) {
    var U = this._transformState;
    if (U.writecb = N, U.writechunk = d, U.writeencoding = $, !U.transforming) {
      var V = this._readableState;
      (U.needTransform || V.needReadable || V.length < V.highWaterMark) && this._read(V.highWaterMark);
    }
  }, h.prototype._read = function(d) {
    var $ = this._transformState;
    $.writechunk !== null && !$.transforming ? ($.transforming = !0, this._transform($.writechunk, $.writeencoding, $.afterTransform)) : $.needTransform = !0;
  }, h.prototype._destroy = function(d, $) {
    o.prototype._destroy.call(this, d, function(N) {
      $(N);
    });
  };
  function _(d, $, N) {
    if ($)
      return d.emit("error", $);
    if (N != null && d.push(N), d._writableState.length)
      throw new u();
    if (d._transformState.transforming)
      throw new n();
    return d.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough$1;
  hasRequired_stream_passthrough = 1, _stream_passthrough$1 = t;
  var e = require_stream_transform();
  inherits_browserExports(t, e);
  function t(a) {
    if (!(this instanceof t))
      return new t(a);
    e.call(this, a);
  }
  return t.prototype._transform = function(a, n, u) {
    u(null, a);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline)
    return pipeline_1;
  hasRequiredPipeline = 1;
  var e;
  function t(N) {
    var U = !1;
    return function() {
      U || (U = !0, N.apply(void 0, arguments));
    };
  }
  var a = requireErrorsBrowser().codes, n = a.ERR_MISSING_ARGS, u = a.ERR_STREAM_DESTROYED;
  function o(N) {
    if (N)
      throw N;
  }
  function l(N) {
    return N.setHeader && typeof N.abort == "function";
  }
  function h(N, U, V, Q) {
    Q = t(Q);
    var ie = !1;
    N.on("close", function() {
      ie = !0;
    }), e === void 0 && (e = requireEndOfStream()), e(N, {
      readable: U,
      writable: V
    }, function(ne) {
      if (ne)
        return Q(ne);
      ie = !0, Q();
    });
    var ee = !1;
    return function(ne) {
      if (!ie && !ee) {
        if (ee = !0, l(N))
          return N.abort();
        if (typeof N.destroy == "function")
          return N.destroy();
        Q(ne || new u("pipe"));
      }
    };
  }
  function y(N) {
    N();
  }
  function _(N, U) {
    return N.pipe(U);
  }
  function d(N) {
    return !N.length || typeof N[N.length - 1] != "function" ? o : N.pop();
  }
  function $() {
    for (var N = arguments.length, U = new Array(N), V = 0; V < N; V++)
      U[V] = arguments[V];
    var Q = d(U);
    if (Array.isArray(U[0]) && (U = U[0]), U.length < 2)
      throw new n("streams");
    var ie, ee = U.map(function(ne, ge) {
      var be = ge < U.length - 1, Ee = ge > 0;
      return h(ne, be, Ee, function(xe) {
        ie || (ie = xe), xe && ee.forEach(y), !be && (ee.forEach(y), Q(ie));
      });
    });
    return U.reduce(_);
  }
  return pipeline_1 = $, pipeline_1;
}
var streamBrowserify = Stream, EE = eventsExports.EventEmitter, inherits$h = inherits_browserExports;
inherits$h(Stream, EE);
Stream.Readable = require_stream_readable$1();
Stream.Writable = require_stream_writable$1();
Stream.Duplex = require_stream_duplex$1();
Stream.Transform = require_stream_transform();
Stream.PassThrough = require_stream_passthrough();
Stream.finished = requireEndOfStream();
Stream.pipeline = requirePipeline();
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(e, t) {
  var a = this;
  function n(d) {
    e.writable && e.write(d) === !1 && a.pause && a.pause();
  }
  a.on("data", n);
  function u() {
    a.readable && a.resume && a.resume();
  }
  e.on("drain", u), !e._isStdio && (!t || t.end !== !1) && (a.on("end", l), a.on("close", h));
  var o = !1;
  function l() {
    o || (o = !0, e.end());
  }
  function h() {
    o || (o = !0, typeof e.destroy == "function" && e.destroy());
  }
  function y(d) {
    if (_(), EE.listenerCount(this, "error") === 0)
      throw d;
  }
  a.on("error", y), e.on("error", y);
  function _() {
    a.removeListener("data", n), e.removeListener("drain", u), a.removeListener("end", l), a.removeListener("close", h), a.removeListener("error", y), e.removeListener("error", y), a.removeListener("end", _), a.removeListener("close", _), e.removeListener("close", _);
  }
  return a.on("end", _), a.on("close", _), e.on("close", _), e.emit("pipe", a), e;
};
var Buffer$p = safeBufferExports$2.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$g = inherits_browserExports, toBuffer$3 = toBuffer$7;
function CipherBase$1(e) {
  Transform$6.call(this), this.hashMode = typeof e == "string", this.hashMode ? this[e] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$g(CipherBase$1, Transform$6);
CipherBase$1.prototype.update = function(e, t, a) {
  var n = toBuffer$3(e, t), u = this._update(n);
  return this.hashMode ? this : (a && (u = this._toString(u, a)), u);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(e, t, a) {
  var n;
  try {
    this.hashMode ? this._update(e) : this.push(this._update(e));
  } catch (u) {
    n = u;
  } finally {
    a(n);
  }
};
CipherBase$1.prototype._flush = function(e) {
  var t;
  try {
    this.push(this.__final());
  } catch (a) {
    t = a;
  }
  e(t);
};
CipherBase$1.prototype._finalOrDigest = function(e) {
  var t = this.__final() || Buffer$p.alloc(0);
  return e && (t = this._toString(t, e, !0)), t;
};
CipherBase$1.prototype._toString = function(e, t, a) {
  if (this._decoder || (this._decoder = new StringDecoder(t), this._encoding = t), this._encoding !== t)
    throw new Error("cant switch encodings");
  var n = this._decoder.write(e);
  return a && (n += this._decoder.end()), n;
};
var cipherBase = CipherBase$1, inherits$f = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$3 = ripemd160, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(e) {
  Base$5.call(this, "digest"), this._hash = e;
}
inherits$f(Hash, Base$5);
Hash.prototype._update = function(e) {
  this._hash.update(e);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$9 = function(t) {
  return t = t.toLowerCase(), t === "md5" ? new MD5$2() : t === "rmd160" || t === "ripemd160" ? new RIPEMD160$3() : new Hash(sha$3(t));
}, inherits$e = inherits_browserExports, Buffer$o = safeBufferExports$2.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$o.alloc(128), blocksize = 64;
function Hmac$3(e, t) {
  Base$4.call(this, "digest"), typeof t == "string" && (t = Buffer$o.from(t)), this._alg = e, this._key = t, t.length > blocksize ? t = e(t) : t.length < blocksize && (t = Buffer$o.concat([t, ZEROS$2], blocksize));
  for (var a = this._ipad = Buffer$o.allocUnsafe(blocksize), n = this._opad = Buffer$o.allocUnsafe(blocksize), u = 0; u < blocksize; u++)
    a[u] = t[u] ^ 54, n[u] = t[u] ^ 92;
  this._hash = [a];
}
inherits$e(Hmac$3, Base$4);
Hmac$3.prototype._update = function(e) {
  this._hash.push(e);
};
Hmac$3.prototype._final = function() {
  var e = this._alg(Buffer$o.concat(this._hash));
  return this._alg(Buffer$o.concat([this._opad, e]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$3 = function(e) {
  return new MD5$1().update(e).digest();
}, inherits$d = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$n = safeBufferExports$2.Buffer, md5$2 = md5$3, RIPEMD160$2 = ripemd160, sha$2 = sha_jsExports, ZEROS$1 = Buffer$n.alloc(128);
function Hmac$2(e, t) {
  Base$3.call(this, "digest"), typeof t == "string" && (t = Buffer$n.from(t));
  var a = e === "sha512" || e === "sha384" ? 128 : 64;
  if (this._alg = e, this._key = t, t.length > a) {
    var n = e === "rmd160" ? new RIPEMD160$2() : sha$2(e);
    t = n.update(t).digest();
  } else
    t.length < a && (t = Buffer$n.concat([t, ZEROS$1], a));
  for (var u = this._ipad = Buffer$n.allocUnsafe(a), o = this._opad = Buffer$n.allocUnsafe(a), l = 0; l < a; l++)
    u[l] = t[l] ^ 54, o[l] = t[l] ^ 92;
  this._hash = e === "rmd160" ? new RIPEMD160$2() : sha$2(e), this._hash.update(u);
}
inherits$d(Hmac$2, Base$3);
Hmac$2.prototype._update = function(e) {
  this._hash.update(e);
};
Hmac$2.prototype._final = function() {
  var e = this._hash.digest(), t = this._alg === "rmd160" ? new RIPEMD160$2() : sha$2(this._alg);
  return t.update(this._opad).update(e).digest();
};
var browser$8 = function(t, a) {
  return t = t.toLowerCase(), t === "rmd160" || t === "ripemd160" ? new Hmac$2("rmd160", a) : t === "md5" ? new Legacy(md5$2, a) : new Hmac$2(t, a);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$1 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384$1 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512$2 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$1,
  sha224,
  sha384: sha384$1,
  sha512: sha512$2,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$7 = {}, $isFinite = isFinite, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(e, t) {
  if (typeof e != "number")
    throw new TypeError("Iterations not a number");
  if (e < 0 || !$isFinite(e))
    throw new TypeError("Bad iterations");
  if (typeof t != "number")
    throw new TypeError("Key length not a number");
  if (t < 0 || t > MAX_ALLOC || t !== t)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(api$2.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$m = safeBufferExports$2.Buffer, toBuffer$2 = toBuffer$7, useUint8Array = typeof Uint8Array < "u", useArrayBuffer = useUint8Array && typeof ArrayBuffer < "u", isView = useArrayBuffer && ArrayBuffer.isView, toBuffer_1 = function(e, t, a) {
  if (typeof e == "string" || Buffer$m.isBuffer(e) || useUint8Array && e instanceof Uint8Array || isView && isView(e))
    return toBuffer$2(e, t);
  throw new TypeError(a + " must be a string, a Buffer, a Uint8Array, or a DataView");
}, md5$1 = md5$3, RIPEMD160$1 = ripemd160, sha$1 = sha_jsExports, Buffer$l = safeBufferExports$2.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$1 = toBuffer_1, ZEROS = Buffer$l.alloc(128), sizes = {
  __proto__: null,
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  "sha512-256": 32,
  ripemd160: 20,
  rmd160: 20
}, mapping = {
  __proto__: null,
  "sha-1": "sha1",
  "sha-224": "sha224",
  "sha-256": "sha256",
  "sha-384": "sha384",
  "sha-512": "sha512",
  "ripemd-160": "ripemd160"
};
function rmd160Func(e) {
  return new RIPEMD160$1().update(e).digest();
}
function getDigest(e) {
  function t(a) {
    return sha$1(e).update(a).digest();
  }
  return e === "rmd160" || e === "ripemd160" ? rmd160Func : e === "md5" ? md5$1 : t;
}
function Hmac$1(e, t, a) {
  var n = getDigest(e), u = e === "sha512" || e === "sha384" ? 128 : 64;
  t.length > u ? t = n(t) : t.length < u && (t = Buffer$l.concat([t, ZEROS], u));
  for (var o = Buffer$l.allocUnsafe(u + sizes[e]), l = Buffer$l.allocUnsafe(u + sizes[e]), h = 0; h < u; h++)
    o[h] = t[h] ^ 54, l[h] = t[h] ^ 92;
  var y = Buffer$l.allocUnsafe(u + a + 4);
  o.copy(y, 0, 0, u), this.ipad1 = y, this.ipad2 = o, this.opad = l, this.alg = e, this.blocksize = u, this.hash = n, this.size = sizes[e];
}
Hmac$1.prototype.run = function(e, t) {
  e.copy(t, this.blocksize);
  var a = this.hash(t);
  return a.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function pbkdf2(e, t, a, n, u) {
  checkParameters$1(a, n), e = toBuffer$1(e, defaultEncoding$1, "Password"), t = toBuffer$1(t, defaultEncoding$1, "Salt");
  var o = (u || "sha1").toLowerCase(), l = mapping[o] || o, h = sizes[l];
  if (typeof h != "number" || !h)
    throw new TypeError("Digest algorithm not supported: " + u);
  var y = new Hmac$1(l, e, t.length), _ = Buffer$l.allocUnsafe(n), d = Buffer$l.allocUnsafe(t.length + 4);
  t.copy(d, 0, 0, t.length);
  for (var $ = 0, N = h, U = Math.ceil(n / N), V = 1; V <= U; V++) {
    d.writeUInt32BE(V, t.length);
    for (var Q = y.run(d, y.ipad1), ie = Q, ee = 1; ee < a; ee++) {
      ie = y.run(ie, y.ipad2);
      for (var ne = 0; ne < N; ne++)
        Q[ne] ^= ie[ne];
    }
    Q.copy(_, $), $ += N;
  }
  return _;
}
var syncBrowser = pbkdf2, Buffer$k = safeBufferExports$2.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer = toBuffer_1, ZERO_BUF, subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [], nextTick;
function getNextTick() {
  return nextTick || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? nextTick = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? nextTick = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? nextTick = commonjsGlobal.setImmediate : nextTick = commonjsGlobal.setTimeout, nextTick);
}
function browserPbkdf2(e, t, a, n, u) {
  return subtle.importKey("raw", e, { name: "PBKDF2" }, !1, ["deriveBits"]).then(function(o) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: t,
      iterations: a,
      hash: {
        name: u
      }
    }, o, n << 3);
  }).then(function(o) {
    return Buffer$k.from(o);
  });
}
function checkNative(e) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[e] !== void 0)
    return checks[e];
  ZERO_BUF = ZERO_BUF || Buffer$k.alloc(8);
  var t = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, e).then(
    function() {
      return !0;
    },
    function() {
      return !1;
    }
  );
  return checks[e] = t, t;
}
function resolvePromise(e, t) {
  e.then(function(a) {
    getNextTick()(function() {
      t(null, a);
    });
  }, function(a) {
    getNextTick()(function() {
      t(a);
    });
  });
}
var async = function(e, t, a, n, u, o) {
  if (typeof u == "function" && (o = u, u = void 0), checkParameters(a, n), e = toBuffer(e, defaultEncoding, "Password"), t = toBuffer(t, defaultEncoding, "Salt"), typeof o != "function")
    throw new Error("No callback provided to pbkdf2");
  u = u || "sha1";
  var l = toBrowser[u.toLowerCase()];
  if (!l || typeof commonjsGlobal.Promise != "function") {
    getNextTick()(function() {
      var h;
      try {
        h = sync(e, t, a, n, u);
      } catch (y) {
        o(y);
        return;
      }
      o(null, h);
    });
    return;
  }
  resolvePromise(checkNative(l).then(function(h) {
    return h ? browserPbkdf2(e, t, a, n, l) : sync(e, t, a, n, u);
  }), o);
};
browser$7.pbkdf2 = async;
browser$7.pbkdf2Sync = syncBrowser;
var browser$6 = {}, des$2 = {}, utils$n = {};
utils$n.readUInt32BE = function(t, a) {
  var n = t[0 + a] << 24 | t[1 + a] << 16 | t[2 + a] << 8 | t[3 + a];
  return n >>> 0;
};
utils$n.writeUInt32BE = function(t, a, n) {
  t[0 + n] = a >>> 24, t[1 + n] = a >>> 16 & 255, t[2 + n] = a >>> 8 & 255, t[3 + n] = a & 255;
};
utils$n.ip = function(t, a, n, u) {
  for (var o = 0, l = 0, h = 6; h >= 0; h -= 2) {
    for (var y = 0; y <= 24; y += 8)
      o <<= 1, o |= a >>> y + h & 1;
    for (var y = 0; y <= 24; y += 8)
      o <<= 1, o |= t >>> y + h & 1;
  }
  for (var h = 6; h >= 0; h -= 2) {
    for (var y = 1; y <= 25; y += 8)
      l <<= 1, l |= a >>> y + h & 1;
    for (var y = 1; y <= 25; y += 8)
      l <<= 1, l |= t >>> y + h & 1;
  }
  n[u + 0] = o >>> 0, n[u + 1] = l >>> 0;
};
utils$n.rip = function(t, a, n, u) {
  for (var o = 0, l = 0, h = 0; h < 4; h++)
    for (var y = 24; y >= 0; y -= 8)
      o <<= 1, o |= a >>> y + h & 1, o <<= 1, o |= t >>> y + h & 1;
  for (var h = 4; h < 8; h++)
    for (var y = 24; y >= 0; y -= 8)
      l <<= 1, l |= a >>> y + h & 1, l <<= 1, l |= t >>> y + h & 1;
  n[u + 0] = o >>> 0, n[u + 1] = l >>> 0;
};
utils$n.pc1 = function(t, a, n, u) {
  for (var o = 0, l = 0, h = 7; h >= 5; h--) {
    for (var y = 0; y <= 24; y += 8)
      o <<= 1, o |= a >> y + h & 1;
    for (var y = 0; y <= 24; y += 8)
      o <<= 1, o |= t >> y + h & 1;
  }
  for (var y = 0; y <= 24; y += 8)
    o <<= 1, o |= a >> y + h & 1;
  for (var h = 1; h <= 3; h++) {
    for (var y = 0; y <= 24; y += 8)
      l <<= 1, l |= a >> y + h & 1;
    for (var y = 0; y <= 24; y += 8)
      l <<= 1, l |= t >> y + h & 1;
  }
  for (var y = 0; y <= 24; y += 8)
    l <<= 1, l |= t >> y + h & 1;
  n[u + 0] = o >>> 0, n[u + 1] = l >>> 0;
};
utils$n.r28shl = function(t, a) {
  return t << a & 268435455 | t >>> 28 - a;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$n.pc2 = function(t, a, n, u) {
  for (var o = 0, l = 0, h = pc2table.length >>> 1, y = 0; y < h; y++)
    o <<= 1, o |= t >>> pc2table[y] & 1;
  for (var y = h; y < pc2table.length; y++)
    l <<= 1, l |= a >>> pc2table[y] & 1;
  n[u + 0] = o >>> 0, n[u + 1] = l >>> 0;
};
utils$n.expand = function(t, a, n) {
  var u = 0, o = 0;
  u = (t & 1) << 5 | t >>> 27;
  for (var l = 23; l >= 15; l -= 4)
    u <<= 6, u |= t >>> l & 63;
  for (var l = 11; l >= 3; l -= 4)
    o |= t >>> l & 63, o <<= 6;
  o |= (t & 31) << 1 | t >>> 31, a[n + 0] = u >>> 0, a[n + 1] = o >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$n.substitute = function(t, a) {
  for (var n = 0, u = 0; u < 4; u++) {
    var o = t >>> 18 - u * 6 & 63, l = sTable[u * 64 + o];
    n <<= 4, n |= l;
  }
  for (var u = 0; u < 4; u++) {
    var o = a >>> 18 - u * 6 & 63, l = sTable[4 * 64 + u * 64 + o];
    n <<= 4, n |= l;
  }
  return n >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$n.permute = function(t) {
  for (var a = 0, n = 0; n < permuteTable.length; n++)
    a <<= 1, a |= t >>> permuteTable[n] & 1;
  return a >>> 0;
};
utils$n.padSplit = function(t, a, n) {
  for (var u = t.toString(2); u.length < a; )
    u = "0" + u;
  for (var o = [], l = 0; l < a; l += n)
    o.push(u.slice(l, l + n));
  return o.join(" ");
};
var minimalisticAssert = assert$i;
function assert$i(e, t) {
  if (!e)
    throw new Error(t || "Assertion failed");
}
assert$i.equal = function(t, a, n) {
  if (t != a)
    throw new Error(n || "Assertion failed: " + t + " != " + a);
};
var assert$h = minimalisticAssert;
function Cipher$3(e) {
  this.options = e, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = e.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function() {
};
Cipher$3.prototype.update = function(t) {
  return t.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(t) : this._updateEncrypt(t);
};
Cipher$3.prototype._buffer = function(t, a) {
  for (var n = Math.min(this.buffer.length - this.bufferOff, t.length - a), u = 0; u < n; u++)
    this.buffer[this.bufferOff + u] = t[a + u];
  return this.bufferOff += n, n;
};
Cipher$3.prototype._flushBuffer = function(t, a) {
  return this._update(this.buffer, 0, t, a), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function(t) {
  var a = 0, n = 0, u = (this.bufferOff + t.length) / this.blockSize | 0, o = new Array(u * this.blockSize);
  this.bufferOff !== 0 && (a += this._buffer(t, a), this.bufferOff === this.buffer.length && (n += this._flushBuffer(o, n)));
  for (var l = t.length - (t.length - a) % this.blockSize; a < l; a += this.blockSize)
    this._update(t, a, o, n), n += this.blockSize;
  for (; a < t.length; a++, this.bufferOff++)
    this.buffer[this.bufferOff] = t[a];
  return o;
};
Cipher$3.prototype._updateDecrypt = function(t) {
  for (var a = 0, n = 0, u = Math.ceil((this.bufferOff + t.length) / this.blockSize) - 1, o = new Array(u * this.blockSize); u > 0; u--)
    a += this._buffer(t, a), n += this._flushBuffer(o, n);
  return a += this._buffer(t, a), o;
};
Cipher$3.prototype.final = function(t) {
  var a;
  t && (a = this.update(t));
  var n;
  return this.type === "encrypt" ? n = this._finalEncrypt() : n = this._finalDecrypt(), a ? a.concat(n) : n;
};
Cipher$3.prototype._pad = function(t, a) {
  if (a === 0)
    return !1;
  for (; a < t.length; )
    t[a++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var t = new Array(this.blockSize);
  return this._update(this.buffer, 0, t, 0), t;
};
Cipher$3.prototype._unpad = function(t) {
  return t;
};
Cipher$3.prototype._finalDecrypt = function() {
  assert$h.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var t = new Array(this.blockSize);
  return this._flushBuffer(t, 0), this._unpad(t);
};
var assert$g = minimalisticAssert, inherits$c = inherits_browserExports, utils$m = utils$n, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(e) {
  Cipher$2.call(this, e);
  var t = new DESState();
  this._desState = t, this.deriveKeys(t, e.key);
}
inherits$c(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function(t) {
  return new DES$3(t);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function(t, a) {
  t.keys = new Array(16 * 2), assert$g.equal(a.length, this.blockSize, "Invalid key length");
  var n = utils$m.readUInt32BE(a, 0), u = utils$m.readUInt32BE(a, 4);
  utils$m.pc1(n, u, t.tmp, 0), n = t.tmp[0], u = t.tmp[1];
  for (var o = 0; o < t.keys.length; o += 2) {
    var l = shiftTable[o >>> 1];
    n = utils$m.r28shl(n, l), u = utils$m.r28shl(u, l), utils$m.pc2(n, u, t.keys, o);
  }
};
DES$3.prototype._update = function(t, a, n, u) {
  var o = this._desState, l = utils$m.readUInt32BE(t, a), h = utils$m.readUInt32BE(t, a + 4);
  utils$m.ip(l, h, o.tmp, 0), l = o.tmp[0], h = o.tmp[1], this.type === "encrypt" ? this._encrypt(o, l, h, o.tmp, 0) : this._decrypt(o, l, h, o.tmp, 0), l = o.tmp[0], h = o.tmp[1], utils$m.writeUInt32BE(n, l, u), utils$m.writeUInt32BE(n, h, u + 4);
};
DES$3.prototype._pad = function(t, a) {
  if (this.padding === !1)
    return !1;
  for (var n = t.length - a, u = a; u < t.length; u++)
    t[u] = n;
  return !0;
};
DES$3.prototype._unpad = function(t) {
  if (this.padding === !1)
    return t;
  for (var a = t[t.length - 1], n = t.length - a; n < t.length; n++)
    assert$g.equal(t[n], a);
  return t.slice(0, t.length - a);
};
DES$3.prototype._encrypt = function(t, a, n, u, o) {
  for (var l = a, h = n, y = 0; y < t.keys.length; y += 2) {
    var _ = t.keys[y], d = t.keys[y + 1];
    utils$m.expand(h, t.tmp, 0), _ ^= t.tmp[0], d ^= t.tmp[1];
    var $ = utils$m.substitute(_, d), N = utils$m.permute($), U = h;
    h = (l ^ N) >>> 0, l = U;
  }
  utils$m.rip(h, l, u, o);
};
DES$3.prototype._decrypt = function(t, a, n, u, o) {
  for (var l = n, h = a, y = t.keys.length - 2; y >= 0; y -= 2) {
    var _ = t.keys[y], d = t.keys[y + 1];
    utils$m.expand(l, t.tmp, 0), _ ^= t.tmp[0], d ^= t.tmp[1];
    var $ = utils$m.substitute(_, d), N = utils$m.permute($), U = l;
    l = (h ^ N) >>> 0, h = U;
  }
  utils$m.rip(l, h, u, o);
};
var cbc$1 = {}, assert$f = minimalisticAssert, inherits$b = inherits_browserExports, proto = {};
function CBCState(e) {
  assert$f.equal(e.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var t = 0; t < this.iv.length; t++)
    this.iv[t] = e[t];
}
function instantiate(e) {
  function t(o) {
    e.call(this, o), this._cbcInit();
  }
  inherits$b(t, e);
  for (var a = Object.keys(proto), n = 0; n < a.length; n++) {
    var u = a[n];
    t.prototype[u] = proto[u];
  }
  return t.create = function(l) {
    return new t(l);
  }, t;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function() {
  var t = new CBCState(this.options.iv);
  this._cbcState = t;
};
proto._update = function(t, a, n, u) {
  var o = this._cbcState, l = this.constructor.super_.prototype, h = o.iv;
  if (this.type === "encrypt") {
    for (var y = 0; y < this.blockSize; y++)
      h[y] ^= t[a + y];
    l._update.call(this, h, 0, n, u);
    for (var y = 0; y < this.blockSize; y++)
      h[y] = n[u + y];
  } else {
    l._update.call(this, t, a, n, u);
    for (var y = 0; y < this.blockSize; y++)
      n[u + y] ^= h[y];
    for (var y = 0; y < this.blockSize; y++)
      h[y] = t[a + y];
  }
};
var assert$e = minimalisticAssert, inherits$a = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(e, t) {
  assert$e.equal(t.length, 24, "Invalid key length");
  var a = t.slice(0, 8), n = t.slice(8, 16), u = t.slice(16, 24);
  e === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: a }),
    DES$2.create({ type: "decrypt", key: n }),
    DES$2.create({ type: "encrypt", key: u })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: u }),
    DES$2.create({ type: "encrypt", key: n }),
    DES$2.create({ type: "decrypt", key: a })
  ];
}
function EDE(e) {
  Cipher$1.call(this, e);
  var t = new EDEState(this.type, this.options.key);
  this._edeState = t;
}
inherits$a(EDE, Cipher$1);
var ede = EDE;
EDE.create = function(t) {
  return new EDE(t);
};
EDE.prototype._update = function(t, a, n, u) {
  var o = this._edeState;
  o.ciphers[0]._update(t, a, n, u), o.ciphers[1]._update(n, u, n, u), o.ciphers[2]._update(n, u, n, u);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$n;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$9 = inherits_browserExports, Buffer$j = safeBufferExports$2.Buffer, modes$4 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$4.des = modes$4["des-cbc"];
modes$4.des3 = modes$4["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$9(DES$1, CipherBase);
function DES$1(e) {
  CipherBase.call(this);
  var t = e.mode.toLowerCase(), a = modes$4[t], n;
  e.decrypt ? n = "decrypt" : n = "encrypt";
  var u = e.key;
  Buffer$j.isBuffer(u) || (u = Buffer$j.from(u)), (t === "des-ede" || t === "des-ede-cbc") && (u = Buffer$j.concat([u, u.slice(0, 8)]));
  var o = e.iv;
  Buffer$j.isBuffer(o) || (o = Buffer$j.from(o)), this._des = a.create({
    key: u,
    iv: o,
    type: n
  });
}
DES$1.prototype._update = function(e) {
  return Buffer$j.from(this._des.update(e));
};
DES$1.prototype._final = function() {
  return Buffer$j.from(this._des.final());
};
var browser$5 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(e, t) {
  return e._cipher.encryptBlock(t);
};
ecb.decrypt = function(e, t) {
  return e._cipher.decryptBlock(t);
};
var cbc = {}, bufferXor = function(t, a) {
  for (var n = Math.min(t.length, a.length), u = new buffer$1.Buffer(n), o = 0; o < n; ++o)
    u[o] = t[o] ^ a[o];
  return u;
}, xor$7 = bufferXor;
cbc.encrypt = function(e, t) {
  var a = xor$7(t, e._prev);
  return e._prev = e._cipher.encryptBlock(a), e._prev;
};
cbc.decrypt = function(e, t) {
  var a = e._prev;
  e._prev = t;
  var n = e._cipher.decryptBlock(t);
  return xor$7(n, a);
};
var cfb = {}, Buffer$i = safeBufferExports$2.Buffer, xor$6 = bufferXor;
function encryptStart(e, t, a) {
  var n = t.length, u = xor$6(t, e._cache);
  return e._cache = e._cache.slice(n), e._prev = Buffer$i.concat([e._prev, a ? t : u]), u;
}
cfb.encrypt = function(e, t, a) {
  for (var n = Buffer$i.allocUnsafe(0), u; t.length; )
    if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = Buffer$i.allocUnsafe(0)), e._cache.length <= t.length)
      u = e._cache.length, n = Buffer$i.concat([n, encryptStart(e, t.slice(0, u), a)]), t = t.slice(u);
    else {
      n = Buffer$i.concat([n, encryptStart(e, t, a)]);
      break;
    }
  return n;
};
var cfb8 = {}, Buffer$h = safeBufferExports$2.Buffer;
function encryptByte$1(e, t, a) {
  var n = e._cipher.encryptBlock(e._prev), u = n[0] ^ t;
  return e._prev = Buffer$h.concat([
    e._prev.slice(1),
    Buffer$h.from([a ? t : u])
  ]), u;
}
cfb8.encrypt = function(e, t, a) {
  for (var n = t.length, u = Buffer$h.allocUnsafe(n), o = -1; ++o < n; )
    u[o] = encryptByte$1(e, t[o], a);
  return u;
};
var cfb1 = {}, Buffer$g = safeBufferExports$2.Buffer;
function encryptByte(e, t, a) {
  for (var n, u = -1, o = 8, l = 0, h, y; ++u < o; )
    n = e._cipher.encryptBlock(e._prev), h = t & 1 << 7 - u ? 128 : 0, y = n[0] ^ h, l += (y & 128) >> u % 8, e._prev = shiftIn(e._prev, a ? h : y);
  return l;
}
function shiftIn(e, t) {
  var a = e.length, n = -1, u = Buffer$g.allocUnsafe(e.length);
  for (e = Buffer$g.concat([e, Buffer$g.from([t])]); ++n < a; )
    u[n] = e[n] << 1 | e[n + 1] >> 7;
  return u;
}
cfb1.encrypt = function(e, t, a) {
  for (var n = t.length, u = Buffer$g.allocUnsafe(n), o = -1; ++o < n; )
    u[o] = encryptByte(e, t[o], a);
  return u;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(e) {
  return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
}
ofb.encrypt = function(e, t) {
  for (; e._cache.length < t.length; )
    e._cache = buffer$1.Buffer.concat([e._cache, getBlock$1(e)]);
  var a = e._cache.slice(0, t.length);
  return e._cache = e._cache.slice(t.length), xor$5(t, a);
};
var ctr = {};
function incr32$2(e) {
  for (var t = e.length, a; t--; )
    if (a = e.readUInt8(t), a === 255)
      e.writeUInt8(0, t);
    else {
      a++, e.writeUInt8(a, t);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$f = safeBufferExports$2.Buffer, incr32$1 = incr32_1;
function getBlock(e) {
  var t = e._cipher.encryptBlockRaw(e._prev);
  return incr32$1(e._prev), t;
}
var blockSize = 16;
ctr.encrypt = function(e, t) {
  var a = Math.ceil(t.length / blockSize), n = e._cache.length;
  e._cache = Buffer$f.concat([
    e._cache,
    Buffer$f.allocUnsafe(a * blockSize)
  ]);
  for (var u = 0; u < a; u++) {
    var o = getBlock(e), l = n + u * blockSize;
    e._cache.writeUInt32BE(o[0], l + 0), e._cache.writeUInt32BE(o[1], l + 4), e._cache.writeUInt32BE(o[2], l + 8), e._cache.writeUInt32BE(o[3], l + 12);
  }
  var h = e._cache.slice(0, t.length);
  return e._cache = e._cache.slice(t.length), xor$4(t, h);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$3 = require$$2;
for (var key$3 in modes$3)
  modes$3[key$3].module = modeModules[modes$3[key$3].mode];
var modes_1 = modes$3, aes$5 = {}, Buffer$e = safeBufferExports$2.Buffer;
function asUInt32Array(e) {
  Buffer$e.isBuffer(e) || (e = Buffer$e.from(e));
  for (var t = e.length / 4 | 0, a = new Array(t), n = 0; n < t; n++)
    a[n] = e.readUInt32BE(n * 4);
  return a;
}
function scrubVec(e) {
  for (var t = 0; t < e.length; e++)
    e[t] = 0;
}
function cryptBlock(e, t, a, n, u) {
  for (var o = a[0], l = a[1], h = a[2], y = a[3], _ = e[0] ^ t[0], d = e[1] ^ t[1], $ = e[2] ^ t[2], N = e[3] ^ t[3], U, V, Q, ie, ee = 4, ne = 1; ne < u; ne++)
    U = o[_ >>> 24] ^ l[d >>> 16 & 255] ^ h[$ >>> 8 & 255] ^ y[N & 255] ^ t[ee++], V = o[d >>> 24] ^ l[$ >>> 16 & 255] ^ h[N >>> 8 & 255] ^ y[_ & 255] ^ t[ee++], Q = o[$ >>> 24] ^ l[N >>> 16 & 255] ^ h[_ >>> 8 & 255] ^ y[d & 255] ^ t[ee++], ie = o[N >>> 24] ^ l[_ >>> 16 & 255] ^ h[d >>> 8 & 255] ^ y[$ & 255] ^ t[ee++], _ = U, d = V, $ = Q, N = ie;
  return U = (n[_ >>> 24] << 24 | n[d >>> 16 & 255] << 16 | n[$ >>> 8 & 255] << 8 | n[N & 255]) ^ t[ee++], V = (n[d >>> 24] << 24 | n[$ >>> 16 & 255] << 16 | n[N >>> 8 & 255] << 8 | n[_ & 255]) ^ t[ee++], Q = (n[$ >>> 24] << 24 | n[N >>> 16 & 255] << 16 | n[_ >>> 8 & 255] << 8 | n[d & 255]) ^ t[ee++], ie = (n[N >>> 24] << 24 | n[_ >>> 16 & 255] << 16 | n[d >>> 8 & 255] << 8 | n[$ & 255]) ^ t[ee++], U = U >>> 0, V = V >>> 0, Q = Q >>> 0, ie = ie >>> 0, [U, V, Q, ie];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var e = new Array(256), t = 0; t < 256; t++)
    t < 128 ? e[t] = t << 1 : e[t] = t << 1 ^ 283;
  for (var a = [], n = [], u = [[], [], [], []], o = [[], [], [], []], l = 0, h = 0, y = 0; y < 256; ++y) {
    var _ = h ^ h << 1 ^ h << 2 ^ h << 3 ^ h << 4;
    _ = _ >>> 8 ^ _ & 255 ^ 99, a[l] = _, n[_] = l;
    var d = e[l], $ = e[d], N = e[$], U = e[_] * 257 ^ _ * 16843008;
    u[0][l] = U << 24 | U >>> 8, u[1][l] = U << 16 | U >>> 16, u[2][l] = U << 8 | U >>> 24, u[3][l] = U, U = N * 16843009 ^ $ * 65537 ^ d * 257 ^ l * 16843008, o[0][_] = U << 24 | U >>> 8, o[1][_] = U << 16 | U >>> 16, o[2][_] = U << 8 | U >>> 24, o[3][_] = U, l === 0 ? l = h = 1 : (l = d ^ e[e[e[N ^ d]]], h ^= e[e[h]]);
  }
  return {
    SBOX: a,
    INV_SBOX: n,
    SUB_MIX: u,
    INV_SUB_MIX: o
  };
}();
function AES(e) {
  this._key = asUInt32Array(e), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var e = this._key, t = e.length, a = t + 6, n = (a + 1) * 4, u = [], o = 0; o < t; o++)
    u[o] = e[o];
  for (o = t; o < n; o++) {
    var l = u[o - 1];
    o % t === 0 ? (l = l << 8 | l >>> 24, l = G.SBOX[l >>> 24] << 24 | G.SBOX[l >>> 16 & 255] << 16 | G.SBOX[l >>> 8 & 255] << 8 | G.SBOX[l & 255], l ^= RCON[o / t | 0] << 24) : t > 6 && o % t === 4 && (l = G.SBOX[l >>> 24] << 24 | G.SBOX[l >>> 16 & 255] << 16 | G.SBOX[l >>> 8 & 255] << 8 | G.SBOX[l & 255]), u[o] = u[o - t] ^ l;
  }
  for (var h = [], y = 0; y < n; y++) {
    var _ = n - y, d = u[_ - (y % 4 ? 0 : 4)];
    y < 4 || _ <= 4 ? h[y] = d : h[y] = G.INV_SUB_MIX[0][G.SBOX[d >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[d >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[d >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[d & 255]];
  }
  this._nRounds = a, this._keySchedule = u, this._invKeySchedule = h;
};
AES.prototype.encryptBlockRaw = function(e) {
  return e = asUInt32Array(e), cryptBlock(e, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(e) {
  var t = this.encryptBlockRaw(e), a = Buffer$e.allocUnsafe(16);
  return a.writeUInt32BE(t[0], 0), a.writeUInt32BE(t[1], 4), a.writeUInt32BE(t[2], 8), a.writeUInt32BE(t[3], 12), a;
};
AES.prototype.decryptBlock = function(e) {
  e = asUInt32Array(e);
  var t = e[1];
  e[1] = e[3], e[3] = t;
  var a = cryptBlock(e, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), n = Buffer$e.allocUnsafe(16);
  return n.writeUInt32BE(a[0], 0), n.writeUInt32BE(a[3], 4), n.writeUInt32BE(a[2], 8), n.writeUInt32BE(a[1], 12), n;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$d = safeBufferExports$2.Buffer, ZEROES = Buffer$d.alloc(16, 0);
function toArray$1(e) {
  return [
    e.readUInt32BE(0),
    e.readUInt32BE(4),
    e.readUInt32BE(8),
    e.readUInt32BE(12)
  ];
}
function fromArray(e) {
  var t = Buffer$d.allocUnsafe(16);
  return t.writeUInt32BE(e[0] >>> 0, 0), t.writeUInt32BE(e[1] >>> 0, 4), t.writeUInt32BE(e[2] >>> 0, 8), t.writeUInt32BE(e[3] >>> 0, 12), t;
}
function GHASH$1(e) {
  this.h = e, this.state = Buffer$d.alloc(16, 0), this.cache = Buffer$d.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(e) {
  for (var t = -1; ++t < e.length; )
    this.state[t] ^= e[t];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var e = toArray$1(this.h), t = [0, 0, 0, 0], a, n, u, o = -1; ++o < 128; ) {
    for (n = (this.state[~~(o / 8)] & 1 << 7 - o % 8) !== 0, n && (t[0] ^= e[0], t[1] ^= e[1], t[2] ^= e[2], t[3] ^= e[3]), u = (e[3] & 1) !== 0, a = 3; a > 0; a--)
      e[a] = e[a] >>> 1 | (e[a - 1] & 1) << 31;
    e[0] = e[0] >>> 1, u && (e[0] = e[0] ^ 225 << 24);
  }
  this.state = fromArray(t);
};
GHASH$1.prototype.update = function(e) {
  this.cache = Buffer$d.concat([this.cache, e]);
  for (var t; this.cache.length >= 16; )
    t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(t);
};
GHASH$1.prototype.final = function(e, t) {
  return this.cache.length && this.ghash(Buffer$d.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, e, 0, t])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$c = safeBufferExports$2.Buffer, Transform$5 = cipherBase, inherits$8 = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(e, t) {
  var a = 0;
  e.length !== t.length && a++;
  for (var n = Math.min(e.length, t.length), u = 0; u < n; ++u)
    a += e[u] ^ t[u];
  return a;
}
function calcIv(e, t, a) {
  if (t.length === 12)
    return e._finID = Buffer$c.concat([t, Buffer$c.from([0, 0, 0, 1])]), Buffer$c.concat([t, Buffer$c.from([0, 0, 0, 2])]);
  var n = new GHASH(a), u = t.length, o = u % 16;
  n.update(t), o && (o = 16 - o, n.update(Buffer$c.alloc(o, 0))), n.update(Buffer$c.alloc(8, 0));
  var l = u * 8, h = Buffer$c.alloc(8);
  h.writeUIntBE(l, 0, 8), n.update(h), e._finID = n.state;
  var y = Buffer$c.from(e._finID);
  return incr32(y), y;
}
function StreamCipher$3(e, t, a, n) {
  Transform$5.call(this);
  var u = Buffer$c.alloc(4, 0);
  this._cipher = new aes$4.AES(t);
  var o = this._cipher.encryptBlock(u);
  this._ghash = new GHASH(o), a = calcIv(this, a, o), this._prev = Buffer$c.from(a), this._cache = Buffer$c.allocUnsafe(0), this._secCache = Buffer$c.allocUnsafe(0), this._decrypt = n, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = !1;
}
inherits$8(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(e) {
  if (!this._called && this._alen) {
    var t = 16 - this._alen % 16;
    t < 16 && (t = Buffer$c.alloc(t, 0), this._ghash.update(t));
  }
  this._called = !0;
  var a = this._mode.encrypt(this, e);
  return this._decrypt ? this._ghash.update(e) : this._ghash.update(a), this._len += e.length, a;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var e = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(e, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = e, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function() {
  if (this._decrypt || !Buffer$c.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function(t) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = t;
};
StreamCipher$3.prototype.setAAD = function(t) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(t), this._alen += t.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$b = safeBufferExports$2.Buffer, Transform$4 = cipherBase, inherits$7 = inherits_browserExports;
function StreamCipher$2(e, t, a, n) {
  Transform$4.call(this), this._cipher = new aes$3.AES(t), this._prev = Buffer$b.from(a), this._cache = Buffer$b.allocUnsafe(0), this._secCache = Buffer$b.allocUnsafe(0), this._decrypt = n, this._mode = e;
}
inherits$7(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(e) {
  return this._mode.encrypt(this, e, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$a = safeBufferExports$2.Buffer, MD5 = md5_js;
function EVP_BytesToKey(e, t, a, n) {
  if (Buffer$a.isBuffer(e) || (e = Buffer$a.from(e, "binary")), t && (Buffer$a.isBuffer(t) || (t = Buffer$a.from(t, "binary")), t.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var u = a / 8, o = Buffer$a.alloc(u), l = Buffer$a.alloc(n || 0), h = Buffer$a.alloc(0); u > 0 || n > 0; ) {
    var y = new MD5();
    y.update(h), y.update(e), t && y.update(t), h = y.digest();
    var _ = 0;
    if (u > 0) {
      var d = o.length - u;
      _ = Math.min(u, h.length), h.copy(o, d, 0, _), u -= _;
    }
    if (_ < h.length && n > 0) {
      var $ = l.length - n, N = Math.min(n, h.length - _);
      h.copy(l, $, _, _ + N), n -= N;
    }
  }
  return h.fill(0), { key: o, iv: l };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$9 = safeBufferExports$2.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$6 = inherits_browserExports;
function Cipher(e, t, a) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(t), this._prev = Buffer$9.from(a), this._mode = e, this._autopadding = !0;
}
inherits$6(Cipher, Transform$3);
Cipher.prototype._update = function(e) {
  this._cache.add(e);
  for (var t, a, n = []; t = this._cache.get(); )
    a = this._mode.encrypt(this, t), n.push(a);
  return Buffer$9.concat(n);
};
var PADDING = Buffer$9.alloc(16, 16);
Cipher.prototype._final = function() {
  var e = this._cache.flush();
  if (this._autopadding)
    return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
  if (!e.equals(PADDING))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(e) {
  return this._autopadding = !!e, this;
};
function Splitter$1() {
  this.cache = Buffer$9.allocUnsafe(0);
}
Splitter$1.prototype.add = function(e) {
  this.cache = Buffer$9.concat([this.cache, e]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var e = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), e;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var e = 16 - this.cache.length, t = Buffer$9.allocUnsafe(e), a = -1; ++a < e; )
    t.writeUInt8(e, a);
  return Buffer$9.concat([this.cache, t]);
};
function createCipheriv$1(e, t, a) {
  var n = MODES$1[e.toLowerCase()];
  if (!n)
    throw new TypeError("invalid suite type");
  if (typeof t == "string" && (t = Buffer$9.from(t)), t.length !== n.key / 8)
    throw new TypeError("invalid key length " + t.length);
  if (typeof a == "string" && (a = Buffer$9.from(a)), n.mode !== "GCM" && a.length !== n.iv)
    throw new TypeError("invalid iv length " + a.length);
  return n.type === "stream" ? new StreamCipher$1(n.module, t, a) : n.type === "auth" ? new AuthCipher$1(n.module, t, a) : new Cipher(n.module, t, a);
}
function createCipher$2(e, t) {
  var a = MODES$1[e.toLowerCase()];
  if (!a)
    throw new TypeError("invalid suite type");
  var n = ebtk$2(t, !1, a.key, a.iv);
  return createCipheriv$1(e, n.key, n.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$2;
var decrypter = {}, AuthCipher = authCipher, Buffer$8 = safeBufferExports$2.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$5 = inherits_browserExports;
function Decipher(e, t, a) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(t), this._prev = Buffer$8.from(a), this._mode = e, this._autopadding = !0;
}
inherits$5(Decipher, Transform$2);
Decipher.prototype._update = function(e) {
  this._cache.add(e);
  for (var t, a, n = []; t = this._cache.get(this._autopadding); )
    a = this._mode.decrypt(this, t), n.push(a);
  return Buffer$8.concat(n);
};
Decipher.prototype._final = function() {
  var e = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, e));
  if (e)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(e) {
  return this._autopadding = !!e, this;
};
function Splitter() {
  this.cache = Buffer$8.allocUnsafe(0);
}
Splitter.prototype.add = function(e) {
  this.cache = Buffer$8.concat([this.cache, e]);
};
Splitter.prototype.get = function(e) {
  var t;
  if (e) {
    if (this.cache.length > 16)
      return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
  } else if (this.cache.length >= 16)
    return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(e) {
  var t = e[15];
  if (t < 1 || t > 16)
    throw new Error("unable to decrypt data");
  for (var a = -1; ++a < t; )
    if (e[a + (16 - t)] !== t)
      throw new Error("unable to decrypt data");
  if (t !== 16)
    return e.slice(0, 16 - t);
}
function createDecipheriv$1(e, t, a) {
  var n = MODES[e.toLowerCase()];
  if (!n)
    throw new TypeError("invalid suite type");
  if (typeof a == "string" && (a = Buffer$8.from(a)), n.mode !== "GCM" && a.length !== n.iv)
    throw new TypeError("invalid iv length " + a.length);
  if (typeof t == "string" && (t = Buffer$8.from(t)), t.length !== n.key / 8)
    throw new TypeError("invalid key length " + t.length);
  return n.type === "stream" ? new StreamCipher(n.module, t, a, !0) : n.type === "auth" ? new AuthCipher(n.module, t, a, !0) : new Decipher(n.module, t, a);
}
function createDecipher$1(e, t) {
  var a = MODES[e.toLowerCase()];
  if (!a)
    throw new TypeError("invalid suite type");
  var n = ebtk$1(t, !1, a.key, a.iv);
  return createDecipheriv$1(e, n.key, n.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$2 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$2);
}
browser$5.createCipher = browser$5.Cipher = ciphers$2.createCipher;
browser$5.createCipheriv = browser$5.Cipheriv = ciphers$2.createCipheriv;
browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
browser$5.listCiphers = browser$5.getCiphers = getCiphers$1;
var modes$1 = {};
(function(e) {
  e["des-ecb"] = {
    key: 8,
    iv: 0
  }, e["des-cbc"] = e.des = {
    key: 8,
    iv: 8
  }, e["des-ede3-cbc"] = e.des3 = {
    key: 24,
    iv: 8
  }, e["des-ede3"] = {
    key: 24,
    iv: 0
  }, e["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, e["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes$1);
var DES = browserifyDes, aes = browser$5, aesModes = modes_1, desModes = modes$1, ebtk = evp_bytestokey;
function createCipher$1(e, t) {
  e = e.toLowerCase();
  var a, n;
  if (aesModes[e])
    a = aesModes[e].key, n = aesModes[e].iv;
  else if (desModes[e])
    a = desModes[e].key * 8, n = desModes[e].iv;
  else
    throw new TypeError("invalid suite type");
  var u = ebtk(t, !1, a, n);
  return createCipheriv(e, u.key, u.iv);
}
function createDecipher(e, t) {
  e = e.toLowerCase();
  var a, n;
  if (aesModes[e])
    a = aesModes[e].key, n = aesModes[e].iv;
  else if (desModes[e])
    a = desModes[e].key * 8, n = desModes[e].iv;
  else
    throw new TypeError("invalid suite type");
  var u = ebtk(t, !1, a, n);
  return createDecipheriv(e, u.key, u.iv);
}
function createCipheriv(e, t, a) {
  if (e = e.toLowerCase(), aesModes[e])
    return aes.createCipheriv(e, t, a);
  if (desModes[e])
    return new DES({ key: t, iv: a, mode: e });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(e, t, a) {
  if (e = e.toLowerCase(), aesModes[e])
    return aes.createDecipheriv(e, t, a);
  if (desModes[e])
    return new DES({ key: t, iv: a, mode: e, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$6.createCipher = browser$6.Cipher = createCipher$1;
browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
browser$6.createDecipher = browser$6.Decipher = createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers;
var browser$4 = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(e) {
  (function(t, a) {
    function n(pe, O) {
      if (!pe)
        throw new Error(O || "Assertion failed");
    }
    function u(pe, O) {
      pe.super_ = O;
      var E = function() {
      };
      E.prototype = O.prototype, pe.prototype = new E(), pe.prototype.constructor = pe;
    }
    function o(pe, O, E) {
      if (o.isBN(pe))
        return pe;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, pe !== null && ((O === "le" || O === "be") && (E = O, O = 10), this._init(pe || 0, O || 10, E || "be"));
    }
    typeof t == "object" ? t.exports = o : a.BN = o, o.BN = o, o.wordSize = 26;
    var l;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? l = window.Buffer : l = buffer$1.Buffer;
    } catch {
    }
    o.isBN = function(O) {
      return O instanceof o ? !0 : O !== null && typeof O == "object" && O.constructor.wordSize === o.wordSize && Array.isArray(O.words);
    }, o.max = function(O, E) {
      return O.cmp(E) > 0 ? O : E;
    }, o.min = function(O, E) {
      return O.cmp(E) < 0 ? O : E;
    }, o.prototype._init = function(O, E, c) {
      if (typeof O == "number")
        return this._initNumber(O, E, c);
      if (typeof O == "object")
        return this._initArray(O, E, c);
      E === "hex" && (E = 16), n(E === (E | 0) && E >= 2 && E <= 36), O = O.toString().replace(/\s+/g, "");
      var b = 0;
      O[0] === "-" && (b++, this.negative = 1), b < O.length && (E === 16 ? this._parseHex(O, b, c) : (this._parseBase(O, E, b), c === "le" && this._initArray(this.toArray(), E, c)));
    }, o.prototype._initNumber = function(O, E, c) {
      O < 0 && (this.negative = 1, O = -O), O < 67108864 ? (this.words = [O & 67108863], this.length = 1) : O < 4503599627370496 ? (this.words = [
        O & 67108863,
        O / 67108864 & 67108863
      ], this.length = 2) : (n(O < 9007199254740992), this.words = [
        O & 67108863,
        O / 67108864 & 67108863,
        1
      ], this.length = 3), c === "le" && this._initArray(this.toArray(), E, c);
    }, o.prototype._initArray = function(O, E, c) {
      if (n(typeof O.length == "number"), O.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(O.length / 3), this.words = new Array(this.length);
      for (var b = 0; b < this.length; b++)
        this.words[b] = 0;
      var C, x, B = 0;
      if (c === "be")
        for (b = O.length - 1, C = 0; b >= 0; b -= 3)
          x = O[b] | O[b - 1] << 8 | O[b - 2] << 16, this.words[C] |= x << B & 67108863, this.words[C + 1] = x >>> 26 - B & 67108863, B += 24, B >= 26 && (B -= 26, C++);
      else if (c === "le")
        for (b = 0, C = 0; b < O.length; b += 3)
          x = O[b] | O[b + 1] << 8 | O[b + 2] << 16, this.words[C] |= x << B & 67108863, this.words[C + 1] = x >>> 26 - B & 67108863, B += 24, B >= 26 && (B -= 26, C++);
      return this.strip();
    };
    function h(pe, O) {
      var E = pe.charCodeAt(O);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function y(pe, O, E) {
      var c = h(pe, E);
      return E - 1 >= O && (c |= h(pe, E - 1) << 4), c;
    }
    o.prototype._parseHex = function(O, E, c) {
      this.length = Math.ceil((O.length - E) / 6), this.words = new Array(this.length);
      for (var b = 0; b < this.length; b++)
        this.words[b] = 0;
      var C = 0, x = 0, B;
      if (c === "be")
        for (b = O.length - 1; b >= E; b -= 2)
          B = y(O, E, b) << C, this.words[x] |= B & 67108863, C >= 18 ? (C -= 18, x += 1, this.words[x] |= B >>> 26) : C += 8;
      else {
        var k = O.length - E;
        for (b = k % 2 === 0 ? E + 1 : E; b < O.length; b += 2)
          B = y(O, E, b) << C, this.words[x] |= B & 67108863, C >= 18 ? (C -= 18, x += 1, this.words[x] |= B >>> 26) : C += 8;
      }
      this.strip();
    };
    function _(pe, O, E, c) {
      for (var b = 0, C = Math.min(pe.length, E), x = O; x < C; x++) {
        var B = pe.charCodeAt(x) - 48;
        b *= c, B >= 49 ? b += B - 49 + 10 : B >= 17 ? b += B - 17 + 10 : b += B;
      }
      return b;
    }
    o.prototype._parseBase = function(O, E, c) {
      this.words = [0], this.length = 1;
      for (var b = 0, C = 1; C <= 67108863; C *= E)
        b++;
      b--, C = C / E | 0;
      for (var x = O.length - c, B = x % b, k = Math.min(x, x - B) + c, w = 0, T = c; T < k; T += b)
        w = _(O, T, T + b, E), this.imuln(C), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
      if (B !== 0) {
        var p = 1;
        for (w = _(O, T, O.length, E), T = 0; T < B; T++)
          p *= E;
        this.imuln(p), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
      }
      this.strip();
    }, o.prototype.copy = function(O) {
      O.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        O.words[E] = this.words[E];
      O.length = this.length, O.negative = this.negative, O.red = this.red;
    }, o.prototype.clone = function() {
      var O = new o(null);
      return this.copy(O), O;
    }, o.prototype._expand = function(O) {
      for (; this.length < O; )
        this.words[this.length++] = 0;
      return this;
    }, o.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, o.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var d = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], $ = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], N = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    o.prototype.toString = function(O, E) {
      O = O || 10, E = E | 0 || 1;
      var c;
      if (O === 16 || O === "hex") {
        c = "";
        for (var b = 0, C = 0, x = 0; x < this.length; x++) {
          var B = this.words[x], k = ((B << b | C) & 16777215).toString(16);
          C = B >>> 24 - b & 16777215, b += 2, b >= 26 && (b -= 26, x--), C !== 0 || x !== this.length - 1 ? c = d[6 - k.length] + k + c : c = k + c;
        }
        for (C !== 0 && (c = C.toString(16) + c); c.length % E !== 0; )
          c = "0" + c;
        return this.negative !== 0 && (c = "-" + c), c;
      }
      if (O === (O | 0) && O >= 2 && O <= 36) {
        var w = $[O], T = N[O];
        c = "";
        var p = this.clone();
        for (p.negative = 0; !p.isZero(); ) {
          var F = p.modn(T).toString(O);
          p = p.idivn(T), p.isZero() ? c = F + c : c = d[w - F.length] + F + c;
        }
        for (this.isZero() && (c = "0" + c); c.length % E !== 0; )
          c = "0" + c;
        return this.negative !== 0 && (c = "-" + c), c;
      }
      n(!1, "Base should be between 2 and 36");
    }, o.prototype.toNumber = function() {
      var O = this.words[0];
      return this.length === 2 ? O += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? O += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -O : O;
    }, o.prototype.toJSON = function() {
      return this.toString(16);
    }, o.prototype.toBuffer = function(O, E) {
      return n(typeof l < "u"), this.toArrayLike(l, O, E);
    }, o.prototype.toArray = function(O, E) {
      return this.toArrayLike(Array, O, E);
    }, o.prototype.toArrayLike = function(O, E, c) {
      var b = this.byteLength(), C = c || Math.max(1, b);
      n(b <= C, "byte array longer than desired length"), n(C > 0, "Requested array length <= 0"), this.strip();
      var x = E === "le", B = new O(C), k, w, T = this.clone();
      if (x) {
        for (w = 0; !T.isZero(); w++)
          k = T.andln(255), T.iushrn(8), B[w] = k;
        for (; w < C; w++)
          B[w] = 0;
      } else {
        for (w = 0; w < C - b; w++)
          B[w] = 0;
        for (w = 0; !T.isZero(); w++)
          k = T.andln(255), T.iushrn(8), B[C - w - 1] = k;
      }
      return B;
    }, Math.clz32 ? o.prototype._countBits = function(O) {
      return 32 - Math.clz32(O);
    } : o.prototype._countBits = function(O) {
      var E = O, c = 0;
      return E >= 4096 && (c += 13, E >>>= 13), E >= 64 && (c += 7, E >>>= 7), E >= 8 && (c += 4, E >>>= 4), E >= 2 && (c += 2, E >>>= 2), c + E;
    }, o.prototype._zeroBits = function(O) {
      if (O === 0)
        return 26;
      var E = O, c = 0;
      return E & 8191 || (c += 13, E >>>= 13), E & 127 || (c += 7, E >>>= 7), E & 15 || (c += 4, E >>>= 4), E & 3 || (c += 2, E >>>= 2), E & 1 || c++, c;
    }, o.prototype.bitLength = function() {
      var O = this.words[this.length - 1], E = this._countBits(O);
      return (this.length - 1) * 26 + E;
    };
    function U(pe) {
      for (var O = new Array(pe.bitLength()), E = 0; E < O.length; E++) {
        var c = E / 26 | 0, b = E % 26;
        O[E] = (pe.words[c] & 1 << b) >>> b;
      }
      return O;
    }
    o.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var O = 0, E = 0; E < this.length; E++) {
        var c = this._zeroBits(this.words[E]);
        if (O += c, c !== 26)
          break;
      }
      return O;
    }, o.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o.prototype.toTwos = function(O) {
      return this.negative !== 0 ? this.abs().inotn(O).iaddn(1) : this.clone();
    }, o.prototype.fromTwos = function(O) {
      return this.testn(O - 1) ? this.notn(O).iaddn(1).ineg() : this.clone();
    }, o.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o.prototype.neg = function() {
      return this.clone().ineg();
    }, o.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o.prototype.iuor = function(O) {
      for (; this.length < O.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < O.length; E++)
        this.words[E] = this.words[E] | O.words[E];
      return this.strip();
    }, o.prototype.ior = function(O) {
      return n((this.negative | O.negative) === 0), this.iuor(O);
    }, o.prototype.or = function(O) {
      return this.length > O.length ? this.clone().ior(O) : O.clone().ior(this);
    }, o.prototype.uor = function(O) {
      return this.length > O.length ? this.clone().iuor(O) : O.clone().iuor(this);
    }, o.prototype.iuand = function(O) {
      var E;
      this.length > O.length ? E = O : E = this;
      for (var c = 0; c < E.length; c++)
        this.words[c] = this.words[c] & O.words[c];
      return this.length = E.length, this.strip();
    }, o.prototype.iand = function(O) {
      return n((this.negative | O.negative) === 0), this.iuand(O);
    }, o.prototype.and = function(O) {
      return this.length > O.length ? this.clone().iand(O) : O.clone().iand(this);
    }, o.prototype.uand = function(O) {
      return this.length > O.length ? this.clone().iuand(O) : O.clone().iuand(this);
    }, o.prototype.iuxor = function(O) {
      var E, c;
      this.length > O.length ? (E = this, c = O) : (E = O, c = this);
      for (var b = 0; b < c.length; b++)
        this.words[b] = E.words[b] ^ c.words[b];
      if (this !== E)
        for (; b < E.length; b++)
          this.words[b] = E.words[b];
      return this.length = E.length, this.strip();
    }, o.prototype.ixor = function(O) {
      return n((this.negative | O.negative) === 0), this.iuxor(O);
    }, o.prototype.xor = function(O) {
      return this.length > O.length ? this.clone().ixor(O) : O.clone().ixor(this);
    }, o.prototype.uxor = function(O) {
      return this.length > O.length ? this.clone().iuxor(O) : O.clone().iuxor(this);
    }, o.prototype.inotn = function(O) {
      n(typeof O == "number" && O >= 0);
      var E = Math.ceil(O / 26) | 0, c = O % 26;
      this._expand(E), c > 0 && E--;
      for (var b = 0; b < E; b++)
        this.words[b] = ~this.words[b] & 67108863;
      return c > 0 && (this.words[b] = ~this.words[b] & 67108863 >> 26 - c), this.strip();
    }, o.prototype.notn = function(O) {
      return this.clone().inotn(O);
    }, o.prototype.setn = function(O, E) {
      n(typeof O == "number" && O >= 0);
      var c = O / 26 | 0, b = O % 26;
      return this._expand(c + 1), E ? this.words[c] = this.words[c] | 1 << b : this.words[c] = this.words[c] & ~(1 << b), this.strip();
    }, o.prototype.iadd = function(O) {
      var E;
      if (this.negative !== 0 && O.negative === 0)
        return this.negative = 0, E = this.isub(O), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && O.negative !== 0)
        return O.negative = 0, E = this.isub(O), O.negative = 1, E._normSign();
      var c, b;
      this.length > O.length ? (c = this, b = O) : (c = O, b = this);
      for (var C = 0, x = 0; x < b.length; x++)
        E = (c.words[x] | 0) + (b.words[x] | 0) + C, this.words[x] = E & 67108863, C = E >>> 26;
      for (; C !== 0 && x < c.length; x++)
        E = (c.words[x] | 0) + C, this.words[x] = E & 67108863, C = E >>> 26;
      if (this.length = c.length, C !== 0)
        this.words[this.length] = C, this.length++;
      else if (c !== this)
        for (; x < c.length; x++)
          this.words[x] = c.words[x];
      return this;
    }, o.prototype.add = function(O) {
      var E;
      return O.negative !== 0 && this.negative === 0 ? (O.negative = 0, E = this.sub(O), O.negative ^= 1, E) : O.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = O.sub(this), this.negative = 1, E) : this.length > O.length ? this.clone().iadd(O) : O.clone().iadd(this);
    }, o.prototype.isub = function(O) {
      if (O.negative !== 0) {
        O.negative = 0;
        var E = this.iadd(O);
        return O.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(O), this.negative = 1, this._normSign();
      var c = this.cmp(O);
      if (c === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var b, C;
      c > 0 ? (b = this, C = O) : (b = O, C = this);
      for (var x = 0, B = 0; B < C.length; B++)
        E = (b.words[B] | 0) - (C.words[B] | 0) + x, x = E >> 26, this.words[B] = E & 67108863;
      for (; x !== 0 && B < b.length; B++)
        E = (b.words[B] | 0) + x, x = E >> 26, this.words[B] = E & 67108863;
      if (x === 0 && B < b.length && b !== this)
        for (; B < b.length; B++)
          this.words[B] = b.words[B];
      return this.length = Math.max(this.length, B), b !== this && (this.negative = 1), this.strip();
    }, o.prototype.sub = function(O) {
      return this.clone().isub(O);
    };
    function V(pe, O, E) {
      E.negative = O.negative ^ pe.negative;
      var c = pe.length + O.length | 0;
      E.length = c, c = c - 1 | 0;
      var b = pe.words[0] | 0, C = O.words[0] | 0, x = b * C, B = x & 67108863, k = x / 67108864 | 0;
      E.words[0] = B;
      for (var w = 1; w < c; w++) {
        for (var T = k >>> 26, p = k & 67108863, F = Math.min(w, O.length - 1), ye = Math.max(0, w - pe.length + 1); ye <= F; ye++) {
          var _e = w - ye | 0;
          b = pe.words[_e] | 0, C = O.words[ye] | 0, x = b * C + p, T += x / 67108864 | 0, p = x & 67108863;
        }
        E.words[w] = p | 0, k = T | 0;
      }
      return k !== 0 ? E.words[w] = k | 0 : E.length--, E.strip();
    }
    var Q = function(O, E, c) {
      var b = O.words, C = E.words, x = c.words, B = 0, k, w, T, p = b[0] | 0, F = p & 8191, ye = p >>> 13, _e = b[1] | 0, de = _e & 8191, P = _e >>> 13, H = b[2] | 0, he = H & 8191, me = H >>> 13, fe = b[3] | 0, re = fe & 8191, we = fe >>> 13, ke = b[4] | 0, Oe = ke & 8191, ce = ke >>> 13, j = b[5] | 0, z = j & 8191, oe = j >>> 13, Be = b[6] | 0, Te = Be & 8191, Pe = Be >>> 13, Ye = b[7] | 0, He = Ye & 8191, ot = Ye >>> 13, at = b[8] | 0, Qe = at & 8191, Pt = at >>> 13, It = b[9] | 0, pt = It & 8191, Wt = It >>> 13, Mt = C[0] | 0, vt = Mt & 8191, Vt = Mt >>> 13, Ct = C[1] | 0, lt = Ct & 8191, zt = Ct >>> 13, Tt = C[2] | 0, dt = Tt & 8191, Yt = Tt >>> 13, Dt = C[3] | 0, bt = Dt & 8191, Jt = Dt >>> 13, Bt = C[4] | 0, ut = Bt & 8191, Ht = Bt >>> 13, Rt = C[5] | 0, gt = Rt & 8191, Qt = Rt >>> 13, kt = C[6] | 0, rt = kt & 8191, Xt = kt >>> 13, J = C[7] | 0, ae = J & 8191, ue = J >>> 13, q = C[8] | 0, le = q & 8191, Ce = q >>> 13, Se = C[9] | 0, Ie = Se & 8191, Ve = Se >>> 13;
      c.negative = O.negative ^ E.negative, c.length = 19, k = Math.imul(F, vt), w = Math.imul(F, Vt), w = w + Math.imul(ye, vt) | 0, T = Math.imul(ye, Vt);
      var Ge = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, k = Math.imul(de, vt), w = Math.imul(de, Vt), w = w + Math.imul(P, vt) | 0, T = Math.imul(P, Vt), k = k + Math.imul(F, lt) | 0, w = w + Math.imul(F, zt) | 0, w = w + Math.imul(ye, lt) | 0, T = T + Math.imul(ye, zt) | 0;
      var qe = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, k = Math.imul(he, vt), w = Math.imul(he, Vt), w = w + Math.imul(me, vt) | 0, T = Math.imul(me, Vt), k = k + Math.imul(de, lt) | 0, w = w + Math.imul(de, zt) | 0, w = w + Math.imul(P, lt) | 0, T = T + Math.imul(P, zt) | 0, k = k + Math.imul(F, dt) | 0, w = w + Math.imul(F, Yt) | 0, w = w + Math.imul(ye, dt) | 0, T = T + Math.imul(ye, Yt) | 0;
      var Nt = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, k = Math.imul(re, vt), w = Math.imul(re, Vt), w = w + Math.imul(we, vt) | 0, T = Math.imul(we, Vt), k = k + Math.imul(he, lt) | 0, w = w + Math.imul(he, zt) | 0, w = w + Math.imul(me, lt) | 0, T = T + Math.imul(me, zt) | 0, k = k + Math.imul(de, dt) | 0, w = w + Math.imul(de, Yt) | 0, w = w + Math.imul(P, dt) | 0, T = T + Math.imul(P, Yt) | 0, k = k + Math.imul(F, bt) | 0, w = w + Math.imul(F, Jt) | 0, w = w + Math.imul(ye, bt) | 0, T = T + Math.imul(ye, Jt) | 0;
      var et = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, k = Math.imul(Oe, vt), w = Math.imul(Oe, Vt), w = w + Math.imul(ce, vt) | 0, T = Math.imul(ce, Vt), k = k + Math.imul(re, lt) | 0, w = w + Math.imul(re, zt) | 0, w = w + Math.imul(we, lt) | 0, T = T + Math.imul(we, zt) | 0, k = k + Math.imul(he, dt) | 0, w = w + Math.imul(he, Yt) | 0, w = w + Math.imul(me, dt) | 0, T = T + Math.imul(me, Yt) | 0, k = k + Math.imul(de, bt) | 0, w = w + Math.imul(de, Jt) | 0, w = w + Math.imul(P, bt) | 0, T = T + Math.imul(P, Jt) | 0, k = k + Math.imul(F, ut) | 0, w = w + Math.imul(F, Ht) | 0, w = w + Math.imul(ye, ut) | 0, T = T + Math.imul(ye, Ht) | 0;
      var _t = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, k = Math.imul(z, vt), w = Math.imul(z, Vt), w = w + Math.imul(oe, vt) | 0, T = Math.imul(oe, Vt), k = k + Math.imul(Oe, lt) | 0, w = w + Math.imul(Oe, zt) | 0, w = w + Math.imul(ce, lt) | 0, T = T + Math.imul(ce, zt) | 0, k = k + Math.imul(re, dt) | 0, w = w + Math.imul(re, Yt) | 0, w = w + Math.imul(we, dt) | 0, T = T + Math.imul(we, Yt) | 0, k = k + Math.imul(he, bt) | 0, w = w + Math.imul(he, Jt) | 0, w = w + Math.imul(me, bt) | 0, T = T + Math.imul(me, Jt) | 0, k = k + Math.imul(de, ut) | 0, w = w + Math.imul(de, Ht) | 0, w = w + Math.imul(P, ut) | 0, T = T + Math.imul(P, Ht) | 0, k = k + Math.imul(F, gt) | 0, w = w + Math.imul(F, Qt) | 0, w = w + Math.imul(ye, gt) | 0, T = T + Math.imul(ye, Qt) | 0;
      var $t = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, k = Math.imul(Te, vt), w = Math.imul(Te, Vt), w = w + Math.imul(Pe, vt) | 0, T = Math.imul(Pe, Vt), k = k + Math.imul(z, lt) | 0, w = w + Math.imul(z, zt) | 0, w = w + Math.imul(oe, lt) | 0, T = T + Math.imul(oe, zt) | 0, k = k + Math.imul(Oe, dt) | 0, w = w + Math.imul(Oe, Yt) | 0, w = w + Math.imul(ce, dt) | 0, T = T + Math.imul(ce, Yt) | 0, k = k + Math.imul(re, bt) | 0, w = w + Math.imul(re, Jt) | 0, w = w + Math.imul(we, bt) | 0, T = T + Math.imul(we, Jt) | 0, k = k + Math.imul(he, ut) | 0, w = w + Math.imul(he, Ht) | 0, w = w + Math.imul(me, ut) | 0, T = T + Math.imul(me, Ht) | 0, k = k + Math.imul(de, gt) | 0, w = w + Math.imul(de, Qt) | 0, w = w + Math.imul(P, gt) | 0, T = T + Math.imul(P, Qt) | 0, k = k + Math.imul(F, rt) | 0, w = w + Math.imul(F, Xt) | 0, w = w + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, Xt) | 0;
      var St = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, k = Math.imul(He, vt), w = Math.imul(He, Vt), w = w + Math.imul(ot, vt) | 0, T = Math.imul(ot, Vt), k = k + Math.imul(Te, lt) | 0, w = w + Math.imul(Te, zt) | 0, w = w + Math.imul(Pe, lt) | 0, T = T + Math.imul(Pe, zt) | 0, k = k + Math.imul(z, dt) | 0, w = w + Math.imul(z, Yt) | 0, w = w + Math.imul(oe, dt) | 0, T = T + Math.imul(oe, Yt) | 0, k = k + Math.imul(Oe, bt) | 0, w = w + Math.imul(Oe, Jt) | 0, w = w + Math.imul(ce, bt) | 0, T = T + Math.imul(ce, Jt) | 0, k = k + Math.imul(re, ut) | 0, w = w + Math.imul(re, Ht) | 0, w = w + Math.imul(we, ut) | 0, T = T + Math.imul(we, Ht) | 0, k = k + Math.imul(he, gt) | 0, w = w + Math.imul(he, Qt) | 0, w = w + Math.imul(me, gt) | 0, T = T + Math.imul(me, Qt) | 0, k = k + Math.imul(de, rt) | 0, w = w + Math.imul(de, Xt) | 0, w = w + Math.imul(P, rt) | 0, T = T + Math.imul(P, Xt) | 0, k = k + Math.imul(F, ae) | 0, w = w + Math.imul(F, ue) | 0, w = w + Math.imul(ye, ae) | 0, T = T + Math.imul(ye, ue) | 0;
      var mt = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, k = Math.imul(Qe, vt), w = Math.imul(Qe, Vt), w = w + Math.imul(Pt, vt) | 0, T = Math.imul(Pt, Vt), k = k + Math.imul(He, lt) | 0, w = w + Math.imul(He, zt) | 0, w = w + Math.imul(ot, lt) | 0, T = T + Math.imul(ot, zt) | 0, k = k + Math.imul(Te, dt) | 0, w = w + Math.imul(Te, Yt) | 0, w = w + Math.imul(Pe, dt) | 0, T = T + Math.imul(Pe, Yt) | 0, k = k + Math.imul(z, bt) | 0, w = w + Math.imul(z, Jt) | 0, w = w + Math.imul(oe, bt) | 0, T = T + Math.imul(oe, Jt) | 0, k = k + Math.imul(Oe, ut) | 0, w = w + Math.imul(Oe, Ht) | 0, w = w + Math.imul(ce, ut) | 0, T = T + Math.imul(ce, Ht) | 0, k = k + Math.imul(re, gt) | 0, w = w + Math.imul(re, Qt) | 0, w = w + Math.imul(we, gt) | 0, T = T + Math.imul(we, Qt) | 0, k = k + Math.imul(he, rt) | 0, w = w + Math.imul(he, Xt) | 0, w = w + Math.imul(me, rt) | 0, T = T + Math.imul(me, Xt) | 0, k = k + Math.imul(de, ae) | 0, w = w + Math.imul(de, ue) | 0, w = w + Math.imul(P, ae) | 0, T = T + Math.imul(P, ue) | 0, k = k + Math.imul(F, le) | 0, w = w + Math.imul(F, Ce) | 0, w = w + Math.imul(ye, le) | 0, T = T + Math.imul(ye, Ce) | 0;
      var xt = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, k = Math.imul(pt, vt), w = Math.imul(pt, Vt), w = w + Math.imul(Wt, vt) | 0, T = Math.imul(Wt, Vt), k = k + Math.imul(Qe, lt) | 0, w = w + Math.imul(Qe, zt) | 0, w = w + Math.imul(Pt, lt) | 0, T = T + Math.imul(Pt, zt) | 0, k = k + Math.imul(He, dt) | 0, w = w + Math.imul(He, Yt) | 0, w = w + Math.imul(ot, dt) | 0, T = T + Math.imul(ot, Yt) | 0, k = k + Math.imul(Te, bt) | 0, w = w + Math.imul(Te, Jt) | 0, w = w + Math.imul(Pe, bt) | 0, T = T + Math.imul(Pe, Jt) | 0, k = k + Math.imul(z, ut) | 0, w = w + Math.imul(z, Ht) | 0, w = w + Math.imul(oe, ut) | 0, T = T + Math.imul(oe, Ht) | 0, k = k + Math.imul(Oe, gt) | 0, w = w + Math.imul(Oe, Qt) | 0, w = w + Math.imul(ce, gt) | 0, T = T + Math.imul(ce, Qt) | 0, k = k + Math.imul(re, rt) | 0, w = w + Math.imul(re, Xt) | 0, w = w + Math.imul(we, rt) | 0, T = T + Math.imul(we, Xt) | 0, k = k + Math.imul(he, ae) | 0, w = w + Math.imul(he, ue) | 0, w = w + Math.imul(me, ae) | 0, T = T + Math.imul(me, ue) | 0, k = k + Math.imul(de, le) | 0, w = w + Math.imul(de, Ce) | 0, w = w + Math.imul(P, le) | 0, T = T + Math.imul(P, Ce) | 0, k = k + Math.imul(F, Ie) | 0, w = w + Math.imul(F, Ve) | 0, w = w + Math.imul(ye, Ie) | 0, T = T + Math.imul(ye, Ve) | 0;
      var Et = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, k = Math.imul(pt, lt), w = Math.imul(pt, zt), w = w + Math.imul(Wt, lt) | 0, T = Math.imul(Wt, zt), k = k + Math.imul(Qe, dt) | 0, w = w + Math.imul(Qe, Yt) | 0, w = w + Math.imul(Pt, dt) | 0, T = T + Math.imul(Pt, Yt) | 0, k = k + Math.imul(He, bt) | 0, w = w + Math.imul(He, Jt) | 0, w = w + Math.imul(ot, bt) | 0, T = T + Math.imul(ot, Jt) | 0, k = k + Math.imul(Te, ut) | 0, w = w + Math.imul(Te, Ht) | 0, w = w + Math.imul(Pe, ut) | 0, T = T + Math.imul(Pe, Ht) | 0, k = k + Math.imul(z, gt) | 0, w = w + Math.imul(z, Qt) | 0, w = w + Math.imul(oe, gt) | 0, T = T + Math.imul(oe, Qt) | 0, k = k + Math.imul(Oe, rt) | 0, w = w + Math.imul(Oe, Xt) | 0, w = w + Math.imul(ce, rt) | 0, T = T + Math.imul(ce, Xt) | 0, k = k + Math.imul(re, ae) | 0, w = w + Math.imul(re, ue) | 0, w = w + Math.imul(we, ae) | 0, T = T + Math.imul(we, ue) | 0, k = k + Math.imul(he, le) | 0, w = w + Math.imul(he, Ce) | 0, w = w + Math.imul(me, le) | 0, T = T + Math.imul(me, Ce) | 0, k = k + Math.imul(de, Ie) | 0, w = w + Math.imul(de, Ve) | 0, w = w + Math.imul(P, Ie) | 0, T = T + Math.imul(P, Ve) | 0;
      var wt = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, k = Math.imul(pt, dt), w = Math.imul(pt, Yt), w = w + Math.imul(Wt, dt) | 0, T = Math.imul(Wt, Yt), k = k + Math.imul(Qe, bt) | 0, w = w + Math.imul(Qe, Jt) | 0, w = w + Math.imul(Pt, bt) | 0, T = T + Math.imul(Pt, Jt) | 0, k = k + Math.imul(He, ut) | 0, w = w + Math.imul(He, Ht) | 0, w = w + Math.imul(ot, ut) | 0, T = T + Math.imul(ot, Ht) | 0, k = k + Math.imul(Te, gt) | 0, w = w + Math.imul(Te, Qt) | 0, w = w + Math.imul(Pe, gt) | 0, T = T + Math.imul(Pe, Qt) | 0, k = k + Math.imul(z, rt) | 0, w = w + Math.imul(z, Xt) | 0, w = w + Math.imul(oe, rt) | 0, T = T + Math.imul(oe, Xt) | 0, k = k + Math.imul(Oe, ae) | 0, w = w + Math.imul(Oe, ue) | 0, w = w + Math.imul(ce, ae) | 0, T = T + Math.imul(ce, ue) | 0, k = k + Math.imul(re, le) | 0, w = w + Math.imul(re, Ce) | 0, w = w + Math.imul(we, le) | 0, T = T + Math.imul(we, Ce) | 0, k = k + Math.imul(he, Ie) | 0, w = w + Math.imul(he, Ve) | 0, w = w + Math.imul(me, Ie) | 0, T = T + Math.imul(me, Ve) | 0;
      var tt = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, k = Math.imul(pt, bt), w = Math.imul(pt, Jt), w = w + Math.imul(Wt, bt) | 0, T = Math.imul(Wt, Jt), k = k + Math.imul(Qe, ut) | 0, w = w + Math.imul(Qe, Ht) | 0, w = w + Math.imul(Pt, ut) | 0, T = T + Math.imul(Pt, Ht) | 0, k = k + Math.imul(He, gt) | 0, w = w + Math.imul(He, Qt) | 0, w = w + Math.imul(ot, gt) | 0, T = T + Math.imul(ot, Qt) | 0, k = k + Math.imul(Te, rt) | 0, w = w + Math.imul(Te, Xt) | 0, w = w + Math.imul(Pe, rt) | 0, T = T + Math.imul(Pe, Xt) | 0, k = k + Math.imul(z, ae) | 0, w = w + Math.imul(z, ue) | 0, w = w + Math.imul(oe, ae) | 0, T = T + Math.imul(oe, ue) | 0, k = k + Math.imul(Oe, le) | 0, w = w + Math.imul(Oe, Ce) | 0, w = w + Math.imul(ce, le) | 0, T = T + Math.imul(ce, Ce) | 0, k = k + Math.imul(re, Ie) | 0, w = w + Math.imul(re, Ve) | 0, w = w + Math.imul(we, Ie) | 0, T = T + Math.imul(we, Ve) | 0;
      var ht = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, k = Math.imul(pt, ut), w = Math.imul(pt, Ht), w = w + Math.imul(Wt, ut) | 0, T = Math.imul(Wt, Ht), k = k + Math.imul(Qe, gt) | 0, w = w + Math.imul(Qe, Qt) | 0, w = w + Math.imul(Pt, gt) | 0, T = T + Math.imul(Pt, Qt) | 0, k = k + Math.imul(He, rt) | 0, w = w + Math.imul(He, Xt) | 0, w = w + Math.imul(ot, rt) | 0, T = T + Math.imul(ot, Xt) | 0, k = k + Math.imul(Te, ae) | 0, w = w + Math.imul(Te, ue) | 0, w = w + Math.imul(Pe, ae) | 0, T = T + Math.imul(Pe, ue) | 0, k = k + Math.imul(z, le) | 0, w = w + Math.imul(z, Ce) | 0, w = w + Math.imul(oe, le) | 0, T = T + Math.imul(oe, Ce) | 0, k = k + Math.imul(Oe, Ie) | 0, w = w + Math.imul(Oe, Ve) | 0, w = w + Math.imul(ce, Ie) | 0, T = T + Math.imul(ce, Ve) | 0;
      var Je = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, k = Math.imul(pt, gt), w = Math.imul(pt, Qt), w = w + Math.imul(Wt, gt) | 0, T = Math.imul(Wt, Qt), k = k + Math.imul(Qe, rt) | 0, w = w + Math.imul(Qe, Xt) | 0, w = w + Math.imul(Pt, rt) | 0, T = T + Math.imul(Pt, Xt) | 0, k = k + Math.imul(He, ae) | 0, w = w + Math.imul(He, ue) | 0, w = w + Math.imul(ot, ae) | 0, T = T + Math.imul(ot, ue) | 0, k = k + Math.imul(Te, le) | 0, w = w + Math.imul(Te, Ce) | 0, w = w + Math.imul(Pe, le) | 0, T = T + Math.imul(Pe, Ce) | 0, k = k + Math.imul(z, Ie) | 0, w = w + Math.imul(z, Ve) | 0, w = w + Math.imul(oe, Ie) | 0, T = T + Math.imul(oe, Ve) | 0;
      var it = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, k = Math.imul(pt, rt), w = Math.imul(pt, Xt), w = w + Math.imul(Wt, rt) | 0, T = Math.imul(Wt, Xt), k = k + Math.imul(Qe, ae) | 0, w = w + Math.imul(Qe, ue) | 0, w = w + Math.imul(Pt, ae) | 0, T = T + Math.imul(Pt, ue) | 0, k = k + Math.imul(He, le) | 0, w = w + Math.imul(He, Ce) | 0, w = w + Math.imul(ot, le) | 0, T = T + Math.imul(ot, Ce) | 0, k = k + Math.imul(Te, Ie) | 0, w = w + Math.imul(Te, Ve) | 0, w = w + Math.imul(Pe, Ie) | 0, T = T + Math.imul(Pe, Ve) | 0;
      var nt = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, k = Math.imul(pt, ae), w = Math.imul(pt, ue), w = w + Math.imul(Wt, ae) | 0, T = Math.imul(Wt, ue), k = k + Math.imul(Qe, le) | 0, w = w + Math.imul(Qe, Ce) | 0, w = w + Math.imul(Pt, le) | 0, T = T + Math.imul(Pt, Ce) | 0, k = k + Math.imul(He, Ie) | 0, w = w + Math.imul(He, Ve) | 0, w = w + Math.imul(ot, Ie) | 0, T = T + Math.imul(ot, Ve) | 0;
      var Ze = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, k = Math.imul(pt, le), w = Math.imul(pt, Ce), w = w + Math.imul(Wt, le) | 0, T = Math.imul(Wt, Ce), k = k + Math.imul(Qe, Ie) | 0, w = w + Math.imul(Qe, Ve) | 0, w = w + Math.imul(Pt, Ie) | 0, T = T + Math.imul(Pt, Ve) | 0;
      var Me = (B + k | 0) + ((w & 8191) << 13) | 0;
      B = (T + (w >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, k = Math.imul(pt, Ie), w = Math.imul(pt, Ve), w = w + Math.imul(Wt, Ie) | 0, T = Math.imul(Wt, Ve);
      var De = (B + k | 0) + ((w & 8191) << 13) | 0;
      return B = (T + (w >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, x[0] = Ge, x[1] = qe, x[2] = Nt, x[3] = et, x[4] = _t, x[5] = $t, x[6] = St, x[7] = mt, x[8] = xt, x[9] = Et, x[10] = wt, x[11] = tt, x[12] = ht, x[13] = Je, x[14] = it, x[15] = nt, x[16] = Ze, x[17] = Me, x[18] = De, B !== 0 && (x[19] = B, c.length++), c;
    };
    Math.imul || (Q = V);
    function ie(pe, O, E) {
      E.negative = O.negative ^ pe.negative, E.length = pe.length + O.length;
      for (var c = 0, b = 0, C = 0; C < E.length - 1; C++) {
        var x = b;
        b = 0;
        for (var B = c & 67108863, k = Math.min(C, O.length - 1), w = Math.max(0, C - pe.length + 1); w <= k; w++) {
          var T = C - w, p = pe.words[T] | 0, F = O.words[w] | 0, ye = p * F, _e = ye & 67108863;
          x = x + (ye / 67108864 | 0) | 0, _e = _e + B | 0, B = _e & 67108863, x = x + (_e >>> 26) | 0, b += x >>> 26, x &= 67108863;
        }
        E.words[C] = B, c = x, x = b;
      }
      return c !== 0 ? E.words[C] = c : E.length--, E.strip();
    }
    function ee(pe, O, E) {
      var c = new ne();
      return c.mulp(pe, O, E);
    }
    o.prototype.mulTo = function(O, E) {
      var c, b = this.length + O.length;
      return this.length === 10 && O.length === 10 ? c = Q(this, O, E) : b < 63 ? c = V(this, O, E) : b < 1024 ? c = ie(this, O, E) : c = ee(this, O, E), c;
    };
    function ne(pe, O) {
      this.x = pe, this.y = O;
    }
    ne.prototype.makeRBT = function(O) {
      for (var E = new Array(O), c = o.prototype._countBits(O) - 1, b = 0; b < O; b++)
        E[b] = this.revBin(b, c, O);
      return E;
    }, ne.prototype.revBin = function(O, E, c) {
      if (O === 0 || O === c - 1)
        return O;
      for (var b = 0, C = 0; C < E; C++)
        b |= (O & 1) << E - C - 1, O >>= 1;
      return b;
    }, ne.prototype.permute = function(O, E, c, b, C, x) {
      for (var B = 0; B < x; B++)
        b[B] = E[O[B]], C[B] = c[O[B]];
    }, ne.prototype.transform = function(O, E, c, b, C, x) {
      this.permute(x, O, E, c, b, C);
      for (var B = 1; B < C; B <<= 1)
        for (var k = B << 1, w = Math.cos(2 * Math.PI / k), T = Math.sin(2 * Math.PI / k), p = 0; p < C; p += k)
          for (var F = w, ye = T, _e = 0; _e < B; _e++) {
            var de = c[p + _e], P = b[p + _e], H = c[p + _e + B], he = b[p + _e + B], me = F * H - ye * he;
            he = F * he + ye * H, H = me, c[p + _e] = de + H, b[p + _e] = P + he, c[p + _e + B] = de - H, b[p + _e + B] = P - he, _e !== k && (me = w * F - T * ye, ye = w * ye + T * F, F = me);
          }
    }, ne.prototype.guessLen13b = function(O, E) {
      var c = Math.max(E, O) | 1, b = c & 1, C = 0;
      for (c = c / 2 | 0; c; c = c >>> 1)
        C++;
      return 1 << C + 1 + b;
    }, ne.prototype.conjugate = function(O, E, c) {
      if (!(c <= 1))
        for (var b = 0; b < c / 2; b++) {
          var C = O[b];
          O[b] = O[c - b - 1], O[c - b - 1] = C, C = E[b], E[b] = -E[c - b - 1], E[c - b - 1] = -C;
        }
    }, ne.prototype.normalize13b = function(O, E) {
      for (var c = 0, b = 0; b < E / 2; b++) {
        var C = Math.round(O[2 * b + 1] / E) * 8192 + Math.round(O[2 * b] / E) + c;
        O[b] = C & 67108863, C < 67108864 ? c = 0 : c = C / 67108864 | 0;
      }
      return O;
    }, ne.prototype.convert13b = function(O, E, c, b) {
      for (var C = 0, x = 0; x < E; x++)
        C = C + (O[x] | 0), c[2 * x] = C & 8191, C = C >>> 13, c[2 * x + 1] = C & 8191, C = C >>> 13;
      for (x = 2 * E; x < b; ++x)
        c[x] = 0;
      n(C === 0), n((C & -8192) === 0);
    }, ne.prototype.stub = function(O) {
      for (var E = new Array(O), c = 0; c < O; c++)
        E[c] = 0;
      return E;
    }, ne.prototype.mulp = function(O, E, c) {
      var b = 2 * this.guessLen13b(O.length, E.length), C = this.makeRBT(b), x = this.stub(b), B = new Array(b), k = new Array(b), w = new Array(b), T = new Array(b), p = new Array(b), F = new Array(b), ye = c.words;
      ye.length = b, this.convert13b(O.words, O.length, B, b), this.convert13b(E.words, E.length, T, b), this.transform(B, x, k, w, b, C), this.transform(T, x, p, F, b, C);
      for (var _e = 0; _e < b; _e++) {
        var de = k[_e] * p[_e] - w[_e] * F[_e];
        w[_e] = k[_e] * F[_e] + w[_e] * p[_e], k[_e] = de;
      }
      return this.conjugate(k, w, b), this.transform(k, w, ye, x, b, C), this.conjugate(ye, x, b), this.normalize13b(ye, b), c.negative = O.negative ^ E.negative, c.length = O.length + E.length, c.strip();
    }, o.prototype.mul = function(O) {
      var E = new o(null);
      return E.words = new Array(this.length + O.length), this.mulTo(O, E);
    }, o.prototype.mulf = function(O) {
      var E = new o(null);
      return E.words = new Array(this.length + O.length), ee(this, O, E);
    }, o.prototype.imul = function(O) {
      return this.clone().mulTo(O, this);
    }, o.prototype.imuln = function(O) {
      n(typeof O == "number"), n(O < 67108864);
      for (var E = 0, c = 0; c < this.length; c++) {
        var b = (this.words[c] | 0) * O, C = (b & 67108863) + (E & 67108863);
        E >>= 26, E += b / 67108864 | 0, E += C >>> 26, this.words[c] = C & 67108863;
      }
      return E !== 0 && (this.words[c] = E, this.length++), this.length = O === 0 ? 1 : this.length, this;
    }, o.prototype.muln = function(O) {
      return this.clone().imuln(O);
    }, o.prototype.sqr = function() {
      return this.mul(this);
    }, o.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o.prototype.pow = function(O) {
      var E = U(O);
      if (E.length === 0)
        return new o(1);
      for (var c = this, b = 0; b < E.length && E[b] === 0; b++, c = c.sqr())
        ;
      if (++b < E.length)
        for (var C = c.sqr(); b < E.length; b++, C = C.sqr())
          E[b] !== 0 && (c = c.mul(C));
      return c;
    }, o.prototype.iushln = function(O) {
      n(typeof O == "number" && O >= 0);
      var E = O % 26, c = (O - E) / 26, b = 67108863 >>> 26 - E << 26 - E, C;
      if (E !== 0) {
        var x = 0;
        for (C = 0; C < this.length; C++) {
          var B = this.words[C] & b, k = (this.words[C] | 0) - B << E;
          this.words[C] = k | x, x = B >>> 26 - E;
        }
        x && (this.words[C] = x, this.length++);
      }
      if (c !== 0) {
        for (C = this.length - 1; C >= 0; C--)
          this.words[C + c] = this.words[C];
        for (C = 0; C < c; C++)
          this.words[C] = 0;
        this.length += c;
      }
      return this.strip();
    }, o.prototype.ishln = function(O) {
      return n(this.negative === 0), this.iushln(O);
    }, o.prototype.iushrn = function(O, E, c) {
      n(typeof O == "number" && O >= 0);
      var b;
      E ? b = (E - E % 26) / 26 : b = 0;
      var C = O % 26, x = Math.min((O - C) / 26, this.length), B = 67108863 ^ 67108863 >>> C << C, k = c;
      if (b -= x, b = Math.max(0, b), k) {
        for (var w = 0; w < x; w++)
          k.words[w] = this.words[w];
        k.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, w = 0; w < this.length; w++)
            this.words[w] = this.words[w + x];
        else
          this.words[0] = 0, this.length = 1;
      var T = 0;
      for (w = this.length - 1; w >= 0 && (T !== 0 || w >= b); w--) {
        var p = this.words[w] | 0;
        this.words[w] = T << 26 - C | p >>> C, T = p & B;
      }
      return k && T !== 0 && (k.words[k.length++] = T), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, o.prototype.ishrn = function(O, E, c) {
      return n(this.negative === 0), this.iushrn(O, E, c);
    }, o.prototype.shln = function(O) {
      return this.clone().ishln(O);
    }, o.prototype.ushln = function(O) {
      return this.clone().iushln(O);
    }, o.prototype.shrn = function(O) {
      return this.clone().ishrn(O);
    }, o.prototype.ushrn = function(O) {
      return this.clone().iushrn(O);
    }, o.prototype.testn = function(O) {
      n(typeof O == "number" && O >= 0);
      var E = O % 26, c = (O - E) / 26, b = 1 << E;
      if (this.length <= c)
        return !1;
      var C = this.words[c];
      return !!(C & b);
    }, o.prototype.imaskn = function(O) {
      n(typeof O == "number" && O >= 0);
      var E = O % 26, c = (O - E) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c)
        return this;
      if (E !== 0 && c++, this.length = Math.min(c, this.length), E !== 0) {
        var b = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= b;
      }
      return this.strip();
    }, o.prototype.maskn = function(O) {
      return this.clone().imaskn(O);
    }, o.prototype.iaddn = function(O) {
      return n(typeof O == "number"), n(O < 67108864), O < 0 ? this.isubn(-O) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < O ? (this.words[0] = O - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(O), this.negative = 1, this) : this._iaddn(O);
    }, o.prototype._iaddn = function(O) {
      this.words[0] += O;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, o.prototype.isubn = function(O) {
      if (n(typeof O == "number"), n(O < 67108864), O < 0)
        return this.iaddn(-O);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(O), this.negative = 1, this;
      if (this.words[0] -= O, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, o.prototype.addn = function(O) {
      return this.clone().iaddn(O);
    }, o.prototype.subn = function(O) {
      return this.clone().isubn(O);
    }, o.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o.prototype.abs = function() {
      return this.clone().iabs();
    }, o.prototype._ishlnsubmul = function(O, E, c) {
      var b = O.length + c, C;
      this._expand(b);
      var x, B = 0;
      for (C = 0; C < O.length; C++) {
        x = (this.words[C + c] | 0) + B;
        var k = (O.words[C] | 0) * E;
        x -= k & 67108863, B = (x >> 26) - (k / 67108864 | 0), this.words[C + c] = x & 67108863;
      }
      for (; C < this.length - c; C++)
        x = (this.words[C + c] | 0) + B, B = x >> 26, this.words[C + c] = x & 67108863;
      if (B === 0)
        return this.strip();
      for (n(B === -1), B = 0, C = 0; C < this.length; C++)
        x = -(this.words[C] | 0) + B, B = x >> 26, this.words[C] = x & 67108863;
      return this.negative = 1, this.strip();
    }, o.prototype._wordDiv = function(O, E) {
      var c = this.length - O.length, b = this.clone(), C = O, x = C.words[C.length - 1] | 0, B = this._countBits(x);
      c = 26 - B, c !== 0 && (C = C.ushln(c), b.iushln(c), x = C.words[C.length - 1] | 0);
      var k = b.length - C.length, w;
      if (E !== "mod") {
        w = new o(null), w.length = k + 1, w.words = new Array(w.length);
        for (var T = 0; T < w.length; T++)
          w.words[T] = 0;
      }
      var p = b.clone()._ishlnsubmul(C, 1, k);
      p.negative === 0 && (b = p, w && (w.words[k] = 1));
      for (var F = k - 1; F >= 0; F--) {
        var ye = (b.words[C.length + F] | 0) * 67108864 + (b.words[C.length + F - 1] | 0);
        for (ye = Math.min(ye / x | 0, 67108863), b._ishlnsubmul(C, ye, F); b.negative !== 0; )
          ye--, b.negative = 0, b._ishlnsubmul(C, 1, F), b.isZero() || (b.negative ^= 1);
        w && (w.words[F] = ye);
      }
      return w && w.strip(), b.strip(), E !== "div" && c !== 0 && b.iushrn(c), {
        div: w || null,
        mod: b
      };
    }, o.prototype.divmod = function(O, E, c) {
      if (n(!O.isZero()), this.isZero())
        return {
          div: new o(0),
          mod: new o(0)
        };
      var b, C, x;
      return this.negative !== 0 && O.negative === 0 ? (x = this.neg().divmod(O, E), E !== "mod" && (b = x.div.neg()), E !== "div" && (C = x.mod.neg(), c && C.negative !== 0 && C.iadd(O)), {
        div: b,
        mod: C
      }) : this.negative === 0 && O.negative !== 0 ? (x = this.divmod(O.neg(), E), E !== "mod" && (b = x.div.neg()), {
        div: b,
        mod: x.mod
      }) : this.negative & O.negative ? (x = this.neg().divmod(O.neg(), E), E !== "div" && (C = x.mod.neg(), c && C.negative !== 0 && C.isub(O)), {
        div: x.div,
        mod: C
      }) : O.length > this.length || this.cmp(O) < 0 ? {
        div: new o(0),
        mod: this
      } : O.length === 1 ? E === "div" ? {
        div: this.divn(O.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new o(this.modn(O.words[0]))
      } : {
        div: this.divn(O.words[0]),
        mod: new o(this.modn(O.words[0]))
      } : this._wordDiv(O, E);
    }, o.prototype.div = function(O) {
      return this.divmod(O, "div", !1).div;
    }, o.prototype.mod = function(O) {
      return this.divmod(O, "mod", !1).mod;
    }, o.prototype.umod = function(O) {
      return this.divmod(O, "mod", !0).mod;
    }, o.prototype.divRound = function(O) {
      var E = this.divmod(O);
      if (E.mod.isZero())
        return E.div;
      var c = E.div.negative !== 0 ? E.mod.isub(O) : E.mod, b = O.ushrn(1), C = O.andln(1), x = c.cmp(b);
      return x < 0 || C === 1 && x === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, o.prototype.modn = function(O) {
      n(O <= 67108863);
      for (var E = (1 << 26) % O, c = 0, b = this.length - 1; b >= 0; b--)
        c = (E * c + (this.words[b] | 0)) % O;
      return c;
    }, o.prototype.idivn = function(O) {
      n(O <= 67108863);
      for (var E = 0, c = this.length - 1; c >= 0; c--) {
        var b = (this.words[c] | 0) + E * 67108864;
        this.words[c] = b / O | 0, E = b % O;
      }
      return this.strip();
    }, o.prototype.divn = function(O) {
      return this.clone().idivn(O);
    }, o.prototype.egcd = function(O) {
      n(O.negative === 0), n(!O.isZero());
      var E = this, c = O.clone();
      E.negative !== 0 ? E = E.umod(O) : E = E.clone();
      for (var b = new o(1), C = new o(0), x = new o(0), B = new o(1), k = 0; E.isEven() && c.isEven(); )
        E.iushrn(1), c.iushrn(1), ++k;
      for (var w = c.clone(), T = E.clone(); !E.isZero(); ) {
        for (var p = 0, F = 1; !(E.words[0] & F) && p < 26; ++p, F <<= 1)
          ;
        if (p > 0)
          for (E.iushrn(p); p-- > 0; )
            (b.isOdd() || C.isOdd()) && (b.iadd(w), C.isub(T)), b.iushrn(1), C.iushrn(1);
        for (var ye = 0, _e = 1; !(c.words[0] & _e) && ye < 26; ++ye, _e <<= 1)
          ;
        if (ye > 0)
          for (c.iushrn(ye); ye-- > 0; )
            (x.isOdd() || B.isOdd()) && (x.iadd(w), B.isub(T)), x.iushrn(1), B.iushrn(1);
        E.cmp(c) >= 0 ? (E.isub(c), b.isub(x), C.isub(B)) : (c.isub(E), x.isub(b), B.isub(C));
      }
      return {
        a: x,
        b: B,
        gcd: c.iushln(k)
      };
    }, o.prototype._invmp = function(O) {
      n(O.negative === 0), n(!O.isZero());
      var E = this, c = O.clone();
      E.negative !== 0 ? E = E.umod(O) : E = E.clone();
      for (var b = new o(1), C = new o(0), x = c.clone(); E.cmpn(1) > 0 && c.cmpn(1) > 0; ) {
        for (var B = 0, k = 1; !(E.words[0] & k) && B < 26; ++B, k <<= 1)
          ;
        if (B > 0)
          for (E.iushrn(B); B-- > 0; )
            b.isOdd() && b.iadd(x), b.iushrn(1);
        for (var w = 0, T = 1; !(c.words[0] & T) && w < 26; ++w, T <<= 1)
          ;
        if (w > 0)
          for (c.iushrn(w); w-- > 0; )
            C.isOdd() && C.iadd(x), C.iushrn(1);
        E.cmp(c) >= 0 ? (E.isub(c), b.isub(C)) : (c.isub(E), C.isub(b));
      }
      var p;
      return E.cmpn(1) === 0 ? p = b : p = C, p.cmpn(0) < 0 && p.iadd(O), p;
    }, o.prototype.gcd = function(O) {
      if (this.isZero())
        return O.abs();
      if (O.isZero())
        return this.abs();
      var E = this.clone(), c = O.clone();
      E.negative = 0, c.negative = 0;
      for (var b = 0; E.isEven() && c.isEven(); b++)
        E.iushrn(1), c.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; c.isEven(); )
          c.iushrn(1);
        var C = E.cmp(c);
        if (C < 0) {
          var x = E;
          E = c, c = x;
        } else if (C === 0 || c.cmpn(1) === 0)
          break;
        E.isub(c);
      } while (!0);
      return c.iushln(b);
    }, o.prototype.invm = function(O) {
      return this.egcd(O).a.umod(O);
    }, o.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o.prototype.andln = function(O) {
      return this.words[0] & O;
    }, o.prototype.bincn = function(O) {
      n(typeof O == "number");
      var E = O % 26, c = (O - E) / 26, b = 1 << E;
      if (this.length <= c)
        return this._expand(c + 1), this.words[c] |= b, this;
      for (var C = b, x = c; C !== 0 && x < this.length; x++) {
        var B = this.words[x] | 0;
        B += C, C = B >>> 26, B &= 67108863, this.words[x] = B;
      }
      return C !== 0 && (this.words[x] = C, this.length++), this;
    }, o.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o.prototype.cmpn = function(O) {
      var E = O < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var c;
      if (this.length > 1)
        c = 1;
      else {
        E && (O = -O), n(O <= 67108863, "Number is too big");
        var b = this.words[0] | 0;
        c = b === O ? 0 : b < O ? -1 : 1;
      }
      return this.negative !== 0 ? -c | 0 : c;
    }, o.prototype.cmp = function(O) {
      if (this.negative !== 0 && O.negative === 0)
        return -1;
      if (this.negative === 0 && O.negative !== 0)
        return 1;
      var E = this.ucmp(O);
      return this.negative !== 0 ? -E | 0 : E;
    }, o.prototype.ucmp = function(O) {
      if (this.length > O.length)
        return 1;
      if (this.length < O.length)
        return -1;
      for (var E = 0, c = this.length - 1; c >= 0; c--) {
        var b = this.words[c] | 0, C = O.words[c] | 0;
        if (b !== C) {
          b < C ? E = -1 : b > C && (E = 1);
          break;
        }
      }
      return E;
    }, o.prototype.gtn = function(O) {
      return this.cmpn(O) === 1;
    }, o.prototype.gt = function(O) {
      return this.cmp(O) === 1;
    }, o.prototype.gten = function(O) {
      return this.cmpn(O) >= 0;
    }, o.prototype.gte = function(O) {
      return this.cmp(O) >= 0;
    }, o.prototype.ltn = function(O) {
      return this.cmpn(O) === -1;
    }, o.prototype.lt = function(O) {
      return this.cmp(O) === -1;
    }, o.prototype.lten = function(O) {
      return this.cmpn(O) <= 0;
    }, o.prototype.lte = function(O) {
      return this.cmp(O) <= 0;
    }, o.prototype.eqn = function(O) {
      return this.cmpn(O) === 0;
    }, o.prototype.eq = function(O) {
      return this.cmp(O) === 0;
    }, o.red = function(O) {
      return new Re(O);
    }, o.prototype.toRed = function(O) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), O.convertTo(this)._forceRed(O);
    }, o.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o.prototype._forceRed = function(O) {
      return this.red = O, this;
    }, o.prototype.forceRed = function(O) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(O);
    }, o.prototype.redAdd = function(O) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, O);
    }, o.prototype.redIAdd = function(O) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, O);
    }, o.prototype.redSub = function(O) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, O);
    }, o.prototype.redISub = function(O) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, O);
    }, o.prototype.redShl = function(O) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, O);
    }, o.prototype.redMul = function(O) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, O), this.red.mul(this, O);
    }, o.prototype.redIMul = function(O) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, O), this.red.imul(this, O);
    }, o.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o.prototype.redPow = function(O) {
      return n(this.red && !O.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, O);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function be(pe, O) {
      this.name = pe, this.p = new o(O, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be.prototype._tmp = function() {
      var O = new o(null);
      return O.words = new Array(Math.ceil(this.n / 13)), O;
    }, be.prototype.ireduce = function(O) {
      var E = O, c;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), c = E.bitLength();
      while (c > this.n);
      var b = c < this.n ? -1 : E.ucmp(this.p);
      return b === 0 ? (E.words[0] = 0, E.length = 1) : b > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, be.prototype.split = function(O, E) {
      O.iushrn(this.n, 0, E);
    }, be.prototype.imulK = function(O) {
      return O.imul(this.k);
    };
    function Ee() {
      be.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    u(Ee, be), Ee.prototype.split = function(O, E) {
      for (var c = 4194303, b = Math.min(O.length, 9), C = 0; C < b; C++)
        E.words[C] = O.words[C];
      if (E.length = b, O.length <= 9) {
        O.words[0] = 0, O.length = 1;
        return;
      }
      var x = O.words[9];
      for (E.words[E.length++] = x & c, C = 10; C < O.length; C++) {
        var B = O.words[C] | 0;
        O.words[C - 10] = (B & c) << 4 | x >>> 22, x = B;
      }
      x >>>= 22, O.words[C - 10] = x, x === 0 && O.length > 10 ? O.length -= 10 : O.length -= 9;
    }, Ee.prototype.imulK = function(O) {
      O.words[O.length] = 0, O.words[O.length + 1] = 0, O.length += 2;
      for (var E = 0, c = 0; c < O.length; c++) {
        var b = O.words[c] | 0;
        E += b * 977, O.words[c] = E & 67108863, E = b * 64 + (E / 67108864 | 0);
      }
      return O.words[O.length - 1] === 0 && (O.length--, O.words[O.length - 1] === 0 && O.length--), O;
    };
    function xe() {
      be.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    u(xe, be);
    function Le() {
      be.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    u(Le, be);
    function Ne() {
      be.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    u(Ne, be), Ne.prototype.imulK = function(O) {
      for (var E = 0, c = 0; c < O.length; c++) {
        var b = (O.words[c] | 0) * 19 + E, C = b & 67108863;
        b >>>= 26, O.words[c] = C, E = b;
      }
      return E !== 0 && (O.words[O.length++] = E), O;
    }, o._prime = function(O) {
      if (ge[O])
        return ge[O];
      var E;
      if (O === "k256")
        E = new Ee();
      else if (O === "p224")
        E = new xe();
      else if (O === "p192")
        E = new Le();
      else if (O === "p25519")
        E = new Ne();
      else
        throw new Error("Unknown prime " + O);
      return ge[O] = E, E;
    };
    function Re(pe) {
      if (typeof pe == "string") {
        var O = o._prime(pe);
        this.m = O.p, this.prime = O;
      } else
        n(pe.gtn(1), "modulus must be greater than 1"), this.m = pe, this.prime = null;
    }
    Re.prototype._verify1 = function(O) {
      n(O.negative === 0, "red works only with positives"), n(O.red, "red works only with red numbers");
    }, Re.prototype._verify2 = function(O, E) {
      n((O.negative | E.negative) === 0, "red works only with positives"), n(
        O.red && O.red === E.red,
        "red works only with red numbers"
      );
    }, Re.prototype.imod = function(O) {
      return this.prime ? this.prime.ireduce(O)._forceRed(this) : O.umod(this.m)._forceRed(this);
    }, Re.prototype.neg = function(O) {
      return O.isZero() ? O.clone() : this.m.sub(O)._forceRed(this);
    }, Re.prototype.add = function(O, E) {
      this._verify2(O, E);
      var c = O.add(E);
      return c.cmp(this.m) >= 0 && c.isub(this.m), c._forceRed(this);
    }, Re.prototype.iadd = function(O, E) {
      this._verify2(O, E);
      var c = O.iadd(E);
      return c.cmp(this.m) >= 0 && c.isub(this.m), c;
    }, Re.prototype.sub = function(O, E) {
      this._verify2(O, E);
      var c = O.sub(E);
      return c.cmpn(0) < 0 && c.iadd(this.m), c._forceRed(this);
    }, Re.prototype.isub = function(O, E) {
      this._verify2(O, E);
      var c = O.isub(E);
      return c.cmpn(0) < 0 && c.iadd(this.m), c;
    }, Re.prototype.shl = function(O, E) {
      return this._verify1(O), this.imod(O.ushln(E));
    }, Re.prototype.imul = function(O, E) {
      return this._verify2(O, E), this.imod(O.imul(E));
    }, Re.prototype.mul = function(O, E) {
      return this._verify2(O, E), this.imod(O.mul(E));
    }, Re.prototype.isqr = function(O) {
      return this.imul(O, O.clone());
    }, Re.prototype.sqr = function(O) {
      return this.mul(O, O);
    }, Re.prototype.sqrt = function(O) {
      if (O.isZero())
        return O.clone();
      var E = this.m.andln(3);
      if (n(E % 2 === 1), E === 3) {
        var c = this.m.add(new o(1)).iushrn(2);
        return this.pow(O, c);
      }
      for (var b = this.m.subn(1), C = 0; !b.isZero() && b.andln(1) === 0; )
        C++, b.iushrn(1);
      n(!b.isZero());
      var x = new o(1).toRed(this), B = x.redNeg(), k = this.m.subn(1).iushrn(1), w = this.m.bitLength();
      for (w = new o(2 * w * w).toRed(this); this.pow(w, k).cmp(B) !== 0; )
        w.redIAdd(B);
      for (var T = this.pow(w, b), p = this.pow(O, b.addn(1).iushrn(1)), F = this.pow(O, b), ye = C; F.cmp(x) !== 0; ) {
        for (var _e = F, de = 0; _e.cmp(x) !== 0; de++)
          _e = _e.redSqr();
        n(de < ye);
        var P = this.pow(T, new o(1).iushln(ye - de - 1));
        p = p.redMul(P), T = P.redSqr(), F = F.redMul(T), ye = de;
      }
      return p;
    }, Re.prototype.invm = function(O) {
      var E = O._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, Re.prototype.pow = function(O, E) {
      if (E.isZero())
        return new o(1).toRed(this);
      if (E.cmpn(1) === 0)
        return O.clone();
      var c = 4, b = new Array(1 << c);
      b[0] = new o(1).toRed(this), b[1] = O;
      for (var C = 2; C < b.length; C++)
        b[C] = this.mul(b[C - 1], O);
      var x = b[0], B = 0, k = 0, w = E.bitLength() % 26;
      for (w === 0 && (w = 26), C = E.length - 1; C >= 0; C--) {
        for (var T = E.words[C], p = w - 1; p >= 0; p--) {
          var F = T >> p & 1;
          if (x !== b[0] && (x = this.sqr(x)), F === 0 && B === 0) {
            k = 0;
            continue;
          }
          B <<= 1, B |= F, k++, !(k !== c && (C !== 0 || p !== 0)) && (x = this.mul(x, b[B]), k = 0, B = 0);
        }
        w = 26;
      }
      return x;
    }, Re.prototype.convertTo = function(O) {
      var E = O.umod(this.m);
      return E === O ? E.clone() : E;
    }, Re.prototype.convertFrom = function(O) {
      var E = O.clone();
      return E.red = null, E;
    }, o.mont = function(O) {
      return new Xe(O);
    };
    function Xe(pe) {
      Re.call(this, pe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    u(Xe, Re), Xe.prototype.convertTo = function(O) {
      return this.imod(O.ushln(this.shift));
    }, Xe.prototype.convertFrom = function(O) {
      var E = this.imod(O.mul(this.rinv));
      return E.red = null, E;
    }, Xe.prototype.imul = function(O, E) {
      if (O.isZero() || E.isZero())
        return O.words[0] = 0, O.length = 1, O;
      var c = O.imul(E), b = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), C = c.isub(b).iushrn(this.shift), x = C;
      return C.cmp(this.m) >= 0 ? x = C.isub(this.m) : C.cmpn(0) < 0 && (x = C.iadd(this.m)), x._forceRed(this);
    }, Xe.prototype.mul = function(O, E) {
      if (O.isZero() || E.isZero())
        return new o(0)._forceRed(this);
      var c = O.mul(E), b = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), C = c.isub(b).iushrn(this.shift), x = C;
      return C.cmp(this.m) >= 0 ? x = C.isub(this.m) : C.cmpn(0) < 0 && (x = C.iadd(this.m)), x._forceRed(this);
    }, Xe.prototype.invm = function(O) {
      var E = this.imod(O._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(e, commonjsGlobal);
})(bn$2);
var bnExports$2 = bn$2.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var e;
  brorand.exports = function(u) {
    return e || (e = new t(null)), e.generate(u);
  };
  function t(n) {
    this.rand = n;
  }
  if (brorand.exports.Rand = t, t.prototype.generate = function(u) {
    return this._rand(u);
  }, t.prototype._rand = function(u) {
    if (this.rand.getBytes)
      return this.rand.getBytes(u);
    for (var o = new Uint8Array(u), l = 0; l < o.length; l++)
      o[l] = this.rand.getByte();
    return o;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(u) {
      var o = new Uint8Array(u);
      return self.crypto.getRandomValues(o), o;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(u) {
      var o = new Uint8Array(u);
      return self.msCrypto.getRandomValues(o), o;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var a = requireCryptoBrowserify();
      if (typeof a.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(u) {
        return a.randomBytes(u);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr;
  hasRequiredMr = 1;
  var e = bnExports$2, t = requireBrorand();
  function a(n) {
    this.rand = n || new t.Rand();
  }
  return mr = a, a.create = function(u) {
    return new a(u);
  }, a.prototype._randbelow = function(u) {
    var o = u.bitLength(), l = Math.ceil(o / 8);
    do
      var h = new e(this.rand.generate(l));
    while (h.cmp(u) >= 0);
    return h;
  }, a.prototype._randrange = function(u, o) {
    var l = o.sub(u);
    return u.add(this._randbelow(l));
  }, a.prototype.test = function(u, o, l) {
    var h = u.bitLength(), y = e.mont(u), _ = new e(1).toRed(y);
    o || (o = Math.max(1, h / 48 | 0));
    for (var d = u.subn(1), $ = 0; !d.testn($); $++)
      ;
    for (var N = u.shrn($), U = d.toRed(y), V = !0; o > 0; o--) {
      var Q = this._randrange(new e(2), d);
      l && l(Q);
      var ie = Q.toRed(y).redPow(N);
      if (!(ie.cmp(_) === 0 || ie.cmp(U) === 0)) {
        for (var ee = 1; ee < $; ee++) {
          if (ie = ie.redSqr(), ie.cmp(_) === 0)
            return !1;
          if (ie.cmp(U) === 0)
            break;
        }
        if (ee === $)
          return !1;
      }
    }
    return V;
  }, a.prototype.getDivisor = function(u, o) {
    var l = u.bitLength(), h = e.mont(u), y = new e(1).toRed(h);
    o || (o = Math.max(1, l / 48 | 0));
    for (var _ = u.subn(1), d = 0; !_.testn(d); d++)
      ;
    for (var $ = u.shrn(d), N = _.toRed(h); o > 0; o--) {
      var U = this._randrange(new e(2), _), V = u.gcd(U);
      if (V.cmpn(1) !== 0)
        return V;
      var Q = U.toRed(h).redPow($);
      if (!(Q.cmp(y) === 0 || Q.cmp(N) === 0)) {
        for (var ie = 1; ie < d; ie++) {
          if (Q = Q.redSqr(), Q.cmp(y) === 0)
            return Q.fromRed().subn(1).gcd(u);
          if (Q.cmp(N) === 0)
            break;
        }
        if (ie === d)
          return Q = Q.redSqr(), Q.fromRed().subn(1).gcd(u);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var e = browserExports;
  generatePrime = ie, ie.simpleSieve = V, ie.fermatTest = Q;
  var t = bnExports$2, a = new t(24), n = requireMr(), u = new n(), o = new t(1), l = new t(2), h = new t(5);
  new t(16), new t(8);
  var y = new t(10), _ = new t(3);
  new t(7);
  var d = new t(11), $ = new t(4);
  new t(12);
  var N = null;
  function U() {
    if (N !== null)
      return N;
    var ee = 1048576, ne = [];
    ne[0] = 2;
    for (var ge = 1, be = 3; be < ee; be += 2) {
      for (var Ee = Math.ceil(Math.sqrt(be)), xe = 0; xe < ge && ne[xe] <= Ee && be % ne[xe] !== 0; xe++)
        ;
      ge !== xe && ne[xe] <= Ee || (ne[ge++] = be);
    }
    return N = ne, ne;
  }
  function V(ee) {
    for (var ne = U(), ge = 0; ge < ne.length; ge++)
      if (ee.modn(ne[ge]) === 0)
        return ee.cmpn(ne[ge]) === 0;
    return !0;
  }
  function Q(ee) {
    var ne = t.mont(ee);
    return l.toRed(ne).redPow(ee.subn(1)).fromRed().cmpn(1) === 0;
  }
  function ie(ee, ne) {
    if (ee < 16)
      return ne === 2 || ne === 5 ? new t([140, 123]) : new t([140, 39]);
    ne = new t(ne);
    for (var ge, be; ; ) {
      for (ge = new t(e(Math.ceil(ee / 8))); ge.bitLength() > ee; )
        ge.ishrn(1);
      if (ge.isEven() && ge.iadd(o), ge.testn(1) || ge.iadd(l), ne.cmp(l)) {
        if (!ne.cmp(h))
          for (; ge.mod(y).cmp(_); )
            ge.iadd($);
      } else
        for (; ge.mod(a).cmp(d); )
          ge.iadd($);
      if (be = ge.shrn(1), V(be) && V(ge) && Q(be) && Q(ge) && u.test(be) && u.test(ge))
        return ge;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh;
  hasRequiredDh = 1;
  var e = bnExports$2, t = requireMr(), a = new t(), n = new e(24), u = new e(11), o = new e(10), l = new e(3), h = new e(7), y = requireGeneratePrime(), _ = browserExports;
  dh = V;
  function d(ie, ee) {
    return ee = ee || "utf8", buffer$1.Buffer.isBuffer(ie) || (ie = new buffer$1.Buffer(ie, ee)), this._pub = new e(ie), this;
  }
  function $(ie, ee) {
    return ee = ee || "utf8", buffer$1.Buffer.isBuffer(ie) || (ie = new buffer$1.Buffer(ie, ee)), this._priv = new e(ie), this;
  }
  var N = {};
  function U(ie, ee) {
    var ne = ee.toString("hex"), ge = [ne, ie.toString(16)].join("_");
    if (ge in N)
      return N[ge];
    var be = 0;
    if (ie.isEven() || !y.simpleSieve || !y.fermatTest(ie) || !a.test(ie))
      return be += 1, ne === "02" || ne === "05" ? be += 8 : be += 4, N[ge] = be, be;
    a.test(ie.shrn(1)) || (be += 2);
    var Ee;
    switch (ne) {
      case "02":
        ie.mod(n).cmp(u) && (be += 8);
        break;
      case "05":
        Ee = ie.mod(o), Ee.cmp(l) && Ee.cmp(h) && (be += 8);
        break;
      default:
        be += 4;
    }
    return N[ge] = be, be;
  }
  function V(ie, ee, ne) {
    this.setGenerator(ee), this.__prime = new e(ie), this._prime = e.mont(this.__prime), this._primeLen = ie.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, ne ? (this.setPublicKey = d, this.setPrivateKey = $) : this._primeCode = 8;
  }
  Object.defineProperty(V.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = U(this.__prime, this.__gen)), this._primeCode;
    }
  }), V.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(_(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, V.prototype.computeSecret = function(ie) {
    ie = new e(ie), ie = ie.toRed(this._prime);
    var ee = ie.redPow(this._priv).fromRed(), ne = new buffer$1.Buffer(ee.toArray()), ge = this.getPrime();
    if (ne.length < ge.length) {
      var be = new buffer$1.Buffer(ge.length - ne.length);
      be.fill(0), ne = buffer$1.Buffer.concat([be, ne]);
    }
    return ne;
  }, V.prototype.getPublicKey = function(ee) {
    return Q(this._pub, ee);
  }, V.prototype.getPrivateKey = function(ee) {
    return Q(this._priv, ee);
  }, V.prototype.getPrime = function(ie) {
    return Q(this.__prime, ie);
  }, V.prototype.getGenerator = function(ie) {
    return Q(this._gen, ie);
  }, V.prototype.setGenerator = function(ie, ee) {
    return ee = ee || "utf8", buffer$1.Buffer.isBuffer(ie) || (ie = new buffer$1.Buffer(ie, ee)), this.__gen = ie, this._gen = new e(ie), this;
  };
  function Q(ie, ee) {
    var ne = new buffer$1.Buffer(ie.toArray());
    return ee ? ne.toString(ee) : ne;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$4;
  hasRequiredBrowser$2 = 1;
  var e = requireGeneratePrime(), t = require$$1$1, a = requireDh();
  function n(l) {
    var h = new buffer$1.Buffer(t[l].prime, "hex"), y = new buffer$1.Buffer(t[l].gen, "hex");
    return new a(h, y);
  }
  var u = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function o(l, h, y, _) {
    return buffer$1.Buffer.isBuffer(h) || u[h] === void 0 ? o(l, "binary", h, y) : (h = h || "binary", _ = _ || "binary", y = y || new buffer$1.Buffer([2]), buffer$1.Buffer.isBuffer(y) || (y = new buffer$1.Buffer(y, _)), typeof l == "number" ? new a(e(l, y), y, !0) : (buffer$1.Buffer.isBuffer(l) || (l = new buffer$1.Buffer(l, h)), new a(l, y, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = n, browser$4.createDiffieHellman = browser$4.DiffieHellman = o, browser$4;
}
var readableBrowser = { exports: {} }, toString = {}.toString, isarray = Array.isArray || function(e) {
  return toString.call(e) == "[object Array]";
}, streamBrowser = eventsExports.EventEmitter, safeBuffer$1 = { exports: {} };
(function(e, t) {
  var a = buffer$1, n = a.Buffer;
  function u(l, h) {
    for (var y in l)
      h[y] = l[y];
  }
  n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = a : (u(a, t), t.Buffer = o);
  function o(l, h, y) {
    return n(l, h, y);
  }
  u(n, o), o.from = function(l, h, y) {
    if (typeof l == "number")
      throw new TypeError("Argument must not be a number");
    return n(l, h, y);
  }, o.alloc = function(l, h, y) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    var _ = n(l);
    return h !== void 0 ? typeof y == "string" ? _.fill(h, y) : _.fill(h) : _.fill(0), _;
  }, o.allocUnsafe = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return n(l);
  }, o.allocUnsafeSlow = function(l) {
    if (typeof l != "number")
      throw new TypeError("Argument must be a number");
    return a.SlowBuffer(l);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(e) {
    function t(o, l) {
      if (!(o instanceof l))
        throw new TypeError("Cannot call a class as a function");
    }
    var a = safeBufferExports.Buffer, n = util$9;
    function u(o, l, h) {
      o.copy(l, h);
    }
    e.exports = function() {
      function o() {
        t(this, o), this.head = null, this.tail = null, this.length = 0;
      }
      return o.prototype.push = function(h) {
        var y = { data: h, next: null };
        this.length > 0 ? this.tail.next = y : this.head = y, this.tail = y, ++this.length;
      }, o.prototype.unshift = function(h) {
        var y = { data: h, next: this.head };
        this.length === 0 && (this.tail = y), this.head = y, ++this.length;
      }, o.prototype.shift = function() {
        if (this.length !== 0) {
          var h = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, h;
        }
      }, o.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, o.prototype.join = function(h) {
        if (this.length === 0)
          return "";
        for (var y = this.head, _ = "" + y.data; y = y.next; )
          _ += h + y.data;
        return _;
      }, o.prototype.concat = function(h) {
        if (this.length === 0)
          return a.alloc(0);
        for (var y = a.allocUnsafe(h >>> 0), _ = this.head, d = 0; _; )
          u(_.data, y, d), d += _.data.length, _ = _.next;
        return y;
      }, o;
    }(), n && n.inspect && n.inspect.custom && (e.exports.prototype[n.inspect.custom] = function() {
      var o = n.inspect({ length: this.length });
      return this.constructor.name + " " + o;
    });
  }(BufferList)), BufferList.exports;
}
var pna = processNextickArgsExports;
function destroy(e, t) {
  var a = this, n = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
  return n || u ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, this, e)) : pna.nextTick(emitErrorNT, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(o) {
    !t && o ? a._writableState ? a._writableState.errorEmitted || (a._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, a, o)) : pna.nextTick(emitErrorNT, a, o) : t && t(o);
  }), this);
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(e, t) {
  e.emit("error", t);
}
var destroy_1 = {
  destroy,
  undestroy
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  var e = processNextickArgsExports;
  _stream_writable = Q;
  function t(x) {
    var B = this;
    this.next = null, this.entry = null, this.finish = function() {
      C(B, x);
    };
  }
  var a = !api$2.browser && ["v0.10", "v0.9."].indexOf(api$2.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, n;
  Q.WritableState = U;
  var u = Object.create(util$a);
  u.inherits = inherits_browserExports;
  var o = {
    deprecate: browser$a
  }, l = streamBrowser, h = safeBufferExports.Buffer, y = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(x) {
    return h.from(x);
  }
  function d(x) {
    return h.isBuffer(x) || x instanceof y;
  }
  var $ = destroy_1;
  u.inherits(Q, l);
  function N() {
  }
  function U(x, B) {
    n = n || require_stream_duplex(), x = x || {};
    var k = B instanceof n;
    this.objectMode = !!x.objectMode, k && (this.objectMode = this.objectMode || !!x.writableObjectMode);
    var w = x.highWaterMark, T = x.writableHighWaterMark, p = this.objectMode ? 16 : 16 * 1024;
    w || w === 0 ? this.highWaterMark = w : k && (T || T === 0) ? this.highWaterMark = T : this.highWaterMark = p, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var F = x.decodeStrings === !1;
    this.decodeStrings = !F, this.defaultEncoding = x.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ye) {
      Le(B, ye);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  U.prototype.getBuffer = function() {
    for (var B = this.bufferedRequest, k = []; B; )
      k.push(B), B = B.next;
    return k;
  }, function() {
    try {
      Object.defineProperty(U.prototype, "buffer", {
        get: o.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var V;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (V = Function.prototype[Symbol.hasInstance], Object.defineProperty(Q, Symbol.hasInstance, {
    value: function(x) {
      return V.call(this, x) ? !0 : this !== Q ? !1 : x && x._writableState instanceof U;
    }
  })) : V = function(x) {
    return x instanceof this;
  };
  function Q(x) {
    if (n = n || require_stream_duplex(), !V.call(Q, this) && !(this instanceof n))
      return new Q(x);
    this._writableState = new U(x, this), this.writable = !0, x && (typeof x.write == "function" && (this._write = x.write), typeof x.writev == "function" && (this._writev = x.writev), typeof x.destroy == "function" && (this._destroy = x.destroy), typeof x.final == "function" && (this._final = x.final)), l.call(this);
  }
  Q.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function ie(x, B) {
    var k = new Error("write after end");
    x.emit("error", k), e.nextTick(B, k);
  }
  function ee(x, B, k, w) {
    var T = !0, p = !1;
    return k === null ? p = new TypeError("May not write null values to stream") : typeof k != "string" && k !== void 0 && !B.objectMode && (p = new TypeError("Invalid non-string/buffer chunk")), p && (x.emit("error", p), e.nextTick(w, p), T = !1), T;
  }
  Q.prototype.write = function(x, B, k) {
    var w = this._writableState, T = !1, p = !w.objectMode && d(x);
    return p && !h.isBuffer(x) && (x = _(x)), typeof B == "function" && (k = B, B = null), p ? B = "buffer" : B || (B = w.defaultEncoding), typeof k != "function" && (k = N), w.ended ? ie(this, k) : (p || ee(this, w, x, k)) && (w.pendingcb++, T = ge(this, w, p, x, B, k)), T;
  }, Q.prototype.cork = function() {
    var x = this._writableState;
    x.corked++;
  }, Q.prototype.uncork = function() {
    var x = this._writableState;
    x.corked && (x.corked--, !x.writing && !x.corked && !x.bufferProcessing && x.bufferedRequest && Xe(this, x));
  }, Q.prototype.setDefaultEncoding = function(B) {
    if (typeof B == "string" && (B = B.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((B + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + B);
    return this._writableState.defaultEncoding = B, this;
  };
  function ne(x, B, k) {
    return !x.objectMode && x.decodeStrings !== !1 && typeof B == "string" && (B = h.from(B, k)), B;
  }
  Object.defineProperty(Q.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ge(x, B, k, w, T, p) {
    if (!k) {
      var F = ne(B, w, T);
      w !== F && (k = !0, T = "buffer", w = F);
    }
    var ye = B.objectMode ? 1 : w.length;
    B.length += ye;
    var _e = B.length < B.highWaterMark;
    if (_e || (B.needDrain = !0), B.writing || B.corked) {
      var de = B.lastBufferedRequest;
      B.lastBufferedRequest = {
        chunk: w,
        encoding: T,
        isBuf: k,
        callback: p,
        next: null
      }, de ? de.next = B.lastBufferedRequest : B.bufferedRequest = B.lastBufferedRequest, B.bufferedRequestCount += 1;
    } else
      be(x, B, !1, ye, w, T, p);
    return _e;
  }
  function be(x, B, k, w, T, p, F) {
    B.writelen = w, B.writecb = F, B.writing = !0, B.sync = !0, k ? x._writev(T, B.onwrite) : x._write(T, p, B.onwrite), B.sync = !1;
  }
  function Ee(x, B, k, w, T) {
    --B.pendingcb, k ? (e.nextTick(T, w), e.nextTick(c, x, B), x._writableState.errorEmitted = !0, x.emit("error", w)) : (T(w), x._writableState.errorEmitted = !0, x.emit("error", w), c(x, B));
  }
  function xe(x) {
    x.writing = !1, x.writecb = null, x.length -= x.writelen, x.writelen = 0;
  }
  function Le(x, B) {
    var k = x._writableState, w = k.sync, T = k.writecb;
    if (xe(k), B)
      Ee(x, k, w, B, T);
    else {
      var p = pe(k);
      !p && !k.corked && !k.bufferProcessing && k.bufferedRequest && Xe(x, k), w ? a(Ne, x, k, p, T) : Ne(x, k, p, T);
    }
  }
  function Ne(x, B, k, w) {
    k || Re(x, B), B.pendingcb--, w(), c(x, B);
  }
  function Re(x, B) {
    B.length === 0 && B.needDrain && (B.needDrain = !1, x.emit("drain"));
  }
  function Xe(x, B) {
    B.bufferProcessing = !0;
    var k = B.bufferedRequest;
    if (x._writev && k && k.next) {
      var w = B.bufferedRequestCount, T = new Array(w), p = B.corkedRequestsFree;
      p.entry = k;
      for (var F = 0, ye = !0; k; )
        T[F] = k, k.isBuf || (ye = !1), k = k.next, F += 1;
      T.allBuffers = ye, be(x, B, !0, B.length, T, "", p.finish), B.pendingcb++, B.lastBufferedRequest = null, p.next ? (B.corkedRequestsFree = p.next, p.next = null) : B.corkedRequestsFree = new t(B), B.bufferedRequestCount = 0;
    } else {
      for (; k; ) {
        var _e = k.chunk, de = k.encoding, P = k.callback, H = B.objectMode ? 1 : _e.length;
        if (be(x, B, !1, H, _e, de, P), k = k.next, B.bufferedRequestCount--, B.writing)
          break;
      }
      k === null && (B.lastBufferedRequest = null);
    }
    B.bufferedRequest = k, B.bufferProcessing = !1;
  }
  Q.prototype._write = function(x, B, k) {
    k(new Error("_write() is not implemented"));
  }, Q.prototype._writev = null, Q.prototype.end = function(x, B, k) {
    var w = this._writableState;
    typeof x == "function" ? (k = x, x = null, B = null) : typeof B == "function" && (k = B, B = null), x != null && this.write(x, B), w.corked && (w.corked = 1, this.uncork()), w.ending || b(this, w, k);
  };
  function pe(x) {
    return x.ending && x.length === 0 && x.bufferedRequest === null && !x.finished && !x.writing;
  }
  function O(x, B) {
    x._final(function(k) {
      B.pendingcb--, k && x.emit("error", k), B.prefinished = !0, x.emit("prefinish"), c(x, B);
    });
  }
  function E(x, B) {
    !B.prefinished && !B.finalCalled && (typeof x._final == "function" ? (B.pendingcb++, B.finalCalled = !0, e.nextTick(O, x, B)) : (B.prefinished = !0, x.emit("prefinish")));
  }
  function c(x, B) {
    var k = pe(B);
    return k && (E(x, B), B.pendingcb === 0 && (B.finished = !0, x.emit("finish"))), k;
  }
  function b(x, B, k) {
    B.ending = !0, c(x, B), k && (B.finished ? e.nextTick(k) : x.once("finish", k)), B.ended = !0, x.writable = !1;
  }
  function C(x, B, k) {
    var w = x.entry;
    for (x.entry = null; w; ) {
      var T = w.callback;
      B.pendingcb--, T(k), w = w.next;
    }
    B.corkedRequestsFree.next = x;
  }
  return Object.defineProperty(Q.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(x) {
      this._writableState && (this._writableState.destroyed = x);
    }
  }), Q.prototype.destroy = $.destroy, Q.prototype._undestroy = $.undestroy, Q.prototype._destroy = function(x, B) {
    this.end(), B(x);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var e = processNextickArgsExports, t = Object.keys || function($) {
    var N = [];
    for (var U in $)
      N.push(U);
    return N;
  };
  _stream_duplex = y;
  var a = Object.create(util$a);
  a.inherits = inherits_browserExports;
  var n = require_stream_readable(), u = require_stream_writable();
  a.inherits(y, n);
  for (var o = t(u.prototype), l = 0; l < o.length; l++) {
    var h = o[l];
    y.prototype[h] || (y.prototype[h] = u.prototype[h]);
  }
  function y($) {
    if (!(this instanceof y))
      return new y($);
    n.call(this, $), u.call(this, $), $ && $.readable === !1 && (this.readable = !1), $ && $.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, $ && $.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", _);
  }
  Object.defineProperty(y.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function _() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(d, this);
  }
  function d($) {
    $.end();
  }
  return Object.defineProperty(y.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function($) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = $, this._writableState.destroyed = $);
    }
  }), y.prototype._destroy = function($, N) {
    this.push(null), this.end(), e.nextTick(N, $);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  var e = processNextickArgsExports;
  _stream_readable = ne;
  var t = isarray, a;
  ne.ReadableState = ee, eventsExports.EventEmitter;
  var n = function(P, H) {
    return P.listeners(H).length;
  }, u = streamBrowser, o = safeBufferExports.Buffer, l = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function h(P) {
    return o.from(P);
  }
  function y(P) {
    return o.isBuffer(P) || P instanceof l;
  }
  var _ = Object.create(util$a);
  _.inherits = inherits_browserExports;
  var d = util$9, $ = void 0;
  d && d.debuglog ? $ = d.debuglog("stream") : $ = function() {
  };
  var N = requireBufferList(), U = destroy_1, V;
  _.inherits(ne, u);
  var Q = ["error", "close", "destroy", "pause", "resume"];
  function ie(P, H, he) {
    if (typeof P.prependListener == "function")
      return P.prependListener(H, he);
    !P._events || !P._events[H] ? P.on(H, he) : t(P._events[H]) ? P._events[H].unshift(he) : P._events[H] = [he, P._events[H]];
  }
  function ee(P, H) {
    a = a || require_stream_duplex(), P = P || {};
    var he = H instanceof a;
    this.objectMode = !!P.objectMode, he && (this.objectMode = this.objectMode || !!P.readableObjectMode);
    var me = P.highWaterMark, fe = P.readableHighWaterMark, re = this.objectMode ? 16 : 16 * 1024;
    me || me === 0 ? this.highWaterMark = me : he && (fe || fe === 0) ? this.highWaterMark = fe : this.highWaterMark = re, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new N(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = P.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, P.encoding && (V || (V = string_decoder.StringDecoder), this.decoder = new V(P.encoding), this.encoding = P.encoding);
  }
  function ne(P) {
    if (a = a || require_stream_duplex(), !(this instanceof ne))
      return new ne(P);
    this._readableState = new ee(P, this), this.readable = !0, P && (typeof P.read == "function" && (this._read = P.read), typeof P.destroy == "function" && (this._destroy = P.destroy)), u.call(this);
  }
  Object.defineProperty(ne.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(P) {
      this._readableState && (this._readableState.destroyed = P);
    }
  }), ne.prototype.destroy = U.destroy, ne.prototype._undestroy = U.undestroy, ne.prototype._destroy = function(P, H) {
    this.push(null), H(P);
  }, ne.prototype.push = function(P, H) {
    var he = this._readableState, me;
    return he.objectMode ? me = !0 : typeof P == "string" && (H = H || he.defaultEncoding, H !== he.encoding && (P = o.from(P, H), H = ""), me = !0), ge(this, P, H, !1, me);
  }, ne.prototype.unshift = function(P) {
    return ge(this, P, null, !0, !1);
  };
  function ge(P, H, he, me, fe) {
    var re = P._readableState;
    if (H === null)
      re.reading = !1, Xe(P, re);
    else {
      var we;
      fe || (we = Ee(re, H)), we ? P.emit("error", we) : re.objectMode || H && H.length > 0 ? (typeof H != "string" && !re.objectMode && Object.getPrototypeOf(H) !== o.prototype && (H = h(H)), me ? re.endEmitted ? P.emit("error", new Error("stream.unshift() after end event")) : be(P, re, H, !0) : re.ended ? P.emit("error", new Error("stream.push() after EOF")) : (re.reading = !1, re.decoder && !he ? (H = re.decoder.write(H), re.objectMode || H.length !== 0 ? be(P, re, H, !1) : E(P, re)) : be(P, re, H, !1))) : me || (re.reading = !1);
    }
    return xe(re);
  }
  function be(P, H, he, me) {
    H.flowing && H.length === 0 && !H.sync ? (P.emit("data", he), P.read(0)) : (H.length += H.objectMode ? 1 : he.length, me ? H.buffer.unshift(he) : H.buffer.push(he), H.needReadable && pe(P)), E(P, H);
  }
  function Ee(P, H) {
    var he;
    return !y(H) && typeof H != "string" && H !== void 0 && !P.objectMode && (he = new TypeError("Invalid non-string/buffer chunk")), he;
  }
  function xe(P) {
    return !P.ended && (P.needReadable || P.length < P.highWaterMark || P.length === 0);
  }
  ne.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ne.prototype.setEncoding = function(P) {
    return V || (V = string_decoder.StringDecoder), this._readableState.decoder = new V(P), this._readableState.encoding = P, this;
  };
  var Le = 8388608;
  function Ne(P) {
    return P >= Le ? P = Le : (P--, P |= P >>> 1, P |= P >>> 2, P |= P >>> 4, P |= P >>> 8, P |= P >>> 16, P++), P;
  }
  function Re(P, H) {
    return P <= 0 || H.length === 0 && H.ended ? 0 : H.objectMode ? 1 : P !== P ? H.flowing && H.length ? H.buffer.head.data.length : H.length : (P > H.highWaterMark && (H.highWaterMark = Ne(P)), P <= H.length ? P : H.ended ? H.length : (H.needReadable = !0, 0));
  }
  ne.prototype.read = function(P) {
    $("read", P), P = parseInt(P, 10);
    var H = this._readableState, he = P;
    if (P !== 0 && (H.emittedReadable = !1), P === 0 && H.needReadable && (H.length >= H.highWaterMark || H.ended))
      return $("read: emitReadable", H.length, H.ended), H.length === 0 && H.ended ? ye(this) : pe(this), null;
    if (P = Re(P, H), P === 0 && H.ended)
      return H.length === 0 && ye(this), null;
    var me = H.needReadable;
    $("need readable", me), (H.length === 0 || H.length - P < H.highWaterMark) && (me = !0, $("length less than watermark", me)), H.ended || H.reading ? (me = !1, $("reading or ended", me)) : me && ($("do read"), H.reading = !0, H.sync = !0, H.length === 0 && (H.needReadable = !0), this._read(H.highWaterMark), H.sync = !1, H.reading || (P = Re(he, H)));
    var fe;
    return P > 0 ? fe = w(P, H) : fe = null, fe === null ? (H.needReadable = !0, P = 0) : H.length -= P, H.length === 0 && (H.ended || (H.needReadable = !0), he !== P && H.ended && ye(this)), fe !== null && this.emit("data", fe), fe;
  };
  function Xe(P, H) {
    if (!H.ended) {
      if (H.decoder) {
        var he = H.decoder.end();
        he && he.length && (H.buffer.push(he), H.length += H.objectMode ? 1 : he.length);
      }
      H.ended = !0, pe(P);
    }
  }
  function pe(P) {
    var H = P._readableState;
    H.needReadable = !1, H.emittedReadable || ($("emitReadable", H.flowing), H.emittedReadable = !0, H.sync ? e.nextTick(O, P) : O(P));
  }
  function O(P) {
    $("emit readable"), P.emit("readable"), k(P);
  }
  function E(P, H) {
    H.readingMore || (H.readingMore = !0, e.nextTick(c, P, H));
  }
  function c(P, H) {
    for (var he = H.length; !H.reading && !H.flowing && !H.ended && H.length < H.highWaterMark && ($("maybeReadMore read 0"), P.read(0), he !== H.length); )
      he = H.length;
    H.readingMore = !1;
  }
  ne.prototype._read = function(P) {
    this.emit("error", new Error("_read() is not implemented"));
  }, ne.prototype.pipe = function(P, H) {
    var he = this, me = this._readableState;
    switch (me.pipesCount) {
      case 0:
        me.pipes = P;
        break;
      case 1:
        me.pipes = [me.pipes, P];
        break;
      default:
        me.pipes.push(P);
        break;
    }
    me.pipesCount += 1, $("pipe count=%d opts=%j", me.pipesCount, H);
    var fe = (!H || H.end !== !1) && P !== api$2.stdout && P !== api$2.stderr, re = fe ? ke : Ye;
    me.endEmitted ? e.nextTick(re) : he.once("end", re), P.on("unpipe", we);
    function we(He, ot) {
      $("onunpipe"), He === he && ot && ot.hasUnpiped === !1 && (ot.hasUnpiped = !0, j());
    }
    function ke() {
      $("onend"), P.end();
    }
    var Oe = b(he);
    P.on("drain", Oe);
    var ce = !1;
    function j() {
      $("cleanup"), P.removeListener("close", Te), P.removeListener("finish", Pe), P.removeListener("drain", Oe), P.removeListener("error", Be), P.removeListener("unpipe", we), he.removeListener("end", ke), he.removeListener("end", Ye), he.removeListener("data", oe), ce = !0, me.awaitDrain && (!P._writableState || P._writableState.needDrain) && Oe();
    }
    var z = !1;
    he.on("data", oe);
    function oe(He) {
      $("ondata"), z = !1;
      var ot = P.write(He);
      ot === !1 && !z && ((me.pipesCount === 1 && me.pipes === P || me.pipesCount > 1 && de(me.pipes, P) !== -1) && !ce && ($("false write response, pause", me.awaitDrain), me.awaitDrain++, z = !0), he.pause());
    }
    function Be(He) {
      $("onerror", He), Ye(), P.removeListener("error", Be), n(P, "error") === 0 && P.emit("error", He);
    }
    ie(P, "error", Be);
    function Te() {
      P.removeListener("finish", Pe), Ye();
    }
    P.once("close", Te);
    function Pe() {
      $("onfinish"), P.removeListener("close", Te), Ye();
    }
    P.once("finish", Pe);
    function Ye() {
      $("unpipe"), he.unpipe(P);
    }
    return P.emit("pipe", he), me.flowing || ($("pipe resume"), he.resume()), P;
  };
  function b(P) {
    return function() {
      var H = P._readableState;
      $("pipeOnDrain", H.awaitDrain), H.awaitDrain && H.awaitDrain--, H.awaitDrain === 0 && n(P, "data") && (H.flowing = !0, k(P));
    };
  }
  ne.prototype.unpipe = function(P) {
    var H = this._readableState, he = { hasUnpiped: !1 };
    if (H.pipesCount === 0)
      return this;
    if (H.pipesCount === 1)
      return P && P !== H.pipes ? this : (P || (P = H.pipes), H.pipes = null, H.pipesCount = 0, H.flowing = !1, P && P.emit("unpipe", this, he), this);
    if (!P) {
      var me = H.pipes, fe = H.pipesCount;
      H.pipes = null, H.pipesCount = 0, H.flowing = !1;
      for (var re = 0; re < fe; re++)
        me[re].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var we = de(H.pipes, P);
    return we === -1 ? this : (H.pipes.splice(we, 1), H.pipesCount -= 1, H.pipesCount === 1 && (H.pipes = H.pipes[0]), P.emit("unpipe", this, he), this);
  }, ne.prototype.on = function(P, H) {
    var he = u.prototype.on.call(this, P, H);
    if (P === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (P === "readable") {
      var me = this._readableState;
      !me.endEmitted && !me.readableListening && (me.readableListening = me.needReadable = !0, me.emittedReadable = !1, me.reading ? me.length && pe(this) : e.nextTick(C, this));
    }
    return he;
  }, ne.prototype.addListener = ne.prototype.on;
  function C(P) {
    $("readable nexttick read 0"), P.read(0);
  }
  ne.prototype.resume = function() {
    var P = this._readableState;
    return P.flowing || ($("resume"), P.flowing = !0, x(this, P)), this;
  };
  function x(P, H) {
    H.resumeScheduled || (H.resumeScheduled = !0, e.nextTick(B, P, H));
  }
  function B(P, H) {
    H.reading || ($("resume read 0"), P.read(0)), H.resumeScheduled = !1, H.awaitDrain = 0, P.emit("resume"), k(P), H.flowing && !H.reading && P.read(0);
  }
  ne.prototype.pause = function() {
    return $("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && ($("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function k(P) {
    var H = P._readableState;
    for ($("flow", H.flowing); H.flowing && P.read() !== null; )
      ;
  }
  ne.prototype.wrap = function(P) {
    var H = this, he = this._readableState, me = !1;
    P.on("end", function() {
      if ($("wrapped end"), he.decoder && !he.ended) {
        var we = he.decoder.end();
        we && we.length && H.push(we);
      }
      H.push(null);
    }), P.on("data", function(we) {
      if ($("wrapped data"), he.decoder && (we = he.decoder.write(we)), !(he.objectMode && we == null) && !(!he.objectMode && (!we || !we.length))) {
        var ke = H.push(we);
        ke || (me = !0, P.pause());
      }
    });
    for (var fe in P)
      this[fe] === void 0 && typeof P[fe] == "function" && (this[fe] = function(we) {
        return function() {
          return P[we].apply(P, arguments);
        };
      }(fe));
    for (var re = 0; re < Q.length; re++)
      P.on(Q[re], this.emit.bind(this, Q[re]));
    return this._read = function(we) {
      $("wrapped _read", we), me && (me = !1, P.resume());
    }, this;
  }, Object.defineProperty(ne.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), ne._fromList = w;
  function w(P, H) {
    if (H.length === 0)
      return null;
    var he;
    return H.objectMode ? he = H.buffer.shift() : !P || P >= H.length ? (H.decoder ? he = H.buffer.join("") : H.buffer.length === 1 ? he = H.buffer.head.data : he = H.buffer.concat(H.length), H.buffer.clear()) : he = T(P, H.buffer, H.decoder), he;
  }
  function T(P, H, he) {
    var me;
    return P < H.head.data.length ? (me = H.head.data.slice(0, P), H.head.data = H.head.data.slice(P)) : P === H.head.data.length ? me = H.shift() : me = he ? p(P, H) : F(P, H), me;
  }
  function p(P, H) {
    var he = H.head, me = 1, fe = he.data;
    for (P -= fe.length; he = he.next; ) {
      var re = he.data, we = P > re.length ? re.length : P;
      if (we === re.length ? fe += re : fe += re.slice(0, P), P -= we, P === 0) {
        we === re.length ? (++me, he.next ? H.head = he.next : H.head = H.tail = null) : (H.head = he, he.data = re.slice(we));
        break;
      }
      ++me;
    }
    return H.length -= me, fe;
  }
  function F(P, H) {
    var he = o.allocUnsafe(P), me = H.head, fe = 1;
    for (me.data.copy(he), P -= me.data.length; me = me.next; ) {
      var re = me.data, we = P > re.length ? re.length : P;
      if (re.copy(he, he.length - P, 0, we), P -= we, P === 0) {
        we === re.length ? (++fe, me.next ? H.head = me.next : H.head = H.tail = null) : (H.head = me, me.data = re.slice(we));
        break;
      }
      ++fe;
    }
    return H.length -= fe, he;
  }
  function ye(P) {
    var H = P._readableState;
    if (H.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    H.endEmitted || (H.ended = !0, e.nextTick(_e, H, P));
  }
  function _e(P, H) {
    !P.endEmitted && P.length === 0 && (P.endEmitted = !0, H.readable = !1, H.emit("end"));
  }
  function de(P, H) {
    for (var he = 0, me = P.length; he < me; he++)
      if (P[he] === H)
        return he;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, Duplex = require_stream_duplex(), util$6 = Object.create(util$a);
util$6.inherits = inherits_browserExports;
util$6.inherits(Transform$1, Duplex);
function afterTransform(e, t) {
  var a = this._transformState;
  a.transforming = !1;
  var n = a.writecb;
  if (!n)
    return this.emit("error", new Error("write callback called multiple times"));
  a.writechunk = null, a.writecb = null, t != null && this.push(t), n(e);
  var u = this._readableState;
  u.reading = !1, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
}
function Transform$1(e) {
  if (!(this instanceof Transform$1))
    return new Transform$1(e);
  Duplex.call(this, e), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var e = this;
  typeof this._flush == "function" ? this._flush(function(t, a) {
    done(e, t, a);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, e, t);
};
Transform$1.prototype._transform = function(e, t, a) {
  throw new Error("_transform() is not implemented");
};
Transform$1.prototype._write = function(e, t, a) {
  var n = this._transformState;
  if (n.writecb = a, n.writechunk = e, n.writeencoding = t, !n.transforming) {
    var u = this._readableState;
    (n.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
  }
};
Transform$1.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Transform$1.prototype._destroy = function(e, t) {
  var a = this;
  Duplex.prototype._destroy.call(this, e, function(n) {
    t(n), a.emit("close");
  });
};
function done(e, t, a) {
  if (t)
    return e.emit("error", t);
  if (a != null && e.push(a), e._writableState.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (e._transformState.transforming)
    throw new Error("Calling transform done when still transforming");
  return e.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform, util$5 = Object.create(util$a);
util$5.inherits = inherits_browserExports;
util$5.inherits(PassThrough, Transform);
function PassThrough(e) {
  if (!(this instanceof PassThrough))
    return new PassThrough(e);
  Transform.call(this, e);
}
PassThrough.prototype._transform = function(e, t, a) {
  a(null, e);
};
(function(e, t) {
  t = e.exports = require_stream_readable(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable(), t.Duplex = require_stream_duplex(), t.Transform = _stream_transform, t.PassThrough = _stream_passthrough;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign = { exports: {} }, bn$1 = { exports: {} };
bn$1.exports;
(function(e) {
  (function(t, a) {
    function n(E, c) {
      if (!E)
        throw new Error(c || "Assertion failed");
    }
    function u(E, c) {
      E.super_ = c;
      var b = function() {
      };
      b.prototype = c.prototype, E.prototype = new b(), E.prototype.constructor = E;
    }
    function o(E, c, b) {
      if (o.isBN(E))
        return E;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, E !== null && ((c === "le" || c === "be") && (b = c, c = 10), this._init(E || 0, c || 10, b || "be"));
    }
    typeof t == "object" ? t.exports = o : a.BN = o, o.BN = o, o.wordSize = 26;
    var l;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? l = window.Buffer : l = buffer$1.Buffer;
    } catch {
    }
    o.isBN = function(c) {
      return c instanceof o ? !0 : c !== null && typeof c == "object" && c.constructor.wordSize === o.wordSize && Array.isArray(c.words);
    }, o.max = function(c, b) {
      return c.cmp(b) > 0 ? c : b;
    }, o.min = function(c, b) {
      return c.cmp(b) < 0 ? c : b;
    }, o.prototype._init = function(c, b, C) {
      if (typeof c == "number")
        return this._initNumber(c, b, C);
      if (typeof c == "object")
        return this._initArray(c, b, C);
      b === "hex" && (b = 16), n(b === (b | 0) && b >= 2 && b <= 36), c = c.toString().replace(/\s+/g, "");
      var x = 0;
      c[0] === "-" && (x++, this.negative = 1), x < c.length && (b === 16 ? this._parseHex(c, x, C) : (this._parseBase(c, b, x), C === "le" && this._initArray(this.toArray(), b, C)));
    }, o.prototype._initNumber = function(c, b, C) {
      c < 0 && (this.negative = 1, c = -c), c < 67108864 ? (this.words = [c & 67108863], this.length = 1) : c < 4503599627370496 ? (this.words = [
        c & 67108863,
        c / 67108864 & 67108863
      ], this.length = 2) : (n(c < 9007199254740992), this.words = [
        c & 67108863,
        c / 67108864 & 67108863,
        1
      ], this.length = 3), C === "le" && this._initArray(this.toArray(), b, C);
    }, o.prototype._initArray = function(c, b, C) {
      if (n(typeof c.length == "number"), c.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(c.length / 3), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var B, k, w = 0;
      if (C === "be")
        for (x = c.length - 1, B = 0; x >= 0; x -= 3)
          k = c[x] | c[x - 1] << 8 | c[x - 2] << 16, this.words[B] |= k << w & 67108863, this.words[B + 1] = k >>> 26 - w & 67108863, w += 24, w >= 26 && (w -= 26, B++);
      else if (C === "le")
        for (x = 0, B = 0; x < c.length; x += 3)
          k = c[x] | c[x + 1] << 8 | c[x + 2] << 16, this.words[B] |= k << w & 67108863, this.words[B + 1] = k >>> 26 - w & 67108863, w += 24, w >= 26 && (w -= 26, B++);
      return this._strip();
    };
    function h(E, c) {
      var b = E.charCodeAt(c);
      if (b >= 48 && b <= 57)
        return b - 48;
      if (b >= 65 && b <= 70)
        return b - 55;
      if (b >= 97 && b <= 102)
        return b - 87;
      n(!1, "Invalid character in " + E);
    }
    function y(E, c, b) {
      var C = h(E, b);
      return b - 1 >= c && (C |= h(E, b - 1) << 4), C;
    }
    o.prototype._parseHex = function(c, b, C) {
      this.length = Math.ceil((c.length - b) / 6), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var B = 0, k = 0, w;
      if (C === "be")
        for (x = c.length - 1; x >= b; x -= 2)
          w = y(c, b, x) << B, this.words[k] |= w & 67108863, B >= 18 ? (B -= 18, k += 1, this.words[k] |= w >>> 26) : B += 8;
      else {
        var T = c.length - b;
        for (x = T % 2 === 0 ? b + 1 : b; x < c.length; x += 2)
          w = y(c, b, x) << B, this.words[k] |= w & 67108863, B >= 18 ? (B -= 18, k += 1, this.words[k] |= w >>> 26) : B += 8;
      }
      this._strip();
    };
    function _(E, c, b, C) {
      for (var x = 0, B = 0, k = Math.min(E.length, b), w = c; w < k; w++) {
        var T = E.charCodeAt(w) - 48;
        x *= C, T >= 49 ? B = T - 49 + 10 : T >= 17 ? B = T - 17 + 10 : B = T, n(T >= 0 && B < C, "Invalid character"), x += B;
      }
      return x;
    }
    o.prototype._parseBase = function(c, b, C) {
      this.words = [0], this.length = 1;
      for (var x = 0, B = 1; B <= 67108863; B *= b)
        x++;
      x--, B = B / b | 0;
      for (var k = c.length - C, w = k % x, T = Math.min(k, k - w) + C, p = 0, F = C; F < T; F += x)
        p = _(c, F, F + x, b), this.imuln(B), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
      if (w !== 0) {
        var ye = 1;
        for (p = _(c, F, c.length, b), F = 0; F < w; F++)
          ye *= b;
        this.imuln(ye), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
      }
      this._strip();
    }, o.prototype.copy = function(c) {
      c.words = new Array(this.length);
      for (var b = 0; b < this.length; b++)
        c.words[b] = this.words[b];
      c.length = this.length, c.negative = this.negative, c.red = this.red;
    };
    function d(E, c) {
      E.words = c.words, E.length = c.length, E.negative = c.negative, E.red = c.red;
    }
    if (o.prototype._move = function(c) {
      d(c, this);
    }, o.prototype.clone = function() {
      var c = new o(null);
      return this.copy(c), c;
    }, o.prototype._expand = function(c) {
      for (; this.length < c; )
        this.words[this.length++] = 0;
      return this;
    }, o.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        o.prototype[Symbol.for("nodejs.util.inspect.custom")] = $;
      } catch {
        o.prototype.inspect = $;
      }
    else
      o.prototype.inspect = $;
    function $() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var N = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], U = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], V = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    o.prototype.toString = function(c, b) {
      c = c || 10, b = b | 0 || 1;
      var C;
      if (c === 16 || c === "hex") {
        C = "";
        for (var x = 0, B = 0, k = 0; k < this.length; k++) {
          var w = this.words[k], T = ((w << x | B) & 16777215).toString(16);
          B = w >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, k--), B !== 0 || k !== this.length - 1 ? C = N[6 - T.length] + T + C : C = T + C;
        }
        for (B !== 0 && (C = B.toString(16) + C); C.length % b !== 0; )
          C = "0" + C;
        return this.negative !== 0 && (C = "-" + C), C;
      }
      if (c === (c | 0) && c >= 2 && c <= 36) {
        var p = U[c], F = V[c];
        C = "";
        var ye = this.clone();
        for (ye.negative = 0; !ye.isZero(); ) {
          var _e = ye.modrn(F).toString(c);
          ye = ye.idivn(F), ye.isZero() ? C = _e + C : C = N[p - _e.length] + _e + C;
        }
        for (this.isZero() && (C = "0" + C); C.length % b !== 0; )
          C = "0" + C;
        return this.negative !== 0 && (C = "-" + C), C;
      }
      n(!1, "Base should be between 2 and 36");
    }, o.prototype.toNumber = function() {
      var c = this.words[0];
      return this.length === 2 ? c += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? c += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -c : c;
    }, o.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, l && (o.prototype.toBuffer = function(c, b) {
      return this.toArrayLike(l, c, b);
    }), o.prototype.toArray = function(c, b) {
      return this.toArrayLike(Array, c, b);
    };
    var Q = function(c, b) {
      return c.allocUnsafe ? c.allocUnsafe(b) : new c(b);
    };
    o.prototype.toArrayLike = function(c, b, C) {
      this._strip();
      var x = this.byteLength(), B = C || Math.max(1, x);
      n(x <= B, "byte array longer than desired length"), n(B > 0, "Requested array length <= 0");
      var k = Q(c, B), w = b === "le" ? "LE" : "BE";
      return this["_toArrayLike" + w](k, x), k;
    }, o.prototype._toArrayLikeLE = function(c, b) {
      for (var C = 0, x = 0, B = 0, k = 0; B < this.length; B++) {
        var w = this.words[B] << k | x;
        c[C++] = w & 255, C < c.length && (c[C++] = w >> 8 & 255), C < c.length && (c[C++] = w >> 16 & 255), k === 6 ? (C < c.length && (c[C++] = w >> 24 & 255), x = 0, k = 0) : (x = w >>> 24, k += 2);
      }
      if (C < c.length)
        for (c[C++] = x; C < c.length; )
          c[C++] = 0;
    }, o.prototype._toArrayLikeBE = function(c, b) {
      for (var C = c.length - 1, x = 0, B = 0, k = 0; B < this.length; B++) {
        var w = this.words[B] << k | x;
        c[C--] = w & 255, C >= 0 && (c[C--] = w >> 8 & 255), C >= 0 && (c[C--] = w >> 16 & 255), k === 6 ? (C >= 0 && (c[C--] = w >> 24 & 255), x = 0, k = 0) : (x = w >>> 24, k += 2);
      }
      if (C >= 0)
        for (c[C--] = x; C >= 0; )
          c[C--] = 0;
    }, Math.clz32 ? o.prototype._countBits = function(c) {
      return 32 - Math.clz32(c);
    } : o.prototype._countBits = function(c) {
      var b = c, C = 0;
      return b >= 4096 && (C += 13, b >>>= 13), b >= 64 && (C += 7, b >>>= 7), b >= 8 && (C += 4, b >>>= 4), b >= 2 && (C += 2, b >>>= 2), C + b;
    }, o.prototype._zeroBits = function(c) {
      if (c === 0)
        return 26;
      var b = c, C = 0;
      return b & 8191 || (C += 13, b >>>= 13), b & 127 || (C += 7, b >>>= 7), b & 15 || (C += 4, b >>>= 4), b & 3 || (C += 2, b >>>= 2), b & 1 || C++, C;
    }, o.prototype.bitLength = function() {
      var c = this.words[this.length - 1], b = this._countBits(c);
      return (this.length - 1) * 26 + b;
    };
    function ie(E) {
      for (var c = new Array(E.bitLength()), b = 0; b < c.length; b++) {
        var C = b / 26 | 0, x = b % 26;
        c[b] = E.words[C] >>> x & 1;
      }
      return c;
    }
    o.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var c = 0, b = 0; b < this.length; b++) {
        var C = this._zeroBits(this.words[b]);
        if (c += C, C !== 26)
          break;
      }
      return c;
    }, o.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o.prototype.toTwos = function(c) {
      return this.negative !== 0 ? this.abs().inotn(c).iaddn(1) : this.clone();
    }, o.prototype.fromTwos = function(c) {
      return this.testn(c - 1) ? this.notn(c).iaddn(1).ineg() : this.clone();
    }, o.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o.prototype.neg = function() {
      return this.clone().ineg();
    }, o.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o.prototype.iuor = function(c) {
      for (; this.length < c.length; )
        this.words[this.length++] = 0;
      for (var b = 0; b < c.length; b++)
        this.words[b] = this.words[b] | c.words[b];
      return this._strip();
    }, o.prototype.ior = function(c) {
      return n((this.negative | c.negative) === 0), this.iuor(c);
    }, o.prototype.or = function(c) {
      return this.length > c.length ? this.clone().ior(c) : c.clone().ior(this);
    }, o.prototype.uor = function(c) {
      return this.length > c.length ? this.clone().iuor(c) : c.clone().iuor(this);
    }, o.prototype.iuand = function(c) {
      var b;
      this.length > c.length ? b = c : b = this;
      for (var C = 0; C < b.length; C++)
        this.words[C] = this.words[C] & c.words[C];
      return this.length = b.length, this._strip();
    }, o.prototype.iand = function(c) {
      return n((this.negative | c.negative) === 0), this.iuand(c);
    }, o.prototype.and = function(c) {
      return this.length > c.length ? this.clone().iand(c) : c.clone().iand(this);
    }, o.prototype.uand = function(c) {
      return this.length > c.length ? this.clone().iuand(c) : c.clone().iuand(this);
    }, o.prototype.iuxor = function(c) {
      var b, C;
      this.length > c.length ? (b = this, C = c) : (b = c, C = this);
      for (var x = 0; x < C.length; x++)
        this.words[x] = b.words[x] ^ C.words[x];
      if (this !== b)
        for (; x < b.length; x++)
          this.words[x] = b.words[x];
      return this.length = b.length, this._strip();
    }, o.prototype.ixor = function(c) {
      return n((this.negative | c.negative) === 0), this.iuxor(c);
    }, o.prototype.xor = function(c) {
      return this.length > c.length ? this.clone().ixor(c) : c.clone().ixor(this);
    }, o.prototype.uxor = function(c) {
      return this.length > c.length ? this.clone().iuxor(c) : c.clone().iuxor(this);
    }, o.prototype.inotn = function(c) {
      n(typeof c == "number" && c >= 0);
      var b = Math.ceil(c / 26) | 0, C = c % 26;
      this._expand(b), C > 0 && b--;
      for (var x = 0; x < b; x++)
        this.words[x] = ~this.words[x] & 67108863;
      return C > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - C), this._strip();
    }, o.prototype.notn = function(c) {
      return this.clone().inotn(c);
    }, o.prototype.setn = function(c, b) {
      n(typeof c == "number" && c >= 0);
      var C = c / 26 | 0, x = c % 26;
      return this._expand(C + 1), b ? this.words[C] = this.words[C] | 1 << x : this.words[C] = this.words[C] & ~(1 << x), this._strip();
    }, o.prototype.iadd = function(c) {
      var b;
      if (this.negative !== 0 && c.negative === 0)
        return this.negative = 0, b = this.isub(c), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && c.negative !== 0)
        return c.negative = 0, b = this.isub(c), c.negative = 1, b._normSign();
      var C, x;
      this.length > c.length ? (C = this, x = c) : (C = c, x = this);
      for (var B = 0, k = 0; k < x.length; k++)
        b = (C.words[k] | 0) + (x.words[k] | 0) + B, this.words[k] = b & 67108863, B = b >>> 26;
      for (; B !== 0 && k < C.length; k++)
        b = (C.words[k] | 0) + B, this.words[k] = b & 67108863, B = b >>> 26;
      if (this.length = C.length, B !== 0)
        this.words[this.length] = B, this.length++;
      else if (C !== this)
        for (; k < C.length; k++)
          this.words[k] = C.words[k];
      return this;
    }, o.prototype.add = function(c) {
      var b;
      return c.negative !== 0 && this.negative === 0 ? (c.negative = 0, b = this.sub(c), c.negative ^= 1, b) : c.negative === 0 && this.negative !== 0 ? (this.negative = 0, b = c.sub(this), this.negative = 1, b) : this.length > c.length ? this.clone().iadd(c) : c.clone().iadd(this);
    }, o.prototype.isub = function(c) {
      if (c.negative !== 0) {
        c.negative = 0;
        var b = this.iadd(c);
        return c.negative = 1, b._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(c), this.negative = 1, this._normSign();
      var C = this.cmp(c);
      if (C === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var x, B;
      C > 0 ? (x = this, B = c) : (x = c, B = this);
      for (var k = 0, w = 0; w < B.length; w++)
        b = (x.words[w] | 0) - (B.words[w] | 0) + k, k = b >> 26, this.words[w] = b & 67108863;
      for (; k !== 0 && w < x.length; w++)
        b = (x.words[w] | 0) + k, k = b >> 26, this.words[w] = b & 67108863;
      if (k === 0 && w < x.length && x !== this)
        for (; w < x.length; w++)
          this.words[w] = x.words[w];
      return this.length = Math.max(this.length, w), x !== this && (this.negative = 1), this._strip();
    }, o.prototype.sub = function(c) {
      return this.clone().isub(c);
    };
    function ee(E, c, b) {
      b.negative = c.negative ^ E.negative;
      var C = E.length + c.length | 0;
      b.length = C, C = C - 1 | 0;
      var x = E.words[0] | 0, B = c.words[0] | 0, k = x * B, w = k & 67108863, T = k / 67108864 | 0;
      b.words[0] = w;
      for (var p = 1; p < C; p++) {
        for (var F = T >>> 26, ye = T & 67108863, _e = Math.min(p, c.length - 1), de = Math.max(0, p - E.length + 1); de <= _e; de++) {
          var P = p - de | 0;
          x = E.words[P] | 0, B = c.words[de] | 0, k = x * B + ye, F += k / 67108864 | 0, ye = k & 67108863;
        }
        b.words[p] = ye | 0, T = F | 0;
      }
      return T !== 0 ? b.words[p] = T | 0 : b.length--, b._strip();
    }
    var ne = function(c, b, C) {
      var x = c.words, B = b.words, k = C.words, w = 0, T, p, F, ye = x[0] | 0, _e = ye & 8191, de = ye >>> 13, P = x[1] | 0, H = P & 8191, he = P >>> 13, me = x[2] | 0, fe = me & 8191, re = me >>> 13, we = x[3] | 0, ke = we & 8191, Oe = we >>> 13, ce = x[4] | 0, j = ce & 8191, z = ce >>> 13, oe = x[5] | 0, Be = oe & 8191, Te = oe >>> 13, Pe = x[6] | 0, Ye = Pe & 8191, He = Pe >>> 13, ot = x[7] | 0, at = ot & 8191, Qe = ot >>> 13, Pt = x[8] | 0, It = Pt & 8191, pt = Pt >>> 13, Wt = x[9] | 0, Mt = Wt & 8191, vt = Wt >>> 13, Vt = B[0] | 0, Ct = Vt & 8191, lt = Vt >>> 13, zt = B[1] | 0, Tt = zt & 8191, dt = zt >>> 13, Yt = B[2] | 0, Dt = Yt & 8191, bt = Yt >>> 13, Jt = B[3] | 0, Bt = Jt & 8191, ut = Jt >>> 13, Ht = B[4] | 0, Rt = Ht & 8191, gt = Ht >>> 13, Qt = B[5] | 0, kt = Qt & 8191, rt = Qt >>> 13, Xt = B[6] | 0, J = Xt & 8191, ae = Xt >>> 13, ue = B[7] | 0, q = ue & 8191, le = ue >>> 13, Ce = B[8] | 0, Se = Ce & 8191, Ie = Ce >>> 13, Ve = B[9] | 0, Ge = Ve & 8191, qe = Ve >>> 13;
      C.negative = c.negative ^ b.negative, C.length = 19, T = Math.imul(_e, Ct), p = Math.imul(_e, lt), p = p + Math.imul(de, Ct) | 0, F = Math.imul(de, lt);
      var Nt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, T = Math.imul(H, Ct), p = Math.imul(H, lt), p = p + Math.imul(he, Ct) | 0, F = Math.imul(he, lt), T = T + Math.imul(_e, Tt) | 0, p = p + Math.imul(_e, dt) | 0, p = p + Math.imul(de, Tt) | 0, F = F + Math.imul(de, dt) | 0;
      var et = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, T = Math.imul(fe, Ct), p = Math.imul(fe, lt), p = p + Math.imul(re, Ct) | 0, F = Math.imul(re, lt), T = T + Math.imul(H, Tt) | 0, p = p + Math.imul(H, dt) | 0, p = p + Math.imul(he, Tt) | 0, F = F + Math.imul(he, dt) | 0, T = T + Math.imul(_e, Dt) | 0, p = p + Math.imul(_e, bt) | 0, p = p + Math.imul(de, Dt) | 0, F = F + Math.imul(de, bt) | 0;
      var _t = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, T = Math.imul(ke, Ct), p = Math.imul(ke, lt), p = p + Math.imul(Oe, Ct) | 0, F = Math.imul(Oe, lt), T = T + Math.imul(fe, Tt) | 0, p = p + Math.imul(fe, dt) | 0, p = p + Math.imul(re, Tt) | 0, F = F + Math.imul(re, dt) | 0, T = T + Math.imul(H, Dt) | 0, p = p + Math.imul(H, bt) | 0, p = p + Math.imul(he, Dt) | 0, F = F + Math.imul(he, bt) | 0, T = T + Math.imul(_e, Bt) | 0, p = p + Math.imul(_e, ut) | 0, p = p + Math.imul(de, Bt) | 0, F = F + Math.imul(de, ut) | 0;
      var $t = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, T = Math.imul(j, Ct), p = Math.imul(j, lt), p = p + Math.imul(z, Ct) | 0, F = Math.imul(z, lt), T = T + Math.imul(ke, Tt) | 0, p = p + Math.imul(ke, dt) | 0, p = p + Math.imul(Oe, Tt) | 0, F = F + Math.imul(Oe, dt) | 0, T = T + Math.imul(fe, Dt) | 0, p = p + Math.imul(fe, bt) | 0, p = p + Math.imul(re, Dt) | 0, F = F + Math.imul(re, bt) | 0, T = T + Math.imul(H, Bt) | 0, p = p + Math.imul(H, ut) | 0, p = p + Math.imul(he, Bt) | 0, F = F + Math.imul(he, ut) | 0, T = T + Math.imul(_e, Rt) | 0, p = p + Math.imul(_e, gt) | 0, p = p + Math.imul(de, Rt) | 0, F = F + Math.imul(de, gt) | 0;
      var St = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, T = Math.imul(Be, Ct), p = Math.imul(Be, lt), p = p + Math.imul(Te, Ct) | 0, F = Math.imul(Te, lt), T = T + Math.imul(j, Tt) | 0, p = p + Math.imul(j, dt) | 0, p = p + Math.imul(z, Tt) | 0, F = F + Math.imul(z, dt) | 0, T = T + Math.imul(ke, Dt) | 0, p = p + Math.imul(ke, bt) | 0, p = p + Math.imul(Oe, Dt) | 0, F = F + Math.imul(Oe, bt) | 0, T = T + Math.imul(fe, Bt) | 0, p = p + Math.imul(fe, ut) | 0, p = p + Math.imul(re, Bt) | 0, F = F + Math.imul(re, ut) | 0, T = T + Math.imul(H, Rt) | 0, p = p + Math.imul(H, gt) | 0, p = p + Math.imul(he, Rt) | 0, F = F + Math.imul(he, gt) | 0, T = T + Math.imul(_e, kt) | 0, p = p + Math.imul(_e, rt) | 0, p = p + Math.imul(de, kt) | 0, F = F + Math.imul(de, rt) | 0;
      var mt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, T = Math.imul(Ye, Ct), p = Math.imul(Ye, lt), p = p + Math.imul(He, Ct) | 0, F = Math.imul(He, lt), T = T + Math.imul(Be, Tt) | 0, p = p + Math.imul(Be, dt) | 0, p = p + Math.imul(Te, Tt) | 0, F = F + Math.imul(Te, dt) | 0, T = T + Math.imul(j, Dt) | 0, p = p + Math.imul(j, bt) | 0, p = p + Math.imul(z, Dt) | 0, F = F + Math.imul(z, bt) | 0, T = T + Math.imul(ke, Bt) | 0, p = p + Math.imul(ke, ut) | 0, p = p + Math.imul(Oe, Bt) | 0, F = F + Math.imul(Oe, ut) | 0, T = T + Math.imul(fe, Rt) | 0, p = p + Math.imul(fe, gt) | 0, p = p + Math.imul(re, Rt) | 0, F = F + Math.imul(re, gt) | 0, T = T + Math.imul(H, kt) | 0, p = p + Math.imul(H, rt) | 0, p = p + Math.imul(he, kt) | 0, F = F + Math.imul(he, rt) | 0, T = T + Math.imul(_e, J) | 0, p = p + Math.imul(_e, ae) | 0, p = p + Math.imul(de, J) | 0, F = F + Math.imul(de, ae) | 0;
      var xt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, T = Math.imul(at, Ct), p = Math.imul(at, lt), p = p + Math.imul(Qe, Ct) | 0, F = Math.imul(Qe, lt), T = T + Math.imul(Ye, Tt) | 0, p = p + Math.imul(Ye, dt) | 0, p = p + Math.imul(He, Tt) | 0, F = F + Math.imul(He, dt) | 0, T = T + Math.imul(Be, Dt) | 0, p = p + Math.imul(Be, bt) | 0, p = p + Math.imul(Te, Dt) | 0, F = F + Math.imul(Te, bt) | 0, T = T + Math.imul(j, Bt) | 0, p = p + Math.imul(j, ut) | 0, p = p + Math.imul(z, Bt) | 0, F = F + Math.imul(z, ut) | 0, T = T + Math.imul(ke, Rt) | 0, p = p + Math.imul(ke, gt) | 0, p = p + Math.imul(Oe, Rt) | 0, F = F + Math.imul(Oe, gt) | 0, T = T + Math.imul(fe, kt) | 0, p = p + Math.imul(fe, rt) | 0, p = p + Math.imul(re, kt) | 0, F = F + Math.imul(re, rt) | 0, T = T + Math.imul(H, J) | 0, p = p + Math.imul(H, ae) | 0, p = p + Math.imul(he, J) | 0, F = F + Math.imul(he, ae) | 0, T = T + Math.imul(_e, q) | 0, p = p + Math.imul(_e, le) | 0, p = p + Math.imul(de, q) | 0, F = F + Math.imul(de, le) | 0;
      var Et = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, T = Math.imul(It, Ct), p = Math.imul(It, lt), p = p + Math.imul(pt, Ct) | 0, F = Math.imul(pt, lt), T = T + Math.imul(at, Tt) | 0, p = p + Math.imul(at, dt) | 0, p = p + Math.imul(Qe, Tt) | 0, F = F + Math.imul(Qe, dt) | 0, T = T + Math.imul(Ye, Dt) | 0, p = p + Math.imul(Ye, bt) | 0, p = p + Math.imul(He, Dt) | 0, F = F + Math.imul(He, bt) | 0, T = T + Math.imul(Be, Bt) | 0, p = p + Math.imul(Be, ut) | 0, p = p + Math.imul(Te, Bt) | 0, F = F + Math.imul(Te, ut) | 0, T = T + Math.imul(j, Rt) | 0, p = p + Math.imul(j, gt) | 0, p = p + Math.imul(z, Rt) | 0, F = F + Math.imul(z, gt) | 0, T = T + Math.imul(ke, kt) | 0, p = p + Math.imul(ke, rt) | 0, p = p + Math.imul(Oe, kt) | 0, F = F + Math.imul(Oe, rt) | 0, T = T + Math.imul(fe, J) | 0, p = p + Math.imul(fe, ae) | 0, p = p + Math.imul(re, J) | 0, F = F + Math.imul(re, ae) | 0, T = T + Math.imul(H, q) | 0, p = p + Math.imul(H, le) | 0, p = p + Math.imul(he, q) | 0, F = F + Math.imul(he, le) | 0, T = T + Math.imul(_e, Se) | 0, p = p + Math.imul(_e, Ie) | 0, p = p + Math.imul(de, Se) | 0, F = F + Math.imul(de, Ie) | 0;
      var wt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, T = Math.imul(Mt, Ct), p = Math.imul(Mt, lt), p = p + Math.imul(vt, Ct) | 0, F = Math.imul(vt, lt), T = T + Math.imul(It, Tt) | 0, p = p + Math.imul(It, dt) | 0, p = p + Math.imul(pt, Tt) | 0, F = F + Math.imul(pt, dt) | 0, T = T + Math.imul(at, Dt) | 0, p = p + Math.imul(at, bt) | 0, p = p + Math.imul(Qe, Dt) | 0, F = F + Math.imul(Qe, bt) | 0, T = T + Math.imul(Ye, Bt) | 0, p = p + Math.imul(Ye, ut) | 0, p = p + Math.imul(He, Bt) | 0, F = F + Math.imul(He, ut) | 0, T = T + Math.imul(Be, Rt) | 0, p = p + Math.imul(Be, gt) | 0, p = p + Math.imul(Te, Rt) | 0, F = F + Math.imul(Te, gt) | 0, T = T + Math.imul(j, kt) | 0, p = p + Math.imul(j, rt) | 0, p = p + Math.imul(z, kt) | 0, F = F + Math.imul(z, rt) | 0, T = T + Math.imul(ke, J) | 0, p = p + Math.imul(ke, ae) | 0, p = p + Math.imul(Oe, J) | 0, F = F + Math.imul(Oe, ae) | 0, T = T + Math.imul(fe, q) | 0, p = p + Math.imul(fe, le) | 0, p = p + Math.imul(re, q) | 0, F = F + Math.imul(re, le) | 0, T = T + Math.imul(H, Se) | 0, p = p + Math.imul(H, Ie) | 0, p = p + Math.imul(he, Se) | 0, F = F + Math.imul(he, Ie) | 0, T = T + Math.imul(_e, Ge) | 0, p = p + Math.imul(_e, qe) | 0, p = p + Math.imul(de, Ge) | 0, F = F + Math.imul(de, qe) | 0;
      var tt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, T = Math.imul(Mt, Tt), p = Math.imul(Mt, dt), p = p + Math.imul(vt, Tt) | 0, F = Math.imul(vt, dt), T = T + Math.imul(It, Dt) | 0, p = p + Math.imul(It, bt) | 0, p = p + Math.imul(pt, Dt) | 0, F = F + Math.imul(pt, bt) | 0, T = T + Math.imul(at, Bt) | 0, p = p + Math.imul(at, ut) | 0, p = p + Math.imul(Qe, Bt) | 0, F = F + Math.imul(Qe, ut) | 0, T = T + Math.imul(Ye, Rt) | 0, p = p + Math.imul(Ye, gt) | 0, p = p + Math.imul(He, Rt) | 0, F = F + Math.imul(He, gt) | 0, T = T + Math.imul(Be, kt) | 0, p = p + Math.imul(Be, rt) | 0, p = p + Math.imul(Te, kt) | 0, F = F + Math.imul(Te, rt) | 0, T = T + Math.imul(j, J) | 0, p = p + Math.imul(j, ae) | 0, p = p + Math.imul(z, J) | 0, F = F + Math.imul(z, ae) | 0, T = T + Math.imul(ke, q) | 0, p = p + Math.imul(ke, le) | 0, p = p + Math.imul(Oe, q) | 0, F = F + Math.imul(Oe, le) | 0, T = T + Math.imul(fe, Se) | 0, p = p + Math.imul(fe, Ie) | 0, p = p + Math.imul(re, Se) | 0, F = F + Math.imul(re, Ie) | 0, T = T + Math.imul(H, Ge) | 0, p = p + Math.imul(H, qe) | 0, p = p + Math.imul(he, Ge) | 0, F = F + Math.imul(he, qe) | 0;
      var ht = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, T = Math.imul(Mt, Dt), p = Math.imul(Mt, bt), p = p + Math.imul(vt, Dt) | 0, F = Math.imul(vt, bt), T = T + Math.imul(It, Bt) | 0, p = p + Math.imul(It, ut) | 0, p = p + Math.imul(pt, Bt) | 0, F = F + Math.imul(pt, ut) | 0, T = T + Math.imul(at, Rt) | 0, p = p + Math.imul(at, gt) | 0, p = p + Math.imul(Qe, Rt) | 0, F = F + Math.imul(Qe, gt) | 0, T = T + Math.imul(Ye, kt) | 0, p = p + Math.imul(Ye, rt) | 0, p = p + Math.imul(He, kt) | 0, F = F + Math.imul(He, rt) | 0, T = T + Math.imul(Be, J) | 0, p = p + Math.imul(Be, ae) | 0, p = p + Math.imul(Te, J) | 0, F = F + Math.imul(Te, ae) | 0, T = T + Math.imul(j, q) | 0, p = p + Math.imul(j, le) | 0, p = p + Math.imul(z, q) | 0, F = F + Math.imul(z, le) | 0, T = T + Math.imul(ke, Se) | 0, p = p + Math.imul(ke, Ie) | 0, p = p + Math.imul(Oe, Se) | 0, F = F + Math.imul(Oe, Ie) | 0, T = T + Math.imul(fe, Ge) | 0, p = p + Math.imul(fe, qe) | 0, p = p + Math.imul(re, Ge) | 0, F = F + Math.imul(re, qe) | 0;
      var Je = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, T = Math.imul(Mt, Bt), p = Math.imul(Mt, ut), p = p + Math.imul(vt, Bt) | 0, F = Math.imul(vt, ut), T = T + Math.imul(It, Rt) | 0, p = p + Math.imul(It, gt) | 0, p = p + Math.imul(pt, Rt) | 0, F = F + Math.imul(pt, gt) | 0, T = T + Math.imul(at, kt) | 0, p = p + Math.imul(at, rt) | 0, p = p + Math.imul(Qe, kt) | 0, F = F + Math.imul(Qe, rt) | 0, T = T + Math.imul(Ye, J) | 0, p = p + Math.imul(Ye, ae) | 0, p = p + Math.imul(He, J) | 0, F = F + Math.imul(He, ae) | 0, T = T + Math.imul(Be, q) | 0, p = p + Math.imul(Be, le) | 0, p = p + Math.imul(Te, q) | 0, F = F + Math.imul(Te, le) | 0, T = T + Math.imul(j, Se) | 0, p = p + Math.imul(j, Ie) | 0, p = p + Math.imul(z, Se) | 0, F = F + Math.imul(z, Ie) | 0, T = T + Math.imul(ke, Ge) | 0, p = p + Math.imul(ke, qe) | 0, p = p + Math.imul(Oe, Ge) | 0, F = F + Math.imul(Oe, qe) | 0;
      var it = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, T = Math.imul(Mt, Rt), p = Math.imul(Mt, gt), p = p + Math.imul(vt, Rt) | 0, F = Math.imul(vt, gt), T = T + Math.imul(It, kt) | 0, p = p + Math.imul(It, rt) | 0, p = p + Math.imul(pt, kt) | 0, F = F + Math.imul(pt, rt) | 0, T = T + Math.imul(at, J) | 0, p = p + Math.imul(at, ae) | 0, p = p + Math.imul(Qe, J) | 0, F = F + Math.imul(Qe, ae) | 0, T = T + Math.imul(Ye, q) | 0, p = p + Math.imul(Ye, le) | 0, p = p + Math.imul(He, q) | 0, F = F + Math.imul(He, le) | 0, T = T + Math.imul(Be, Se) | 0, p = p + Math.imul(Be, Ie) | 0, p = p + Math.imul(Te, Se) | 0, F = F + Math.imul(Te, Ie) | 0, T = T + Math.imul(j, Ge) | 0, p = p + Math.imul(j, qe) | 0, p = p + Math.imul(z, Ge) | 0, F = F + Math.imul(z, qe) | 0;
      var nt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, T = Math.imul(Mt, kt), p = Math.imul(Mt, rt), p = p + Math.imul(vt, kt) | 0, F = Math.imul(vt, rt), T = T + Math.imul(It, J) | 0, p = p + Math.imul(It, ae) | 0, p = p + Math.imul(pt, J) | 0, F = F + Math.imul(pt, ae) | 0, T = T + Math.imul(at, q) | 0, p = p + Math.imul(at, le) | 0, p = p + Math.imul(Qe, q) | 0, F = F + Math.imul(Qe, le) | 0, T = T + Math.imul(Ye, Se) | 0, p = p + Math.imul(Ye, Ie) | 0, p = p + Math.imul(He, Se) | 0, F = F + Math.imul(He, Ie) | 0, T = T + Math.imul(Be, Ge) | 0, p = p + Math.imul(Be, qe) | 0, p = p + Math.imul(Te, Ge) | 0, F = F + Math.imul(Te, qe) | 0;
      var Ze = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, T = Math.imul(Mt, J), p = Math.imul(Mt, ae), p = p + Math.imul(vt, J) | 0, F = Math.imul(vt, ae), T = T + Math.imul(It, q) | 0, p = p + Math.imul(It, le) | 0, p = p + Math.imul(pt, q) | 0, F = F + Math.imul(pt, le) | 0, T = T + Math.imul(at, Se) | 0, p = p + Math.imul(at, Ie) | 0, p = p + Math.imul(Qe, Se) | 0, F = F + Math.imul(Qe, Ie) | 0, T = T + Math.imul(Ye, Ge) | 0, p = p + Math.imul(Ye, qe) | 0, p = p + Math.imul(He, Ge) | 0, F = F + Math.imul(He, qe) | 0;
      var Me = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, T = Math.imul(Mt, q), p = Math.imul(Mt, le), p = p + Math.imul(vt, q) | 0, F = Math.imul(vt, le), T = T + Math.imul(It, Se) | 0, p = p + Math.imul(It, Ie) | 0, p = p + Math.imul(pt, Se) | 0, F = F + Math.imul(pt, Ie) | 0, T = T + Math.imul(at, Ge) | 0, p = p + Math.imul(at, qe) | 0, p = p + Math.imul(Qe, Ge) | 0, F = F + Math.imul(Qe, qe) | 0;
      var De = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, T = Math.imul(Mt, Se), p = Math.imul(Mt, Ie), p = p + Math.imul(vt, Se) | 0, F = Math.imul(vt, Ie), T = T + Math.imul(It, Ge) | 0, p = p + Math.imul(It, qe) | 0, p = p + Math.imul(pt, Ge) | 0, F = F + Math.imul(pt, qe) | 0;
      var ze = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, T = Math.imul(Mt, Ge), p = Math.imul(Mt, qe), p = p + Math.imul(vt, Ge) | 0, F = Math.imul(vt, qe);
      var Ue = (w + T | 0) + ((p & 8191) << 13) | 0;
      return w = (F + (p >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, k[0] = Nt, k[1] = et, k[2] = _t, k[3] = $t, k[4] = St, k[5] = mt, k[6] = xt, k[7] = Et, k[8] = wt, k[9] = tt, k[10] = ht, k[11] = Je, k[12] = it, k[13] = nt, k[14] = Ze, k[15] = Me, k[16] = De, k[17] = ze, k[18] = Ue, w !== 0 && (k[19] = w, C.length++), C;
    };
    Math.imul || (ne = ee);
    function ge(E, c, b) {
      b.negative = c.negative ^ E.negative, b.length = E.length + c.length;
      for (var C = 0, x = 0, B = 0; B < b.length - 1; B++) {
        var k = x;
        x = 0;
        for (var w = C & 67108863, T = Math.min(B, c.length - 1), p = Math.max(0, B - E.length + 1); p <= T; p++) {
          var F = B - p, ye = E.words[F] | 0, _e = c.words[p] | 0, de = ye * _e, P = de & 67108863;
          k = k + (de / 67108864 | 0) | 0, P = P + w | 0, w = P & 67108863, k = k + (P >>> 26) | 0, x += k >>> 26, k &= 67108863;
        }
        b.words[B] = w, C = k, k = x;
      }
      return C !== 0 ? b.words[B] = C : b.length--, b._strip();
    }
    function be(E, c, b) {
      return ge(E, c, b);
    }
    o.prototype.mulTo = function(c, b) {
      var C, x = this.length + c.length;
      return this.length === 10 && c.length === 10 ? C = ne(this, c, b) : x < 63 ? C = ee(this, c, b) : x < 1024 ? C = ge(this, c, b) : C = be(this, c, b), C;
    }, o.prototype.mul = function(c) {
      var b = new o(null);
      return b.words = new Array(this.length + c.length), this.mulTo(c, b);
    }, o.prototype.mulf = function(c) {
      var b = new o(null);
      return b.words = new Array(this.length + c.length), be(this, c, b);
    }, o.prototype.imul = function(c) {
      return this.clone().mulTo(c, this);
    }, o.prototype.imuln = function(c) {
      var b = c < 0;
      b && (c = -c), n(typeof c == "number"), n(c < 67108864);
      for (var C = 0, x = 0; x < this.length; x++) {
        var B = (this.words[x] | 0) * c, k = (B & 67108863) + (C & 67108863);
        C >>= 26, C += B / 67108864 | 0, C += k >>> 26, this.words[x] = k & 67108863;
      }
      return C !== 0 && (this.words[x] = C, this.length++), this.length = c === 0 ? 1 : this.length, b ? this.ineg() : this;
    }, o.prototype.muln = function(c) {
      return this.clone().imuln(c);
    }, o.prototype.sqr = function() {
      return this.mul(this);
    }, o.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o.prototype.pow = function(c) {
      var b = ie(c);
      if (b.length === 0)
        return new o(1);
      for (var C = this, x = 0; x < b.length && b[x] === 0; x++, C = C.sqr())
        ;
      if (++x < b.length)
        for (var B = C.sqr(); x < b.length; x++, B = B.sqr())
          b[x] !== 0 && (C = C.mul(B));
      return C;
    }, o.prototype.iushln = function(c) {
      n(typeof c == "number" && c >= 0);
      var b = c % 26, C = (c - b) / 26, x = 67108863 >>> 26 - b << 26 - b, B;
      if (b !== 0) {
        var k = 0;
        for (B = 0; B < this.length; B++) {
          var w = this.words[B] & x, T = (this.words[B] | 0) - w << b;
          this.words[B] = T | k, k = w >>> 26 - b;
        }
        k && (this.words[B] = k, this.length++);
      }
      if (C !== 0) {
        for (B = this.length - 1; B >= 0; B--)
          this.words[B + C] = this.words[B];
        for (B = 0; B < C; B++)
          this.words[B] = 0;
        this.length += C;
      }
      return this._strip();
    }, o.prototype.ishln = function(c) {
      return n(this.negative === 0), this.iushln(c);
    }, o.prototype.iushrn = function(c, b, C) {
      n(typeof c == "number" && c >= 0);
      var x;
      b ? x = (b - b % 26) / 26 : x = 0;
      var B = c % 26, k = Math.min((c - B) / 26, this.length), w = 67108863 ^ 67108863 >>> B << B, T = C;
      if (x -= k, x = Math.max(0, x), T) {
        for (var p = 0; p < k; p++)
          T.words[p] = this.words[p];
        T.length = k;
      }
      if (k !== 0)
        if (this.length > k)
          for (this.length -= k, p = 0; p < this.length; p++)
            this.words[p] = this.words[p + k];
        else
          this.words[0] = 0, this.length = 1;
      var F = 0;
      for (p = this.length - 1; p >= 0 && (F !== 0 || p >= x); p--) {
        var ye = this.words[p] | 0;
        this.words[p] = F << 26 - B | ye >>> B, F = ye & w;
      }
      return T && F !== 0 && (T.words[T.length++] = F), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, o.prototype.ishrn = function(c, b, C) {
      return n(this.negative === 0), this.iushrn(c, b, C);
    }, o.prototype.shln = function(c) {
      return this.clone().ishln(c);
    }, o.prototype.ushln = function(c) {
      return this.clone().iushln(c);
    }, o.prototype.shrn = function(c) {
      return this.clone().ishrn(c);
    }, o.prototype.ushrn = function(c) {
      return this.clone().iushrn(c);
    }, o.prototype.testn = function(c) {
      n(typeof c == "number" && c >= 0);
      var b = c % 26, C = (c - b) / 26, x = 1 << b;
      if (this.length <= C)
        return !1;
      var B = this.words[C];
      return !!(B & x);
    }, o.prototype.imaskn = function(c) {
      n(typeof c == "number" && c >= 0);
      var b = c % 26, C = (c - b) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= C)
        return this;
      if (b !== 0 && C++, this.length = Math.min(C, this.length), b !== 0) {
        var x = 67108863 ^ 67108863 >>> b << b;
        this.words[this.length - 1] &= x;
      }
      return this._strip();
    }, o.prototype.maskn = function(c) {
      return this.clone().imaskn(c);
    }, o.prototype.iaddn = function(c) {
      return n(typeof c == "number"), n(c < 67108864), c < 0 ? this.isubn(-c) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= c ? (this.words[0] = c - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(c), this.negative = 1, this) : this._iaddn(c);
    }, o.prototype._iaddn = function(c) {
      this.words[0] += c;
      for (var b = 0; b < this.length && this.words[b] >= 67108864; b++)
        this.words[b] -= 67108864, b === this.length - 1 ? this.words[b + 1] = 1 : this.words[b + 1]++;
      return this.length = Math.max(this.length, b + 1), this;
    }, o.prototype.isubn = function(c) {
      if (n(typeof c == "number"), n(c < 67108864), c < 0)
        return this.iaddn(-c);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(c), this.negative = 1, this;
      if (this.words[0] -= c, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var b = 0; b < this.length && this.words[b] < 0; b++)
          this.words[b] += 67108864, this.words[b + 1] -= 1;
      return this._strip();
    }, o.prototype.addn = function(c) {
      return this.clone().iaddn(c);
    }, o.prototype.subn = function(c) {
      return this.clone().isubn(c);
    }, o.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o.prototype.abs = function() {
      return this.clone().iabs();
    }, o.prototype._ishlnsubmul = function(c, b, C) {
      var x = c.length + C, B;
      this._expand(x);
      var k, w = 0;
      for (B = 0; B < c.length; B++) {
        k = (this.words[B + C] | 0) + w;
        var T = (c.words[B] | 0) * b;
        k -= T & 67108863, w = (k >> 26) - (T / 67108864 | 0), this.words[B + C] = k & 67108863;
      }
      for (; B < this.length - C; B++)
        k = (this.words[B + C] | 0) + w, w = k >> 26, this.words[B + C] = k & 67108863;
      if (w === 0)
        return this._strip();
      for (n(w === -1), w = 0, B = 0; B < this.length; B++)
        k = -(this.words[B] | 0) + w, w = k >> 26, this.words[B] = k & 67108863;
      return this.negative = 1, this._strip();
    }, o.prototype._wordDiv = function(c, b) {
      var C = this.length - c.length, x = this.clone(), B = c, k = B.words[B.length - 1] | 0, w = this._countBits(k);
      C = 26 - w, C !== 0 && (B = B.ushln(C), x.iushln(C), k = B.words[B.length - 1] | 0);
      var T = x.length - B.length, p;
      if (b !== "mod") {
        p = new o(null), p.length = T + 1, p.words = new Array(p.length);
        for (var F = 0; F < p.length; F++)
          p.words[F] = 0;
      }
      var ye = x.clone()._ishlnsubmul(B, 1, T);
      ye.negative === 0 && (x = ye, p && (p.words[T] = 1));
      for (var _e = T - 1; _e >= 0; _e--) {
        var de = (x.words[B.length + _e] | 0) * 67108864 + (x.words[B.length + _e - 1] | 0);
        for (de = Math.min(de / k | 0, 67108863), x._ishlnsubmul(B, de, _e); x.negative !== 0; )
          de--, x.negative = 0, x._ishlnsubmul(B, 1, _e), x.isZero() || (x.negative ^= 1);
        p && (p.words[_e] = de);
      }
      return p && p._strip(), x._strip(), b !== "div" && C !== 0 && x.iushrn(C), {
        div: p || null,
        mod: x
      };
    }, o.prototype.divmod = function(c, b, C) {
      if (n(!c.isZero()), this.isZero())
        return {
          div: new o(0),
          mod: new o(0)
        };
      var x, B, k;
      return this.negative !== 0 && c.negative === 0 ? (k = this.neg().divmod(c, b), b !== "mod" && (x = k.div.neg()), b !== "div" && (B = k.mod.neg(), C && B.negative !== 0 && B.iadd(c)), {
        div: x,
        mod: B
      }) : this.negative === 0 && c.negative !== 0 ? (k = this.divmod(c.neg(), b), b !== "mod" && (x = k.div.neg()), {
        div: x,
        mod: k.mod
      }) : this.negative & c.negative ? (k = this.neg().divmod(c.neg(), b), b !== "div" && (B = k.mod.neg(), C && B.negative !== 0 && B.isub(c)), {
        div: k.div,
        mod: B
      }) : c.length > this.length || this.cmp(c) < 0 ? {
        div: new o(0),
        mod: this
      } : c.length === 1 ? b === "div" ? {
        div: this.divn(c.words[0]),
        mod: null
      } : b === "mod" ? {
        div: null,
        mod: new o(this.modrn(c.words[0]))
      } : {
        div: this.divn(c.words[0]),
        mod: new o(this.modrn(c.words[0]))
      } : this._wordDiv(c, b);
    }, o.prototype.div = function(c) {
      return this.divmod(c, "div", !1).div;
    }, o.prototype.mod = function(c) {
      return this.divmod(c, "mod", !1).mod;
    }, o.prototype.umod = function(c) {
      return this.divmod(c, "mod", !0).mod;
    }, o.prototype.divRound = function(c) {
      var b = this.divmod(c);
      if (b.mod.isZero())
        return b.div;
      var C = b.div.negative !== 0 ? b.mod.isub(c) : b.mod, x = c.ushrn(1), B = c.andln(1), k = C.cmp(x);
      return k < 0 || B === 1 && k === 0 ? b.div : b.div.negative !== 0 ? b.div.isubn(1) : b.div.iaddn(1);
    }, o.prototype.modrn = function(c) {
      var b = c < 0;
      b && (c = -c), n(c <= 67108863);
      for (var C = (1 << 26) % c, x = 0, B = this.length - 1; B >= 0; B--)
        x = (C * x + (this.words[B] | 0)) % c;
      return b ? -x : x;
    }, o.prototype.modn = function(c) {
      return this.modrn(c);
    }, o.prototype.idivn = function(c) {
      var b = c < 0;
      b && (c = -c), n(c <= 67108863);
      for (var C = 0, x = this.length - 1; x >= 0; x--) {
        var B = (this.words[x] | 0) + C * 67108864;
        this.words[x] = B / c | 0, C = B % c;
      }
      return this._strip(), b ? this.ineg() : this;
    }, o.prototype.divn = function(c) {
      return this.clone().idivn(c);
    }, o.prototype.egcd = function(c) {
      n(c.negative === 0), n(!c.isZero());
      var b = this, C = c.clone();
      b.negative !== 0 ? b = b.umod(c) : b = b.clone();
      for (var x = new o(1), B = new o(0), k = new o(0), w = new o(1), T = 0; b.isEven() && C.isEven(); )
        b.iushrn(1), C.iushrn(1), ++T;
      for (var p = C.clone(), F = b.clone(); !b.isZero(); ) {
        for (var ye = 0, _e = 1; !(b.words[0] & _e) && ye < 26; ++ye, _e <<= 1)
          ;
        if (ye > 0)
          for (b.iushrn(ye); ye-- > 0; )
            (x.isOdd() || B.isOdd()) && (x.iadd(p), B.isub(F)), x.iushrn(1), B.iushrn(1);
        for (var de = 0, P = 1; !(C.words[0] & P) && de < 26; ++de, P <<= 1)
          ;
        if (de > 0)
          for (C.iushrn(de); de-- > 0; )
            (k.isOdd() || w.isOdd()) && (k.iadd(p), w.isub(F)), k.iushrn(1), w.iushrn(1);
        b.cmp(C) >= 0 ? (b.isub(C), x.isub(k), B.isub(w)) : (C.isub(b), k.isub(x), w.isub(B));
      }
      return {
        a: k,
        b: w,
        gcd: C.iushln(T)
      };
    }, o.prototype._invmp = function(c) {
      n(c.negative === 0), n(!c.isZero());
      var b = this, C = c.clone();
      b.negative !== 0 ? b = b.umod(c) : b = b.clone();
      for (var x = new o(1), B = new o(0), k = C.clone(); b.cmpn(1) > 0 && C.cmpn(1) > 0; ) {
        for (var w = 0, T = 1; !(b.words[0] & T) && w < 26; ++w, T <<= 1)
          ;
        if (w > 0)
          for (b.iushrn(w); w-- > 0; )
            x.isOdd() && x.iadd(k), x.iushrn(1);
        for (var p = 0, F = 1; !(C.words[0] & F) && p < 26; ++p, F <<= 1)
          ;
        if (p > 0)
          for (C.iushrn(p); p-- > 0; )
            B.isOdd() && B.iadd(k), B.iushrn(1);
        b.cmp(C) >= 0 ? (b.isub(C), x.isub(B)) : (C.isub(b), B.isub(x));
      }
      var ye;
      return b.cmpn(1) === 0 ? ye = x : ye = B, ye.cmpn(0) < 0 && ye.iadd(c), ye;
    }, o.prototype.gcd = function(c) {
      if (this.isZero())
        return c.abs();
      if (c.isZero())
        return this.abs();
      var b = this.clone(), C = c.clone();
      b.negative = 0, C.negative = 0;
      for (var x = 0; b.isEven() && C.isEven(); x++)
        b.iushrn(1), C.iushrn(1);
      do {
        for (; b.isEven(); )
          b.iushrn(1);
        for (; C.isEven(); )
          C.iushrn(1);
        var B = b.cmp(C);
        if (B < 0) {
          var k = b;
          b = C, C = k;
        } else if (B === 0 || C.cmpn(1) === 0)
          break;
        b.isub(C);
      } while (!0);
      return C.iushln(x);
    }, o.prototype.invm = function(c) {
      return this.egcd(c).a.umod(c);
    }, o.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o.prototype.andln = function(c) {
      return this.words[0] & c;
    }, o.prototype.bincn = function(c) {
      n(typeof c == "number");
      var b = c % 26, C = (c - b) / 26, x = 1 << b;
      if (this.length <= C)
        return this._expand(C + 1), this.words[C] |= x, this;
      for (var B = x, k = C; B !== 0 && k < this.length; k++) {
        var w = this.words[k] | 0;
        w += B, B = w >>> 26, w &= 67108863, this.words[k] = w;
      }
      return B !== 0 && (this.words[k] = B, this.length++), this;
    }, o.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o.prototype.cmpn = function(c) {
      var b = c < 0;
      if (this.negative !== 0 && !b)
        return -1;
      if (this.negative === 0 && b)
        return 1;
      this._strip();
      var C;
      if (this.length > 1)
        C = 1;
      else {
        b && (c = -c), n(c <= 67108863, "Number is too big");
        var x = this.words[0] | 0;
        C = x === c ? 0 : x < c ? -1 : 1;
      }
      return this.negative !== 0 ? -C | 0 : C;
    }, o.prototype.cmp = function(c) {
      if (this.negative !== 0 && c.negative === 0)
        return -1;
      if (this.negative === 0 && c.negative !== 0)
        return 1;
      var b = this.ucmp(c);
      return this.negative !== 0 ? -b | 0 : b;
    }, o.prototype.ucmp = function(c) {
      if (this.length > c.length)
        return 1;
      if (this.length < c.length)
        return -1;
      for (var b = 0, C = this.length - 1; C >= 0; C--) {
        var x = this.words[C] | 0, B = c.words[C] | 0;
        if (x !== B) {
          x < B ? b = -1 : x > B && (b = 1);
          break;
        }
      }
      return b;
    }, o.prototype.gtn = function(c) {
      return this.cmpn(c) === 1;
    }, o.prototype.gt = function(c) {
      return this.cmp(c) === 1;
    }, o.prototype.gten = function(c) {
      return this.cmpn(c) >= 0;
    }, o.prototype.gte = function(c) {
      return this.cmp(c) >= 0;
    }, o.prototype.ltn = function(c) {
      return this.cmpn(c) === -1;
    }, o.prototype.lt = function(c) {
      return this.cmp(c) === -1;
    }, o.prototype.lten = function(c) {
      return this.cmpn(c) <= 0;
    }, o.prototype.lte = function(c) {
      return this.cmp(c) <= 0;
    }, o.prototype.eqn = function(c) {
      return this.cmpn(c) === 0;
    }, o.prototype.eq = function(c) {
      return this.cmp(c) === 0;
    }, o.red = function(c) {
      return new pe(c);
    }, o.prototype.toRed = function(c) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), c.convertTo(this)._forceRed(c);
    }, o.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o.prototype._forceRed = function(c) {
      return this.red = c, this;
    }, o.prototype.forceRed = function(c) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(c);
    }, o.prototype.redAdd = function(c) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, c);
    }, o.prototype.redIAdd = function(c) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, c);
    }, o.prototype.redSub = function(c) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, c);
    }, o.prototype.redISub = function(c) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, c);
    }, o.prototype.redShl = function(c) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, c);
    }, o.prototype.redMul = function(c) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.mul(this, c);
    }, o.prototype.redIMul = function(c) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.imul(this, c);
    }, o.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o.prototype.redPow = function(c) {
      return n(this.red && !c.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, c);
    };
    var Ee = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function xe(E, c) {
      this.name = E, this.p = new o(c, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    xe.prototype._tmp = function() {
      var c = new o(null);
      return c.words = new Array(Math.ceil(this.n / 13)), c;
    }, xe.prototype.ireduce = function(c) {
      var b = c, C;
      do
        this.split(b, this.tmp), b = this.imulK(b), b = b.iadd(this.tmp), C = b.bitLength();
      while (C > this.n);
      var x = C < this.n ? -1 : b.ucmp(this.p);
      return x === 0 ? (b.words[0] = 0, b.length = 1) : x > 0 ? b.isub(this.p) : b.strip !== void 0 ? b.strip() : b._strip(), b;
    }, xe.prototype.split = function(c, b) {
      c.iushrn(this.n, 0, b);
    }, xe.prototype.imulK = function(c) {
      return c.imul(this.k);
    };
    function Le() {
      xe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    u(Le, xe), Le.prototype.split = function(c, b) {
      for (var C = 4194303, x = Math.min(c.length, 9), B = 0; B < x; B++)
        b.words[B] = c.words[B];
      if (b.length = x, c.length <= 9) {
        c.words[0] = 0, c.length = 1;
        return;
      }
      var k = c.words[9];
      for (b.words[b.length++] = k & C, B = 10; B < c.length; B++) {
        var w = c.words[B] | 0;
        c.words[B - 10] = (w & C) << 4 | k >>> 22, k = w;
      }
      k >>>= 22, c.words[B - 10] = k, k === 0 && c.length > 10 ? c.length -= 10 : c.length -= 9;
    }, Le.prototype.imulK = function(c) {
      c.words[c.length] = 0, c.words[c.length + 1] = 0, c.length += 2;
      for (var b = 0, C = 0; C < c.length; C++) {
        var x = c.words[C] | 0;
        b += x * 977, c.words[C] = b & 67108863, b = x * 64 + (b / 67108864 | 0);
      }
      return c.words[c.length - 1] === 0 && (c.length--, c.words[c.length - 1] === 0 && c.length--), c;
    };
    function Ne() {
      xe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    u(Ne, xe);
    function Re() {
      xe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    u(Re, xe);
    function Xe() {
      xe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    u(Xe, xe), Xe.prototype.imulK = function(c) {
      for (var b = 0, C = 0; C < c.length; C++) {
        var x = (c.words[C] | 0) * 19 + b, B = x & 67108863;
        x >>>= 26, c.words[C] = B, b = x;
      }
      return b !== 0 && (c.words[c.length++] = b), c;
    }, o._prime = function(c) {
      if (Ee[c])
        return Ee[c];
      var b;
      if (c === "k256")
        b = new Le();
      else if (c === "p224")
        b = new Ne();
      else if (c === "p192")
        b = new Re();
      else if (c === "p25519")
        b = new Xe();
      else
        throw new Error("Unknown prime " + c);
      return Ee[c] = b, b;
    };
    function pe(E) {
      if (typeof E == "string") {
        var c = o._prime(E);
        this.m = c.p, this.prime = c;
      } else
        n(E.gtn(1), "modulus must be greater than 1"), this.m = E, this.prime = null;
    }
    pe.prototype._verify1 = function(c) {
      n(c.negative === 0, "red works only with positives"), n(c.red, "red works only with red numbers");
    }, pe.prototype._verify2 = function(c, b) {
      n((c.negative | b.negative) === 0, "red works only with positives"), n(
        c.red && c.red === b.red,
        "red works only with red numbers"
      );
    }, pe.prototype.imod = function(c) {
      return this.prime ? this.prime.ireduce(c)._forceRed(this) : (d(c, c.umod(this.m)._forceRed(this)), c);
    }, pe.prototype.neg = function(c) {
      return c.isZero() ? c.clone() : this.m.sub(c)._forceRed(this);
    }, pe.prototype.add = function(c, b) {
      this._verify2(c, b);
      var C = c.add(b);
      return C.cmp(this.m) >= 0 && C.isub(this.m), C._forceRed(this);
    }, pe.prototype.iadd = function(c, b) {
      this._verify2(c, b);
      var C = c.iadd(b);
      return C.cmp(this.m) >= 0 && C.isub(this.m), C;
    }, pe.prototype.sub = function(c, b) {
      this._verify2(c, b);
      var C = c.sub(b);
      return C.cmpn(0) < 0 && C.iadd(this.m), C._forceRed(this);
    }, pe.prototype.isub = function(c, b) {
      this._verify2(c, b);
      var C = c.isub(b);
      return C.cmpn(0) < 0 && C.iadd(this.m), C;
    }, pe.prototype.shl = function(c, b) {
      return this._verify1(c), this.imod(c.ushln(b));
    }, pe.prototype.imul = function(c, b) {
      return this._verify2(c, b), this.imod(c.imul(b));
    }, pe.prototype.mul = function(c, b) {
      return this._verify2(c, b), this.imod(c.mul(b));
    }, pe.prototype.isqr = function(c) {
      return this.imul(c, c.clone());
    }, pe.prototype.sqr = function(c) {
      return this.mul(c, c);
    }, pe.prototype.sqrt = function(c) {
      if (c.isZero())
        return c.clone();
      var b = this.m.andln(3);
      if (n(b % 2 === 1), b === 3) {
        var C = this.m.add(new o(1)).iushrn(2);
        return this.pow(c, C);
      }
      for (var x = this.m.subn(1), B = 0; !x.isZero() && x.andln(1) === 0; )
        B++, x.iushrn(1);
      n(!x.isZero());
      var k = new o(1).toRed(this), w = k.redNeg(), T = this.m.subn(1).iushrn(1), p = this.m.bitLength();
      for (p = new o(2 * p * p).toRed(this); this.pow(p, T).cmp(w) !== 0; )
        p.redIAdd(w);
      for (var F = this.pow(p, x), ye = this.pow(c, x.addn(1).iushrn(1)), _e = this.pow(c, x), de = B; _e.cmp(k) !== 0; ) {
        for (var P = _e, H = 0; P.cmp(k) !== 0; H++)
          P = P.redSqr();
        n(H < de);
        var he = this.pow(F, new o(1).iushln(de - H - 1));
        ye = ye.redMul(he), F = he.redSqr(), _e = _e.redMul(F), de = H;
      }
      return ye;
    }, pe.prototype.invm = function(c) {
      var b = c._invmp(this.m);
      return b.negative !== 0 ? (b.negative = 0, this.imod(b).redNeg()) : this.imod(b);
    }, pe.prototype.pow = function(c, b) {
      if (b.isZero())
        return new o(1).toRed(this);
      if (b.cmpn(1) === 0)
        return c.clone();
      var C = 4, x = new Array(1 << C);
      x[0] = new o(1).toRed(this), x[1] = c;
      for (var B = 2; B < x.length; B++)
        x[B] = this.mul(x[B - 1], c);
      var k = x[0], w = 0, T = 0, p = b.bitLength() % 26;
      for (p === 0 && (p = 26), B = b.length - 1; B >= 0; B--) {
        for (var F = b.words[B], ye = p - 1; ye >= 0; ye--) {
          var _e = F >> ye & 1;
          if (k !== x[0] && (k = this.sqr(k)), _e === 0 && w === 0) {
            T = 0;
            continue;
          }
          w <<= 1, w |= _e, T++, !(T !== C && (B !== 0 || ye !== 0)) && (k = this.mul(k, x[w]), T = 0, w = 0);
        }
        p = 26;
      }
      return k;
    }, pe.prototype.convertTo = function(c) {
      var b = c.umod(this.m);
      return b === c ? b.clone() : b;
    }, pe.prototype.convertFrom = function(c) {
      var b = c.clone();
      return b.red = null, b;
    }, o.mont = function(c) {
      return new O(c);
    };
    function O(E) {
      pe.call(this, E), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    u(O, pe), O.prototype.convertTo = function(c) {
      return this.imod(c.ushln(this.shift));
    }, O.prototype.convertFrom = function(c) {
      var b = this.imod(c.mul(this.rinv));
      return b.red = null, b;
    }, O.prototype.imul = function(c, b) {
      if (c.isZero() || b.isZero())
        return c.words[0] = 0, c.length = 1, c;
      var C = c.imul(b), x = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = C.isub(x).iushrn(this.shift), k = B;
      return B.cmp(this.m) >= 0 ? k = B.isub(this.m) : B.cmpn(0) < 0 && (k = B.iadd(this.m)), k._forceRed(this);
    }, O.prototype.mul = function(c, b) {
      if (c.isZero() || b.isZero())
        return new o(0)._forceRed(this);
      var C = c.mul(b), x = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = C.isub(x).iushrn(this.shift), k = B;
      return B.cmp(this.m) >= 0 ? k = B.isub(this.m) : B.cmpn(0) < 0 && (k = B.iadd(this.m)), k._forceRed(this);
    }, O.prototype.invm = function(c) {
      var b = this.imod(c._invmp(this.m).mul(this.r2));
      return b._forceRed(this);
    };
  })(e, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports, BN$a = bnExports$1, randomBytes$1 = browserExports, Buffer$7 = safeBufferExports$2.Buffer;
function getr(e) {
  var t = e.modulus.byteLength(), a;
  do
    a = new BN$a(randomBytes$1(t));
  while (a.cmp(e.modulus) >= 0 || !a.umod(e.prime1) || !a.umod(e.prime2));
  return a;
}
function blind(e) {
  var t = getr(e), a = t.toRed(BN$a.mont(e.modulus)).redPow(new BN$a(e.publicExponent)).fromRed();
  return { blinder: a, unblinder: t.invm(e.modulus) };
}
function crt$2(e, t) {
  var a = blind(t), n = t.modulus.byteLength(), u = new BN$a(e).mul(a.blinder).umod(t.modulus), o = u.toRed(BN$a.mont(t.prime1)), l = u.toRed(BN$a.mont(t.prime2)), h = t.coefficient, y = t.prime1, _ = t.prime2, d = o.redPow(t.exponent1).fromRed(), $ = l.redPow(t.exponent2).fromRed(), N = d.isub($).imul(h).umod(y).imul(_);
  return $.iadd(N).imul(a.unblinder).umod(t.modulus).toArrayLike(Buffer$7, "be", n);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const name = "elliptic", version = "6.6.1", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$l = {}, utils$k = {};
(function(e) {
  var t = e;
  function a(o, l) {
    if (Array.isArray(o))
      return o.slice();
    if (!o)
      return [];
    var h = [];
    if (typeof o != "string") {
      for (var y = 0; y < o.length; y++)
        h[y] = o[y] | 0;
      return h;
    }
    if (l === "hex") {
      o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
      for (var y = 0; y < o.length; y += 2)
        h.push(parseInt(o[y] + o[y + 1], 16));
    } else
      for (var y = 0; y < o.length; y++) {
        var _ = o.charCodeAt(y), d = _ >> 8, $ = _ & 255;
        d ? h.push(d, $) : h.push($);
      }
    return h;
  }
  t.toArray = a;
  function n(o) {
    return o.length === 1 ? "0" + o : o;
  }
  t.zero2 = n;
  function u(o) {
    for (var l = "", h = 0; h < o.length; h++)
      l += n(o[h].toString(16));
    return l;
  }
  t.toHex = u, t.encode = function(l, h) {
    return h === "hex" ? u(l) : l;
  };
})(utils$k);
(function(e) {
  var t = e, a = bnExports$2, n = minimalisticAssert, u = utils$k;
  t.assert = n, t.toArray = u.toArray, t.zero2 = u.zero2, t.toHex = u.toHex, t.encode = u.encode;
  function o(d, $, N) {
    var U = new Array(Math.max(d.bitLength(), N) + 1), V;
    for (V = 0; V < U.length; V += 1)
      U[V] = 0;
    var Q = 1 << $ + 1, ie = d.clone();
    for (V = 0; V < U.length; V++) {
      var ee, ne = ie.andln(Q - 1);
      ie.isOdd() ? (ne > (Q >> 1) - 1 ? ee = (Q >> 1) - ne : ee = ne, ie.isubn(ee)) : ee = 0, U[V] = ee, ie.iushrn(1);
    }
    return U;
  }
  t.getNAF = o;
  function l(d, $) {
    var N = [
      [],
      []
    ];
    d = d.clone(), $ = $.clone();
    for (var U = 0, V = 0, Q; d.cmpn(-U) > 0 || $.cmpn(-V) > 0; ) {
      var ie = d.andln(3) + U & 3, ee = $.andln(3) + V & 3;
      ie === 3 && (ie = -1), ee === 3 && (ee = -1);
      var ne;
      ie & 1 ? (Q = d.andln(7) + U & 7, (Q === 3 || Q === 5) && ee === 2 ? ne = -ie : ne = ie) : ne = 0, N[0].push(ne);
      var ge;
      ee & 1 ? (Q = $.andln(7) + V & 7, (Q === 3 || Q === 5) && ie === 2 ? ge = -ee : ge = ee) : ge = 0, N[1].push(ge), 2 * U === ne + 1 && (U = 1 - U), 2 * V === ge + 1 && (V = 1 - V), d.iushrn(1), $.iushrn(1);
    }
    return N;
  }
  t.getJSF = l;
  function h(d, $, N) {
    var U = "_" + $;
    d.prototype[$] = function() {
      return this[U] !== void 0 ? this[U] : this[U] = N.call(this);
    };
  }
  t.cachedProperty = h;
  function y(d) {
    return typeof d == "string" ? t.toArray(d, "hex") : d;
  }
  t.parseBytes = y;
  function _(d) {
    return new a(d, "hex", "le");
  }
  t.intFromLE = _;
})(utils$l);
var curve = {}, BN$9 = bnExports$2, utils$j = utils$l, getNAF = utils$j.getNAF, getJSF = utils$j.getJSF, assert$d = utils$j.assert;
function BaseCurve(e, t) {
  this.type = e, this.p = new BN$9(t.p, 16), this.red = t.prime ? BN$9.red(t.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = t.n && new BN$9(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var a = this.n && this.p.div(this.n);
  !a || a.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(t, a) {
  assert$d(t.precomputed);
  var n = t._getDoubles(), u = getNAF(a, 1, this._bitLength), o = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
  o /= 3;
  var l = [], h, y;
  for (h = 0; h < u.length; h += n.step) {
    y = 0;
    for (var _ = h + n.step - 1; _ >= h; _--)
      y = (y << 1) + u[_];
    l.push(y);
  }
  for (var d = this.jpoint(null, null, null), $ = this.jpoint(null, null, null), N = o; N > 0; N--) {
    for (h = 0; h < l.length; h++)
      y = l[h], y === N ? $ = $.mixedAdd(n.points[h]) : y === -N && ($ = $.mixedAdd(n.points[h].neg()));
    d = d.add($);
  }
  return d.toP();
};
BaseCurve.prototype._wnafMul = function(t, a) {
  var n = 4, u = t._getNAFPoints(n);
  n = u.wnd;
  for (var o = u.points, l = getNAF(a, n, this._bitLength), h = this.jpoint(null, null, null), y = l.length - 1; y >= 0; y--) {
    for (var _ = 0; y >= 0 && l[y] === 0; y--)
      _++;
    if (y >= 0 && _++, h = h.dblp(_), y < 0)
      break;
    var d = l[y];
    assert$d(d !== 0), t.type === "affine" ? d > 0 ? h = h.mixedAdd(o[d - 1 >> 1]) : h = h.mixedAdd(o[-d - 1 >> 1].neg()) : d > 0 ? h = h.add(o[d - 1 >> 1]) : h = h.add(o[-d - 1 >> 1].neg());
  }
  return t.type === "affine" ? h.toP() : h;
};
BaseCurve.prototype._wnafMulAdd = function(t, a, n, u, o) {
  var l = this._wnafT1, h = this._wnafT2, y = this._wnafT3, _ = 0, d, $, N;
  for (d = 0; d < u; d++) {
    N = a[d];
    var U = N._getNAFPoints(t);
    l[d] = U.wnd, h[d] = U.points;
  }
  for (d = u - 1; d >= 1; d -= 2) {
    var V = d - 1, Q = d;
    if (l[V] !== 1 || l[Q] !== 1) {
      y[V] = getNAF(n[V], l[V], this._bitLength), y[Q] = getNAF(n[Q], l[Q], this._bitLength), _ = Math.max(y[V].length, _), _ = Math.max(y[Q].length, _);
      continue;
    }
    var ie = [
      a[V],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      a[Q]
      /* 7 */
    ];
    a[V].y.cmp(a[Q].y) === 0 ? (ie[1] = a[V].add(a[Q]), ie[2] = a[V].toJ().mixedAdd(a[Q].neg())) : a[V].y.cmp(a[Q].y.redNeg()) === 0 ? (ie[1] = a[V].toJ().mixedAdd(a[Q]), ie[2] = a[V].add(a[Q].neg())) : (ie[1] = a[V].toJ().mixedAdd(a[Q]), ie[2] = a[V].toJ().mixedAdd(a[Q].neg()));
    var ee = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], ne = getJSF(n[V], n[Q]);
    for (_ = Math.max(ne[0].length, _), y[V] = new Array(_), y[Q] = new Array(_), $ = 0; $ < _; $++) {
      var ge = ne[0][$] | 0, be = ne[1][$] | 0;
      y[V][$] = ee[(ge + 1) * 3 + (be + 1)], y[Q][$] = 0, h[V] = ie;
    }
  }
  var Ee = this.jpoint(null, null, null), xe = this._wnafT4;
  for (d = _; d >= 0; d--) {
    for (var Le = 0; d >= 0; ) {
      var Ne = !0;
      for ($ = 0; $ < u; $++)
        xe[$] = y[$][d] | 0, xe[$] !== 0 && (Ne = !1);
      if (!Ne)
        break;
      Le++, d--;
    }
    if (d >= 0 && Le++, Ee = Ee.dblp(Le), d < 0)
      break;
    for ($ = 0; $ < u; $++) {
      var Re = xe[$];
      Re !== 0 && (Re > 0 ? N = h[$][Re - 1 >> 1] : Re < 0 && (N = h[$][-Re - 1 >> 1].neg()), N.type === "affine" ? Ee = Ee.mixedAdd(N) : Ee = Ee.add(N));
    }
  }
  for (d = 0; d < u; d++)
    h[d] = null;
  return o ? Ee : Ee.toP();
};
function BasePoint(e, t) {
  this.curve = e, this.type = t, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(t, a) {
  t = utils$j.toArray(t, a);
  var n = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * n) {
    t[0] === 6 ? assert$d(t[t.length - 1] % 2 === 0) : t[0] === 7 && assert$d(t[t.length - 1] % 2 === 1);
    var u = this.point(
      t.slice(1, 1 + n),
      t.slice(1 + n, 1 + 2 * n)
    );
    return u;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === n)
    return this.pointFromX(t.slice(1, 1 + n), t[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(t) {
  return this.encode(t, !0);
};
BasePoint.prototype._encode = function(t) {
  var a = this.curve.p.byteLength(), n = this.getX().toArray("be", a);
  return t ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", a));
};
BasePoint.prototype.encode = function(t, a) {
  return utils$j.encode(this._encode(a), t);
};
BasePoint.prototype.precompute = function(t) {
  if (this.precomputed)
    return this;
  var a = {
    doubles: null,
    naf: null,
    beta: null
  };
  return a.naf = this._getNAFPoints(8), a.doubles = this._getDoubles(4, t), a.beta = this._getBeta(), this.precomputed = a, this;
};
BasePoint.prototype._hasDoubles = function(t) {
  if (!this.precomputed)
    return !1;
  var a = this.precomputed.doubles;
  return a ? a.points.length >= Math.ceil((t.bitLength() + 1) / a.step) : !1;
};
BasePoint.prototype._getDoubles = function(t, a) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], u = this, o = 0; o < a; o += t) {
    for (var l = 0; l < t; l++)
      u = u.dbl();
    n.push(u);
  }
  return {
    step: t,
    points: n
  };
};
BasePoint.prototype._getNAFPoints = function(t) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var a = [this], n = (1 << t) - 1, u = n === 1 ? null : this.dbl(), o = 1; o < n; o++)
    a[o] = a[o - 1].add(u);
  return {
    wnd: t,
    points: a
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(t) {
  for (var a = this, n = 0; n < t; n++)
    a = a.dbl();
  return a;
};
var utils$i = utils$l, BN$8 = bnExports$2, inherits$4 = inherits_browserExports, Base$2 = base$1, assert$c = utils$i.assert;
function ShortCurve(e) {
  Base$2.call(this, "short", e), this.a = new BN$8(e.a, 16).toRed(this.red), this.b = new BN$8(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var a, n;
    if (t.beta)
      a = new BN$8(t.beta, 16).toRed(this.red);
    else {
      var u = this._getEndoRoots(this.p);
      a = u[0].cmp(u[1]) < 0 ? u[0] : u[1], a = a.toRed(this.red);
    }
    if (t.lambda)
      n = new BN$8(t.lambda, 16);
    else {
      var o = this._getEndoRoots(this.n);
      this.g.mul(o[0]).x.cmp(this.g.x.redMul(a)) === 0 ? n = o[0] : (n = o[1], assert$c(this.g.mul(n).x.cmp(this.g.x.redMul(a)) === 0));
    }
    var l;
    return t.basis ? l = t.basis.map(function(h) {
      return {
        a: new BN$8(h.a, 16),
        b: new BN$8(h.b, 16)
      };
    }) : l = this._getEndoBasis(n), {
      beta: a,
      lambda: n,
      basis: l
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(t) {
  var a = t === this.p ? this.red : BN$8.mont(t), n = new BN$8(2).toRed(a).redInvm(), u = n.redNeg(), o = new BN$8(3).toRed(a).redNeg().redSqrt().redMul(n), l = u.redAdd(o).fromRed(), h = u.redSub(o).fromRed();
  return [l, h];
};
ShortCurve.prototype._getEndoBasis = function(t) {
  for (var a = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = t, u = this.n.clone(), o = new BN$8(1), l = new BN$8(0), h = new BN$8(0), y = new BN$8(1), _, d, $, N, U, V, Q, ie = 0, ee, ne; n.cmpn(0) !== 0; ) {
    var ge = u.div(n);
    ee = u.sub(ge.mul(n)), ne = h.sub(ge.mul(o));
    var be = y.sub(ge.mul(l));
    if (!$ && ee.cmp(a) < 0)
      _ = Q.neg(), d = o, $ = ee.neg(), N = ne;
    else if ($ && ++ie === 2)
      break;
    Q = ee, u = n, n = ee, h = o, o = ne, y = l, l = be;
  }
  U = ee.neg(), V = ne;
  var Ee = $.sqr().add(N.sqr()), xe = U.sqr().add(V.sqr());
  return xe.cmp(Ee) >= 0 && (U = _, V = d), $.negative && ($ = $.neg(), N = N.neg()), U.negative && (U = U.neg(), V = V.neg()), [
    { a: $, b: N },
    { a: U, b: V }
  ];
};
ShortCurve.prototype._endoSplit = function(t) {
  var a = this.endo.basis, n = a[0], u = a[1], o = u.b.mul(t).divRound(this.n), l = n.b.neg().mul(t).divRound(this.n), h = o.mul(n.a), y = l.mul(u.a), _ = o.mul(n.b), d = l.mul(u.b), $ = t.sub(h).sub(y), N = _.add(d).neg();
  return { k1: $, k2: N };
};
ShortCurve.prototype.pointFromX = function(t, a) {
  t = new BN$8(t, 16), t.red || (t = t.toRed(this.red));
  var n = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), u = n.redSqrt();
  if (u.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var o = u.fromRed().isOdd();
  return (a && !o || !a && o) && (u = u.redNeg()), this.point(t, u);
};
ShortCurve.prototype.validate = function(t) {
  if (t.inf)
    return !0;
  var a = t.x, n = t.y, u = this.a.redMul(a), o = a.redSqr().redMul(a).redIAdd(u).redIAdd(this.b);
  return n.redSqr().redISub(o).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(t, a, n) {
  for (var u = this._endoWnafT1, o = this._endoWnafT2, l = 0; l < t.length; l++) {
    var h = this._endoSplit(a[l]), y = t[l], _ = y._getBeta();
    h.k1.negative && (h.k1.ineg(), y = y.neg(!0)), h.k2.negative && (h.k2.ineg(), _ = _.neg(!0)), u[l * 2] = y, u[l * 2 + 1] = _, o[l * 2] = h.k1, o[l * 2 + 1] = h.k2;
  }
  for (var d = this._wnafMulAdd(1, u, o, l * 2, n), $ = 0; $ < l * 2; $++)
    u[$] = null, o[$] = null;
  return d;
};
function Point$2(e, t, a, n) {
  Base$2.BasePoint.call(this, e, "affine"), t === null && a === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(t, 16), this.y = new BN$8(a, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$4(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function(t, a, n) {
  return new Point$2(this, t, a, n);
};
ShortCurve.prototype.pointFromJSON = function(t, a) {
  return Point$2.fromJSON(this, t, a);
};
Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta)
      return t.beta;
    var a = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var n = this.curve, u = function(o) {
        return n.point(o.x.redMul(n.endo.beta), o.y);
      };
      t.beta = a, a.precomputed = {
        beta: null,
        naf: t.naf && {
          wnd: t.naf.wnd,
          points: t.naf.points.map(u)
        },
        doubles: t.doubles && {
          step: t.doubles.step,
          points: t.doubles.points.map(u)
        }
      };
    }
    return a;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(t, a, n) {
  typeof a == "string" && (a = JSON.parse(a));
  var u = t.point(a[0], a[1], n);
  if (!a[2])
    return u;
  function o(h) {
    return t.point(h[0], h[1], n);
  }
  var l = a[2];
  return u.precomputed = {
    beta: null,
    doubles: l.doubles && {
      step: l.doubles.step,
      points: [u].concat(l.doubles.points.map(o))
    },
    naf: l.naf && {
      wnd: l.naf.wnd,
      points: [u].concat(l.naf.points.map(o))
    }
  }, u;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(t) {
  if (this.inf)
    return t;
  if (t.inf)
    return this;
  if (this.eq(t))
    return this.dbl();
  if (this.neg().eq(t))
    return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0)
    return this.curve.point(null, null);
  var a = this.y.redSub(t.y);
  a.cmpn(0) !== 0 && (a = a.redMul(this.x.redSub(t.x).redInvm()));
  var n = a.redSqr().redISub(this.x).redISub(t.x), u = a.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, u);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a, n = this.x.redSqr(), u = t.redInvm(), o = n.redAdd(n).redIAdd(n).redIAdd(a).redMul(u), l = o.redSqr().redISub(this.x.redAdd(this.x)), h = o.redMul(this.x.redSub(l)).redISub(this.y);
  return this.curve.point(l, h);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(t) {
  return t = new BN$8(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
};
Point$2.prototype.mulAdd = function(t, a, n) {
  var u = [this, a], o = [t, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, o) : this.curve._wnafMulAdd(1, u, o, 2);
};
Point$2.prototype.jmulAdd = function(t, a, n) {
  var u = [this, a], o = [t, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, o, !0) : this.curve._wnafMulAdd(1, u, o, 2, !0);
};
Point$2.prototype.eq = function(t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
};
Point$2.prototype.neg = function(t) {
  if (this.inf)
    return this;
  var a = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var n = this.precomputed, u = function(o) {
      return o.neg();
    };
    a.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(u)
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(u)
      }
    };
  }
  return a;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function JPoint(e, t, a, n) {
  Base$2.BasePoint.call(this, e, "jacobian"), t === null && a === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(t, 16), this.y = new BN$8(a, 16), this.z = new BN$8(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function(t, a, n) {
  return new JPoint(this, t, a, n);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var t = this.z.redInvm(), a = t.redSqr(), n = this.x.redMul(a), u = this.y.redMul(a).redMul(t);
  return this.curve.point(n, u);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(t) {
  if (this.isInfinity())
    return t;
  if (t.isInfinity())
    return this;
  var a = t.z.redSqr(), n = this.z.redSqr(), u = this.x.redMul(a), o = t.x.redMul(n), l = this.y.redMul(a.redMul(t.z)), h = t.y.redMul(n.redMul(this.z)), y = u.redSub(o), _ = l.redSub(h);
  if (y.cmpn(0) === 0)
    return _.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = y.redSqr(), $ = d.redMul(y), N = u.redMul(d), U = _.redSqr().redIAdd($).redISub(N).redISub(N), V = _.redMul(N.redISub(U)).redISub(l.redMul($)), Q = this.z.redMul(t.z).redMul(y);
  return this.curve.jpoint(U, V, Q);
};
JPoint.prototype.mixedAdd = function(t) {
  if (this.isInfinity())
    return t.toJ();
  if (t.isInfinity())
    return this;
  var a = this.z.redSqr(), n = this.x, u = t.x.redMul(a), o = this.y, l = t.y.redMul(a).redMul(this.z), h = n.redSub(u), y = o.redSub(l);
  if (h.cmpn(0) === 0)
    return y.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var _ = h.redSqr(), d = _.redMul(h), $ = n.redMul(_), N = y.redSqr().redIAdd(d).redISub($).redISub($), U = y.redMul($.redISub(N)).redISub(o.redMul(d)), V = this.z.redMul(h);
  return this.curve.jpoint(N, U, V);
};
JPoint.prototype.dblp = function(t) {
  if (t === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!t)
    return this.dbl();
  var a;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (a = 0; a < t; a++)
      n = n.dbl();
    return n;
  }
  var u = this.curve.a, o = this.curve.tinv, l = this.x, h = this.y, y = this.z, _ = y.redSqr().redSqr(), d = h.redAdd(h);
  for (a = 0; a < t; a++) {
    var $ = l.redSqr(), N = d.redSqr(), U = N.redSqr(), V = $.redAdd($).redIAdd($).redIAdd(u.redMul(_)), Q = l.redMul(N), ie = V.redSqr().redISub(Q.redAdd(Q)), ee = Q.redISub(ie), ne = V.redMul(ee);
    ne = ne.redIAdd(ne).redISub(U);
    var ge = d.redMul(y);
    a + 1 < t && (_ = _.redMul(U)), l = ie, y = ge, d = ne;
  }
  return this.curve.jpoint(l, d.redMul(o), y);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var t, a, n;
  if (this.zOne) {
    var u = this.x.redSqr(), o = this.y.redSqr(), l = o.redSqr(), h = this.x.redAdd(o).redSqr().redISub(u).redISub(l);
    h = h.redIAdd(h);
    var y = u.redAdd(u).redIAdd(u), _ = y.redSqr().redISub(h).redISub(h), d = l.redIAdd(l);
    d = d.redIAdd(d), d = d.redIAdd(d), t = _, a = y.redMul(h.redISub(_)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var $ = this.x.redSqr(), N = this.y.redSqr(), U = N.redSqr(), V = this.x.redAdd(N).redSqr().redISub($).redISub(U);
    V = V.redIAdd(V);
    var Q = $.redAdd($).redIAdd($), ie = Q.redSqr(), ee = U.redIAdd(U);
    ee = ee.redIAdd(ee), ee = ee.redIAdd(ee), t = ie.redISub(V).redISub(V), a = Q.redMul(V.redISub(t)).redISub(ee), n = this.y.redMul(this.z), n = n.redIAdd(n);
  }
  return this.curve.jpoint(t, a, n);
};
JPoint.prototype._threeDbl = function() {
  var t, a, n;
  if (this.zOne) {
    var u = this.x.redSqr(), o = this.y.redSqr(), l = o.redSqr(), h = this.x.redAdd(o).redSqr().redISub(u).redISub(l);
    h = h.redIAdd(h);
    var y = u.redAdd(u).redIAdd(u).redIAdd(this.curve.a), _ = y.redSqr().redISub(h).redISub(h);
    t = _;
    var d = l.redIAdd(l);
    d = d.redIAdd(d), d = d.redIAdd(d), a = y.redMul(h.redISub(_)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var $ = this.z.redSqr(), N = this.y.redSqr(), U = this.x.redMul(N), V = this.x.redSub($).redMul(this.x.redAdd($));
    V = V.redAdd(V).redIAdd(V);
    var Q = U.redIAdd(U);
    Q = Q.redIAdd(Q);
    var ie = Q.redAdd(Q);
    t = V.redSqr().redISub(ie), n = this.y.redAdd(this.z).redSqr().redISub(N).redISub($);
    var ee = N.redSqr();
    ee = ee.redIAdd(ee), ee = ee.redIAdd(ee), ee = ee.redIAdd(ee), a = V.redMul(Q.redISub(t)).redISub(ee);
  }
  return this.curve.jpoint(t, a, n);
};
JPoint.prototype._dbl = function() {
  var t = this.curve.a, a = this.x, n = this.y, u = this.z, o = u.redSqr().redSqr(), l = a.redSqr(), h = n.redSqr(), y = l.redAdd(l).redIAdd(l).redIAdd(t.redMul(o)), _ = a.redAdd(a);
  _ = _.redIAdd(_);
  var d = _.redMul(h), $ = y.redSqr().redISub(d.redAdd(d)), N = d.redISub($), U = h.redSqr();
  U = U.redIAdd(U), U = U.redIAdd(U), U = U.redIAdd(U);
  var V = y.redMul(N).redISub(U), Q = n.redAdd(n).redMul(u);
  return this.curve.jpoint($, V, Q);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var t = this.x.redSqr(), a = this.y.redSqr(), n = this.z.redSqr(), u = a.redSqr(), o = t.redAdd(t).redIAdd(t), l = o.redSqr(), h = this.x.redAdd(a).redSqr().redISub(t).redISub(u);
  h = h.redIAdd(h), h = h.redAdd(h).redIAdd(h), h = h.redISub(l);
  var y = h.redSqr(), _ = u.redIAdd(u);
  _ = _.redIAdd(_), _ = _.redIAdd(_), _ = _.redIAdd(_);
  var d = o.redIAdd(h).redSqr().redISub(l).redISub(y).redISub(_), $ = a.redMul(d);
  $ = $.redIAdd($), $ = $.redIAdd($);
  var N = this.x.redMul(y).redISub($);
  N = N.redIAdd(N), N = N.redIAdd(N);
  var U = this.y.redMul(d.redMul(_.redISub(d)).redISub(h.redMul(y)));
  U = U.redIAdd(U), U = U.redIAdd(U), U = U.redIAdd(U);
  var V = this.z.redAdd(h).redSqr().redISub(n).redISub(y);
  return this.curve.jpoint(N, U, V);
};
JPoint.prototype.mul = function(t, a) {
  return t = new BN$8(t, a), this.curve._wnafMul(this, t);
};
JPoint.prototype.eq = function(t) {
  if (t.type === "affine")
    return this.eq(t.toJ());
  if (this === t)
    return !0;
  var a = this.z.redSqr(), n = t.z.redSqr();
  if (this.x.redMul(n).redISub(t.x.redMul(a)).cmpn(0) !== 0)
    return !1;
  var u = a.redMul(this.z), o = n.redMul(t.z);
  return this.y.redMul(o).redISub(t.y.redMul(u)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(t) {
  var a = this.z.redSqr(), n = t.toRed(this.curve.red).redMul(a);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var u = t.clone(), o = this.curve.redN.redMul(a); ; ) {
    if (u.iadd(this.curve.n), u.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(o), this.x.cmp(n) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$2, inherits$3 = inherits_browserExports, Base$1 = base$1, utils$h = utils$l;
function MontCurve(e) {
  Base$1.call(this, "mont", e), this.a = new BN$7(e.a, 16).toRed(this.red), this.b = new BN$7(e.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(t) {
  var a = t.normalize().x, n = a.redSqr(), u = n.redMul(a).redAdd(n.redMul(this.a)).redAdd(a), o = u.redSqrt();
  return o.redSqr().cmp(u) === 0;
};
function Point$1(e, t, a) {
  Base$1.BasePoint.call(this, e, "projective"), t === null && a === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(t, 16), this.z = new BN$7(a, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$3(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(t, a) {
  return this.point(utils$h.toArray(t, a), 1);
};
MontCurve.prototype.point = function(t, a) {
  return new Point$1(this, t, a);
};
MontCurve.prototype.pointFromJSON = function(t) {
  return Point$1.fromJSON(this, t);
};
Point$1.prototype.precompute = function() {
};
Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function(t, a) {
  return new Point$1(t, a[0], a[1] || t.one);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function() {
  var t = this.x.redAdd(this.z), a = t.redSqr(), n = this.x.redSub(this.z), u = n.redSqr(), o = a.redSub(u), l = a.redMul(u), h = o.redMul(u.redAdd(this.curve.a24.redMul(o)));
  return this.curve.point(l, h);
};
Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function(t, a) {
  var n = this.x.redAdd(this.z), u = this.x.redSub(this.z), o = t.x.redAdd(t.z), l = t.x.redSub(t.z), h = l.redMul(n), y = o.redMul(u), _ = a.z.redMul(h.redAdd(y).redSqr()), d = a.x.redMul(h.redISub(y).redSqr());
  return this.curve.point(_, d);
};
Point$1.prototype.mul = function(t) {
  for (var a = t.clone(), n = this, u = this.curve.point(null, null), o = this, l = []; a.cmpn(0) !== 0; a.iushrn(1))
    l.push(a.andln(1));
  for (var h = l.length - 1; h >= 0; h--)
    l[h] === 0 ? (n = n.diffAdd(u, o), u = u.dbl()) : (u = n.diffAdd(u, o), n = n.dbl());
  return u;
};
Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function(t) {
  return this.getX().cmp(t.getX()) === 0;
};
Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$g = utils$l, BN$6 = bnExports$2, inherits$2 = inherits_browserExports, Base = base$1, assert$b = utils$g.assert;
function EdwardsCurve(e) {
  this.twisted = (e.a | 0) !== 1, this.mOneA = this.twisted && (e.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", e), this.a = new BN$6(e.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(e.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(e.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$b(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (e.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(t) {
  return this.mOneA ? t.redNeg() : this.a.redMul(t);
};
EdwardsCurve.prototype._mulC = function(t) {
  return this.oneC ? t : this.c.redMul(t);
};
EdwardsCurve.prototype.jpoint = function(t, a, n, u) {
  return this.point(t, a, n, u);
};
EdwardsCurve.prototype.pointFromX = function(t, a) {
  t = new BN$6(t, 16), t.red || (t = t.toRed(this.red));
  var n = t.redSqr(), u = this.c2.redSub(this.a.redMul(n)), o = this.one.redSub(this.c2.redMul(this.d).redMul(n)), l = u.redMul(o.redInvm()), h = l.redSqrt();
  if (h.redSqr().redSub(l).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var y = h.fromRed().isOdd();
  return (a && !y || !a && y) && (h = h.redNeg()), this.point(t, h);
};
EdwardsCurve.prototype.pointFromY = function(t, a) {
  t = new BN$6(t, 16), t.red || (t = t.toRed(this.red));
  var n = t.redSqr(), u = n.redSub(this.c2), o = n.redMul(this.d).redMul(this.c2).redSub(this.a), l = u.redMul(o.redInvm());
  if (l.cmp(this.zero) === 0) {
    if (a)
      throw new Error("invalid point");
    return this.point(this.zero, t);
  }
  var h = l.redSqrt();
  if (h.redSqr().redSub(l).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return h.fromRed().isOdd() !== a && (h = h.redNeg()), this.point(h, t);
};
EdwardsCurve.prototype.validate = function(t) {
  if (t.isInfinity())
    return !0;
  t.normalize();
  var a = t.x.redSqr(), n = t.y.redSqr(), u = a.redMul(this.a).redAdd(n), o = this.c2.redMul(this.one.redAdd(this.d.redMul(a).redMul(n)));
  return u.cmp(o) === 0;
};
function Point(e, t, a, n, u) {
  Base.BasePoint.call(this, e, "projective"), t === null && a === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(t, 16), this.y = new BN$6(a, 16), this.z = n ? new BN$6(n, 16) : this.curve.one, this.t = u && new BN$6(u, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$2(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(t) {
  return Point.fromJSON(this, t);
};
EdwardsCurve.prototype.point = function(t, a, n, u) {
  return new Point(this, t, a, n, u);
};
Point.fromJSON = function(t, a) {
  return new Point(t, a[0], a[1], a[2]);
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function() {
  var t = this.x.redSqr(), a = this.y.redSqr(), n = this.z.redSqr();
  n = n.redIAdd(n);
  var u = this.curve._mulA(t), o = this.x.redAdd(this.y).redSqr().redISub(t).redISub(a), l = u.redAdd(a), h = l.redSub(n), y = u.redSub(a), _ = o.redMul(h), d = l.redMul(y), $ = o.redMul(y), N = h.redMul(l);
  return this.curve.point(_, d, N, $);
};
Point.prototype._projDbl = function() {
  var t = this.x.redAdd(this.y).redSqr(), a = this.x.redSqr(), n = this.y.redSqr(), u, o, l, h, y, _;
  if (this.curve.twisted) {
    h = this.curve._mulA(a);
    var d = h.redAdd(n);
    this.zOne ? (u = t.redSub(a).redSub(n).redMul(d.redSub(this.curve.two)), o = d.redMul(h.redSub(n)), l = d.redSqr().redSub(d).redSub(d)) : (y = this.z.redSqr(), _ = d.redSub(y).redISub(y), u = t.redSub(a).redISub(n).redMul(_), o = d.redMul(h.redSub(n)), l = d.redMul(_));
  } else
    h = a.redAdd(n), y = this.curve._mulC(this.z).redSqr(), _ = h.redSub(y).redSub(y), u = this.curve._mulC(t.redISub(h)).redMul(_), o = this.curve._mulC(h).redMul(a.redISub(n)), l = h.redMul(_);
  return this.curve.point(u, o, l);
};
Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function(t) {
  var a = this.y.redSub(this.x).redMul(t.y.redSub(t.x)), n = this.y.redAdd(this.x).redMul(t.y.redAdd(t.x)), u = this.t.redMul(this.curve.dd).redMul(t.t), o = this.z.redMul(t.z.redAdd(t.z)), l = n.redSub(a), h = o.redSub(u), y = o.redAdd(u), _ = n.redAdd(a), d = l.redMul(h), $ = y.redMul(_), N = l.redMul(_), U = h.redMul(y);
  return this.curve.point(d, $, U, N);
};
Point.prototype._projAdd = function(t) {
  var a = this.z.redMul(t.z), n = a.redSqr(), u = this.x.redMul(t.x), o = this.y.redMul(t.y), l = this.curve.d.redMul(u).redMul(o), h = n.redSub(l), y = n.redAdd(l), _ = this.x.redAdd(this.y).redMul(t.x.redAdd(t.y)).redISub(u).redISub(o), d = a.redMul(h).redMul(_), $, N;
  return this.curve.twisted ? ($ = a.redMul(y).redMul(o.redSub(this.curve._mulA(u))), N = h.redMul(y)) : ($ = a.redMul(y).redMul(o.redSub(u)), N = this.curve._mulC(h).redMul(y)), this.curve.point(d, $, N);
};
Point.prototype.add = function(t) {
  return this.isInfinity() ? t : t.isInfinity() ? this : this.curve.extended ? this._extAdd(t) : this._projAdd(t);
};
Point.prototype.mul = function(t) {
  return this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve._wnafMul(this, t);
};
Point.prototype.mulAdd = function(t, a, n) {
  return this.curve._wnafMulAdd(1, [this, a], [t, n], 2, !1);
};
Point.prototype.jmulAdd = function(t, a, n) {
  return this.curve._wnafMulAdd(1, [this, a], [t, n], 2, !0);
};
Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var t = this.z.redInvm();
  return this.x = this.x.redMul(t), this.y = this.y.redMul(t), this.t && (this.t = this.t.redMul(t)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function(t) {
  return this === t || this.getX().cmp(t.getX()) === 0 && this.getY().cmp(t.getY()) === 0;
};
Point.prototype.eqXToP = function(t) {
  var a = t.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(a) === 0)
    return !0;
  for (var n = t.clone(), u = this.curve.redN.redMul(this.z); ; ) {
    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
      return !1;
    if (a.redIAdd(u), this.x.cmp(a) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(e) {
  var t = e;
  t.base = base$1, t.short = short, t.mont = mont, t.edwards = edwards;
})(curve);
var curves$1 = {}, hash$3 = {}, utils$f = {}, assert$a = minimalisticAssert, inherits$1 = inherits_browserExports;
utils$f.inherits = inherits$1;
function isSurrogatePair(e, t) {
  return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length ? !1 : (e.charCodeAt(t + 1) & 64512) === 56320;
}
function toArray(e, t) {
  if (Array.isArray(e))
    return e.slice();
  if (!e)
    return [];
  var a = [];
  if (typeof e == "string")
    if (t) {
      if (t === "hex")
        for (e = e.replace(/[^a-z0-9]+/ig, ""), e.length % 2 !== 0 && (e = "0" + e), u = 0; u < e.length; u += 2)
          a.push(parseInt(e[u] + e[u + 1], 16));
    } else
      for (var n = 0, u = 0; u < e.length; u++) {
        var o = e.charCodeAt(u);
        o < 128 ? a[n++] = o : o < 2048 ? (a[n++] = o >> 6 | 192, a[n++] = o & 63 | 128) : isSurrogatePair(e, u) ? (o = 65536 + ((o & 1023) << 10) + (e.charCodeAt(++u) & 1023), a[n++] = o >> 18 | 240, a[n++] = o >> 12 & 63 | 128, a[n++] = o >> 6 & 63 | 128, a[n++] = o & 63 | 128) : (a[n++] = o >> 12 | 224, a[n++] = o >> 6 & 63 | 128, a[n++] = o & 63 | 128);
      }
  else
    for (u = 0; u < e.length; u++)
      a[u] = e[u] | 0;
  return a;
}
utils$f.toArray = toArray;
function toHex$1(e) {
  for (var t = "", a = 0; a < e.length; a++)
    t += zero2(e[a].toString(16));
  return t;
}
utils$f.toHex = toHex$1;
function htonl(e) {
  var t = e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (e & 255) << 24;
  return t >>> 0;
}
utils$f.htonl = htonl;
function toHex32(e, t) {
  for (var a = "", n = 0; n < e.length; n++) {
    var u = e[n];
    t === "little" && (u = htonl(u)), a += zero8(u.toString(16));
  }
  return a;
}
utils$f.toHex32 = toHex32;
function zero2(e) {
  return e.length === 1 ? "0" + e : e;
}
utils$f.zero2 = zero2;
function zero8(e) {
  return e.length === 7 ? "0" + e : e.length === 6 ? "00" + e : e.length === 5 ? "000" + e : e.length === 4 ? "0000" + e : e.length === 3 ? "00000" + e : e.length === 2 ? "000000" + e : e.length === 1 ? "0000000" + e : e;
}
utils$f.zero8 = zero8;
function join32(e, t, a, n) {
  var u = a - t;
  assert$a(u % 4 === 0);
  for (var o = new Array(u / 4), l = 0, h = t; l < o.length; l++, h += 4) {
    var y;
    n === "big" ? y = e[h] << 24 | e[h + 1] << 16 | e[h + 2] << 8 | e[h + 3] : y = e[h + 3] << 24 | e[h + 2] << 16 | e[h + 1] << 8 | e[h], o[l] = y >>> 0;
  }
  return o;
}
utils$f.join32 = join32;
function split32(e, t) {
  for (var a = new Array(e.length * 4), n = 0, u = 0; n < e.length; n++, u += 4) {
    var o = e[n];
    t === "big" ? (a[u] = o >>> 24, a[u + 1] = o >>> 16 & 255, a[u + 2] = o >>> 8 & 255, a[u + 3] = o & 255) : (a[u + 3] = o >>> 24, a[u + 2] = o >>> 16 & 255, a[u + 1] = o >>> 8 & 255, a[u] = o & 255);
  }
  return a;
}
utils$f.split32 = split32;
function rotr32$1(e, t) {
  return e >>> t | e << 32 - t;
}
utils$f.rotr32 = rotr32$1;
function rotl32$2(e, t) {
  return e << t | e >>> 32 - t;
}
utils$f.rotl32 = rotl32$2;
function sum32$3(e, t) {
  return e + t >>> 0;
}
utils$f.sum32 = sum32$3;
function sum32_3$1(e, t, a) {
  return e + t + a >>> 0;
}
utils$f.sum32_3 = sum32_3$1;
function sum32_4$2(e, t, a, n) {
  return e + t + a + n >>> 0;
}
utils$f.sum32_4 = sum32_4$2;
function sum32_5$2(e, t, a, n, u) {
  return e + t + a + n + u >>> 0;
}
utils$f.sum32_5 = sum32_5$2;
function sum64$1(e, t, a, n) {
  var u = e[t], o = e[t + 1], l = n + o >>> 0, h = (l < n ? 1 : 0) + a + u;
  e[t] = h >>> 0, e[t + 1] = l;
}
utils$f.sum64 = sum64$1;
function sum64_hi$1(e, t, a, n) {
  var u = t + n >>> 0, o = (u < t ? 1 : 0) + e + a;
  return o >>> 0;
}
utils$f.sum64_hi = sum64_hi$1;
function sum64_lo$1(e, t, a, n) {
  var u = t + n;
  return u >>> 0;
}
utils$f.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(e, t, a, n, u, o, l, h) {
  var y = 0, _ = t;
  _ = _ + n >>> 0, y += _ < t ? 1 : 0, _ = _ + o >>> 0, y += _ < o ? 1 : 0, _ = _ + h >>> 0, y += _ < h ? 1 : 0;
  var d = e + a + u + l + y;
  return d >>> 0;
}
utils$f.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(e, t, a, n, u, o, l, h) {
  var y = t + n + o + h;
  return y >>> 0;
}
utils$f.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(e, t, a, n, u, o, l, h, y, _) {
  var d = 0, $ = t;
  $ = $ + n >>> 0, d += $ < t ? 1 : 0, $ = $ + o >>> 0, d += $ < o ? 1 : 0, $ = $ + h >>> 0, d += $ < h ? 1 : 0, $ = $ + _ >>> 0, d += $ < _ ? 1 : 0;
  var N = e + a + u + l + y + d;
  return N >>> 0;
}
utils$f.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(e, t, a, n, u, o, l, h, y, _) {
  var d = t + n + o + h + _;
  return d >>> 0;
}
utils$f.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(e, t, a) {
  var n = t << 32 - a | e >>> a;
  return n >>> 0;
}
utils$f.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(e, t, a) {
  var n = e << 32 - a | t >>> a;
  return n >>> 0;
}
utils$f.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(e, t, a) {
  return e >>> a;
}
utils$f.shr64_hi = shr64_hi$1;
function shr64_lo$1(e, t, a) {
  var n = e << 32 - a | t >>> a;
  return n >>> 0;
}
utils$f.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$e = utils$f, assert$9 = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(t, a) {
  if (t = utils$e.toArray(t, a), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
    t = this.pending;
    var n = t.length % this._delta8;
    this.pending = t.slice(t.length - n, t.length), this.pending.length === 0 && (this.pending = null), t = utils$e.join32(t, 0, t.length - n, this.endian);
    for (var u = 0; u < t.length; u += this._delta32)
      this._update(t, u, u + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(t) {
  return this.update(this._pad()), assert$9(this.pending === null), this._digest(t);
};
BlockHash$4.prototype._pad = function() {
  var t = this.pendingTotal, a = this._delta8, n = a - (t + this.padLength) % a, u = new Array(n + this.padLength);
  u[0] = 128;
  for (var o = 1; o < n; o++)
    u[o] = 0;
  if (t <<= 3, this.endian === "big") {
    for (var l = 8; l < this.padLength; l++)
      u[o++] = 0;
    u[o++] = 0, u[o++] = 0, u[o++] = 0, u[o++] = 0, u[o++] = t >>> 24 & 255, u[o++] = t >>> 16 & 255, u[o++] = t >>> 8 & 255, u[o++] = t & 255;
  } else
    for (u[o++] = t & 255, u[o++] = t >>> 8 & 255, u[o++] = t >>> 16 & 255, u[o++] = t >>> 24 & 255, u[o++] = 0, u[o++] = 0, u[o++] = 0, u[o++] = 0, l = 8; l < this.padLength; l++)
      u[o++] = 0;
  return u;
};
var sha = {}, common$4 = {}, utils$d = utils$f, rotr32 = utils$d.rotr32;
function ft_1$1(e, t, a, n) {
  if (e === 0)
    return ch32$1(t, a, n);
  if (e === 1 || e === 3)
    return p32(t, a, n);
  if (e === 2)
    return maj32$1(t, a, n);
}
common$4.ft_1 = ft_1$1;
function ch32$1(e, t, a) {
  return e & t ^ ~e & a;
}
common$4.ch32 = ch32$1;
function maj32$1(e, t, a) {
  return e & t ^ e & a ^ t & a;
}
common$4.maj32 = maj32$1;
function p32(e, t, a) {
  return e ^ t ^ a;
}
common$4.p32 = p32;
function s0_256$1(e) {
  return rotr32(e, 2) ^ rotr32(e, 13) ^ rotr32(e, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(e) {
  return rotr32(e, 6) ^ rotr32(e, 11) ^ rotr32(e, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(e) {
  return rotr32(e, 7) ^ rotr32(e, 18) ^ e >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(e) {
  return rotr32(e, 17) ^ rotr32(e, 19) ^ e >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$c = utils$f, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$c.rotl32, sum32$2 = utils$c.sum32, sum32_5$1 = utils$c.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$c.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(t, a) {
  for (var n = this.W, u = 0; u < 16; u++)
    n[u] = t[a + u];
  for (; u < n.length; u++)
    n[u] = rotl32$1(n[u - 3] ^ n[u - 8] ^ n[u - 14] ^ n[u - 16], 1);
  var o = this.h[0], l = this.h[1], h = this.h[2], y = this.h[3], _ = this.h[4];
  for (u = 0; u < n.length; u++) {
    var d = ~~(u / 20), $ = sum32_5$1(rotl32$1(o, 5), ft_1(d, l, h, y), _, n[u], sha1_K[d]);
    _ = y, y = h, h = rotl32$1(l, 30), l = o, o = $;
  }
  this.h[0] = sum32$2(this.h[0], o), this.h[1] = sum32$2(this.h[1], l), this.h[2] = sum32$2(this.h[2], h), this.h[3] = sum32$2(this.h[3], y), this.h[4] = sum32$2(this.h[4], _);
};
SHA1.prototype._digest = function(t) {
  return t === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$f, common$2 = common$5, shaCommon = common$4, assert$8 = minimalisticAssert, sum32$1 = utils$b.sum32, sum32_4$1 = utils$b.sum32_4, sum32_5 = utils$b.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$b.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(t, a) {
  for (var n = this.W, u = 0; u < 16; u++)
    n[u] = t[a + u];
  for (; u < n.length; u++)
    n[u] = sum32_4$1(g1_256(n[u - 2]), n[u - 7], g0_256(n[u - 15]), n[u - 16]);
  var o = this.h[0], l = this.h[1], h = this.h[2], y = this.h[3], _ = this.h[4], d = this.h[5], $ = this.h[6], N = this.h[7];
  for (assert$8(this.k.length === n.length), u = 0; u < n.length; u++) {
    var U = sum32_5(N, s1_256(_), ch32(_, d, $), this.k[u], n[u]), V = sum32$1(s0_256(o), maj32(o, l, h));
    N = $, $ = d, d = _, _ = sum32$1(y, U), y = h, h = l, l = o, o = sum32$1(U, V);
  }
  this.h[0] = sum32$1(this.h[0], o), this.h[1] = sum32$1(this.h[1], l), this.h[2] = sum32$1(this.h[2], h), this.h[3] = sum32$1(this.h[3], y), this.h[4] = sum32$1(this.h[4], _), this.h[5] = sum32$1(this.h[5], d), this.h[6] = sum32$1(this.h[6], $), this.h[7] = sum32$1(this.h[7], N);
};
SHA256$1.prototype._digest = function(t) {
  return t === "hex" ? utils$b.toHex32(this.h, "big") : utils$b.split32(this.h, "big");
};
var utils$a = utils$f, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$a.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(t) {
  return t === "hex" ? utils$a.toHex32(this.h.slice(0, 7), "big") : utils$a.split32(this.h.slice(0, 7), "big");
};
var utils$9 = utils$f, common$1 = common$5, assert$7 = minimalisticAssert, rotr64_hi = utils$9.rotr64_hi, rotr64_lo = utils$9.rotr64_lo, shr64_hi = utils$9.shr64_hi, shr64_lo = utils$9.shr64_lo, sum64 = utils$9.sum64, sum64_hi = utils$9.sum64_hi, sum64_lo = utils$9.sum64_lo, sum64_4_hi = utils$9.sum64_4_hi, sum64_4_lo = utils$9.sum64_4_lo, sum64_5_hi = utils$9.sum64_5_hi, sum64_5_lo = utils$9.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$9.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(t, a) {
  for (var n = this.W, u = 0; u < 32; u++)
    n[u] = t[a + u];
  for (; u < n.length; u += 2) {
    var o = g1_512_hi(n[u - 4], n[u - 3]), l = g1_512_lo(n[u - 4], n[u - 3]), h = n[u - 14], y = n[u - 13], _ = g0_512_hi(n[u - 30], n[u - 29]), d = g0_512_lo(n[u - 30], n[u - 29]), $ = n[u - 32], N = n[u - 31];
    n[u] = sum64_4_hi(
      o,
      l,
      h,
      y,
      _,
      d,
      $,
      N
    ), n[u + 1] = sum64_4_lo(
      o,
      l,
      h,
      y,
      _,
      d,
      $,
      N
    );
  }
};
SHA512$1.prototype._update = function(t, a) {
  this._prepareBlock(t, a);
  var n = this.W, u = this.h[0], o = this.h[1], l = this.h[2], h = this.h[3], y = this.h[4], _ = this.h[5], d = this.h[6], $ = this.h[7], N = this.h[8], U = this.h[9], V = this.h[10], Q = this.h[11], ie = this.h[12], ee = this.h[13], ne = this.h[14], ge = this.h[15];
  assert$7(this.k.length === n.length);
  for (var be = 0; be < n.length; be += 2) {
    var Ee = ne, xe = ge, Le = s1_512_hi(N, U), Ne = s1_512_lo(N, U), Re = ch64_hi(N, U, V, Q, ie), Xe = ch64_lo(N, U, V, Q, ie, ee), pe = this.k[be], O = this.k[be + 1], E = n[be], c = n[be + 1], b = sum64_5_hi(
      Ee,
      xe,
      Le,
      Ne,
      Re,
      Xe,
      pe,
      O,
      E,
      c
    ), C = sum64_5_lo(
      Ee,
      xe,
      Le,
      Ne,
      Re,
      Xe,
      pe,
      O,
      E,
      c
    );
    Ee = s0_512_hi(u, o), xe = s0_512_lo(u, o), Le = maj64_hi(u, o, l, h, y), Ne = maj64_lo(u, o, l, h, y, _);
    var x = sum64_hi(Ee, xe, Le, Ne), B = sum64_lo(Ee, xe, Le, Ne);
    ne = ie, ge = ee, ie = V, ee = Q, V = N, Q = U, N = sum64_hi(d, $, b, C), U = sum64_lo($, $, b, C), d = y, $ = _, y = l, _ = h, l = u, h = o, u = sum64_hi(b, C, x, B), o = sum64_lo(b, C, x, B);
  }
  sum64(this.h, 0, u, o), sum64(this.h, 2, l, h), sum64(this.h, 4, y, _), sum64(this.h, 6, d, $), sum64(this.h, 8, N, U), sum64(this.h, 10, V, Q), sum64(this.h, 12, ie, ee), sum64(this.h, 14, ne, ge);
};
SHA512$1.prototype._digest = function(t) {
  return t === "hex" ? utils$9.toHex32(this.h, "big") : utils$9.split32(this.h, "big");
};
function ch64_hi(e, t, a, n, u) {
  var o = e & a ^ ~e & u;
  return o < 0 && (o += 4294967296), o;
}
function ch64_lo(e, t, a, n, u, o) {
  var l = t & n ^ ~t & o;
  return l < 0 && (l += 4294967296), l;
}
function maj64_hi(e, t, a, n, u) {
  var o = e & a ^ e & u ^ a & u;
  return o < 0 && (o += 4294967296), o;
}
function maj64_lo(e, t, a, n, u, o) {
  var l = t & n ^ t & o ^ n & o;
  return l < 0 && (l += 4294967296), l;
}
function s0_512_hi(e, t) {
  var a = rotr64_hi(e, t, 28), n = rotr64_hi(t, e, 2), u = rotr64_hi(t, e, 7), o = a ^ n ^ u;
  return o < 0 && (o += 4294967296), o;
}
function s0_512_lo(e, t) {
  var a = rotr64_lo(e, t, 28), n = rotr64_lo(t, e, 2), u = rotr64_lo(t, e, 7), o = a ^ n ^ u;
  return o < 0 && (o += 4294967296), o;
}
function s1_512_hi(e, t) {
  var a = rotr64_hi(e, t, 14), n = rotr64_hi(e, t, 18), u = rotr64_hi(t, e, 9), o = a ^ n ^ u;
  return o < 0 && (o += 4294967296), o;
}
function s1_512_lo(e, t) {
  var a = rotr64_lo(e, t, 14), n = rotr64_lo(e, t, 18), u = rotr64_lo(t, e, 9), o = a ^ n ^ u;
  return o < 0 && (o += 4294967296), o;
}
function g0_512_hi(e, t) {
  var a = rotr64_hi(e, t, 1), n = rotr64_hi(e, t, 8), u = shr64_hi(e, t, 7), o = a ^ n ^ u;
  return o < 0 && (o += 4294967296), o;
}
function g0_512_lo(e, t) {
  var a = rotr64_lo(e, t, 1), n = rotr64_lo(e, t, 8), u = shr64_lo(e, t, 7), o = a ^ n ^ u;
  return o < 0 && (o += 4294967296), o;
}
function g1_512_hi(e, t) {
  var a = rotr64_hi(e, t, 19), n = rotr64_hi(t, e, 29), u = shr64_hi(e, t, 6), o = a ^ n ^ u;
  return o < 0 && (o += 4294967296), o;
}
function g1_512_lo(e, t) {
  var a = rotr64_lo(e, t, 19), n = rotr64_lo(t, e, 29), u = shr64_lo(e, t, 6), o = a ^ n ^ u;
  return o < 0 && (o += 4294967296), o;
}
var utils$8 = utils$f, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$8.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(t) {
  return t === "hex" ? utils$8.toHex32(this.h.slice(0, 12), "big") : utils$8.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$7 = utils$f, common = common$5, rotl32 = utils$7.rotl32, sum32 = utils$7.sum32, sum32_3 = utils$7.sum32_3, sum32_4 = utils$7.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$7.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function(t, a) {
  for (var n = this.h[0], u = this.h[1], o = this.h[2], l = this.h[3], h = this.h[4], y = n, _ = u, d = o, $ = l, N = h, U = 0; U < 80; U++) {
    var V = sum32(
      rotl32(
        sum32_4(n, f$1(U, u, o, l), t[r[U] + a], K(U)),
        s$1[U]
      ),
      h
    );
    n = h, h = l, l = rotl32(o, 10), o = u, u = V, V = sum32(
      rotl32(
        sum32_4(y, f$1(79 - U, _, d, $), t[rh[U] + a], Kh(U)),
        sh[U]
      ),
      N
    ), y = N, N = $, $ = rotl32(d, 10), d = _, _ = V;
  }
  V = sum32_3(this.h[1], o, $), this.h[1] = sum32_3(this.h[2], l, N), this.h[2] = sum32_3(this.h[3], h, y), this.h[3] = sum32_3(this.h[4], n, _), this.h[4] = sum32_3(this.h[0], u, d), this.h[0] = V;
};
RIPEMD160.prototype._digest = function(t) {
  return t === "hex" ? utils$7.toHex32(this.h, "little") : utils$7.split32(this.h, "little");
};
function f$1(e, t, a, n) {
  return e <= 15 ? t ^ a ^ n : e <= 31 ? t & a | ~t & n : e <= 47 ? (t | ~a) ^ n : e <= 63 ? t & n | a & ~n : t ^ (a | ~n);
}
function K(e) {
  return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838;
}
function Kh(e) {
  return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$6 = utils$f, assert$6 = minimalisticAssert;
function Hmac(e, t, a) {
  if (!(this instanceof Hmac))
    return new Hmac(e, t, a);
  this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(utils$6.toArray(t, a));
}
var hmac$1 = Hmac;
Hmac.prototype._init = function(t) {
  t.length > this.blockSize && (t = new this.Hash().update(t).digest()), assert$6(t.length <= this.blockSize);
  for (var a = t.length; a < this.blockSize; a++)
    t.push(0);
  for (a = 0; a < t.length; a++)
    t[a] ^= 54;
  for (this.inner = new this.Hash().update(t), a = 0; a < t.length; a++)
    t[a] ^= 106;
  this.outer = new this.Hash().update(t);
};
Hmac.prototype.update = function(t, a) {
  return this.inner.update(t, a), this;
};
Hmac.prototype.digest = function(t) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t);
};
(function(e) {
  var t = e;
  t.utils = utils$f, t.common = common$5, t.sha = sha, t.ripemd = ripemd, t.hmac = hmac$1, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(hash$3);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(e) {
  var t = e, a = hash$3, n = curve, u = utils$l, o = u.assert;
  function l(_) {
    _.type === "short" ? this.curve = new n.short(_) : _.type === "edwards" ? this.curve = new n.edwards(_) : this.curve = new n.mont(_), this.g = this.curve.g, this.n = this.curve.n, this.hash = _.hash, o(this.g.validate(), "Invalid curve"), o(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = l;
  function h(_, d) {
    Object.defineProperty(t, _, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var $ = new l(d);
        return Object.defineProperty(t, _, {
          configurable: !0,
          enumerable: !0,
          value: $
        }), $;
      }
    });
  }
  h("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: a.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), h("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: a.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), h("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: a.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), h("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: a.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), h("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: a.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), h("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: a.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), h("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: a.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var y;
  try {
    y = requireSecp256k1();
  } catch {
    y = void 0;
  }
  h("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: a.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      y
    ]
  });
})(curves$1);
var hash$2 = hash$3, utils$5 = utils$k, assert$5 = minimalisticAssert;
function HmacDRBG(e) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(e);
  this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = utils$5.toArray(e.entropy, e.entropyEnc || "hex"), a = utils$5.toArray(e.nonce, e.nonceEnc || "hex"), n = utils$5.toArray(e.pers, e.persEnc || "hex");
  assert$5(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, a, n);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(t, a, n) {
  var u = t.concat(a).concat(n);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var o = 0; o < this.V.length; o++)
    this.K[o] = 0, this.V[o] = 1;
  this._update(u), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(t) {
  var a = this._hmac().update(this.V).update([0]);
  t && (a = a.update(t)), this.K = a.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(t, a, n, u) {
  typeof a != "string" && (u = n, n = a, a = null), t = utils$5.toArray(t, a), n = utils$5.toArray(n, u), assert$5(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(t.concat(n || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(t, a, n, u) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof a != "string" && (u = n, n = a, a = null), n && (n = utils$5.toArray(n, u || "hex"), this._update(n));
  for (var o = []; o.length < t; )
    this.V = this._hmac().update(this.V).digest(), o = o.concat(this.V);
  var l = o.slice(0, t);
  return this._update(n), this._reseed++, utils$5.encode(l, a);
};
var BN$5 = bnExports$2, utils$4 = utils$l, assert$4 = utils$4.assert;
function KeyPair$2(e, t) {
  this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var key$2 = KeyPair$2;
KeyPair$2.fromPublic = function(t, a, n) {
  return a instanceof KeyPair$2 ? a : new KeyPair$2(t, {
    pub: a,
    pubEnc: n
  });
};
KeyPair$2.fromPrivate = function(t, a, n) {
  return a instanceof KeyPair$2 ? a : new KeyPair$2(t, {
    priv: a,
    privEnc: n
  });
};
KeyPair$2.prototype.validate = function() {
  var t = this.getPublic();
  return t.isInfinity() ? { result: !1, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function(t, a) {
  return typeof t == "string" && (a = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), a ? this.pub.encode(a, t) : this.pub;
};
KeyPair$2.prototype.getPrivate = function(t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function(t, a) {
  this.priv = new BN$5(t, a || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function(t, a) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? assert$4(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$4(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t, a);
};
KeyPair$2.prototype.derive = function(t) {
  return t.validate() || assert$4(t.validate(), "public point not validated"), t.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function(t, a, n) {
  return this.ec.sign(t, this, a, n);
};
KeyPair$2.prototype.verify = function(t, a, n) {
  return this.ec.verify(t, a, this, void 0, n);
};
KeyPair$2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$2, utils$3 = utils$l, assert$3 = utils$3.assert;
function Signature$2(e, t) {
  if (e instanceof Signature$2)
    return e;
  this._importDER(e, t) || (assert$3(e.r && e.s, "Signature without r or s"), this.r = new BN$4(e.r, 16), this.s = new BN$4(e.s, 16), e.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(e, t) {
  var a = e[t.place++];
  if (!(a & 128))
    return a;
  var n = a & 15;
  if (n === 0 || n > 4 || e[t.place] === 0)
    return !1;
  for (var u = 0, o = 0, l = t.place; o < n; o++, l++)
    u <<= 8, u |= e[l], u >>>= 0;
  return u <= 127 ? !1 : (t.place = l, u);
}
function rmPadding(e) {
  for (var t = 0, a = e.length - 1; !e[t] && !(e[t + 1] & 128) && t < a; )
    t++;
  return t === 0 ? e : e.slice(t);
}
Signature$2.prototype._importDER = function(t, a) {
  t = utils$3.toArray(t, a);
  var n = new Position();
  if (t[n.place++] !== 48)
    return !1;
  var u = getLength(t, n);
  if (u === !1 || u + n.place !== t.length || t[n.place++] !== 2)
    return !1;
  var o = getLength(t, n);
  if (o === !1 || t[n.place] & 128)
    return !1;
  var l = t.slice(n.place, o + n.place);
  if (n.place += o, t[n.place++] !== 2)
    return !1;
  var h = getLength(t, n);
  if (h === !1 || t.length !== h + n.place || t[n.place] & 128)
    return !1;
  var y = t.slice(n.place, h + n.place);
  if (l[0] === 0)
    if (l[1] & 128)
      l = l.slice(1);
    else
      return !1;
  if (y[0] === 0)
    if (y[1] & 128)
      y = y.slice(1);
    else
      return !1;
  return this.r = new BN$4(l), this.s = new BN$4(y), this.recoveryParam = null, !0;
};
function constructLength(e, t) {
  if (t < 128) {
    e.push(t);
    return;
  }
  var a = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (e.push(a | 128); --a; )
    e.push(t >>> (a << 3) & 255);
  e.push(t);
}
Signature$2.prototype.toDER = function(t) {
  var a = this.r.toArray(), n = this.s.toArray();
  for (a[0] & 128 && (a = [0].concat(a)), n[0] & 128 && (n = [0].concat(n)), a = rmPadding(a), n = rmPadding(n); !n[0] && !(n[1] & 128); )
    n = n.slice(1);
  var u = [2];
  constructLength(u, a.length), u = u.concat(a), u.push(2), constructLength(u, n.length);
  var o = u.concat(n), l = [48];
  return constructLength(l, o.length), l = l.concat(o), utils$3.encode(l, t);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec;
  hasRequiredEc = 1;
  var e = bnExports$2, t = hmacDrbg, a = utils$l, n = curves$1, u = requireBrorand(), o = a.assert, l = key$2, h = signature$1;
  function y(_) {
    if (!(this instanceof y))
      return new y(_);
    typeof _ == "string" && (o(
      Object.prototype.hasOwnProperty.call(n, _),
      "Unknown curve " + _
    ), _ = n[_]), _ instanceof n.PresetCurve && (_ = { curve: _ }), this.curve = _.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = _.curve.g, this.g.precompute(_.curve.n.bitLength() + 1), this.hash = _.hash || _.curve.hash;
  }
  return ec = y, y.prototype.keyPair = function(d) {
    return new l(this, d);
  }, y.prototype.keyFromPrivate = function(d, $) {
    return l.fromPrivate(this, d, $);
  }, y.prototype.keyFromPublic = function(d, $) {
    return l.fromPublic(this, d, $);
  }, y.prototype.genKeyPair = function(d) {
    d || (d = {});
    for (var $ = new t({
      hash: this.hash,
      pers: d.pers,
      persEnc: d.persEnc || "utf8",
      entropy: d.entropy || u(this.hash.hmacStrength),
      entropyEnc: d.entropy && d.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), N = this.n.byteLength(), U = this.n.sub(new e(2)); ; ) {
      var V = new e($.generate(N));
      if (!(V.cmp(U) > 0))
        return V.iaddn(1), this.keyFromPrivate(V);
    }
  }, y.prototype._truncateToN = function(d, $, N) {
    var U;
    if (e.isBN(d) || typeof d == "number")
      d = new e(d, 16), U = d.byteLength();
    else if (typeof d == "object")
      U = d.length, d = new e(d, 16);
    else {
      var V = d.toString();
      U = V.length + 1 >>> 1, d = new e(V, 16);
    }
    typeof N != "number" && (N = U * 8);
    var Q = N - this.n.bitLength();
    return Q > 0 && (d = d.ushrn(Q)), !$ && d.cmp(this.n) >= 0 ? d.sub(this.n) : d;
  }, y.prototype.sign = function(d, $, N, U) {
    if (typeof N == "object" && (U = N, N = null), U || (U = {}), typeof d != "string" && typeof d != "number" && !e.isBN(d)) {
      o(
        typeof d == "object" && d && typeof d.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), o(d.length >>> 0 === d.length);
      for (var V = 0; V < d.length; V++)
        o((d[V] & 255) === d[V]);
    }
    $ = this.keyFromPrivate($, N), d = this._truncateToN(d, !1, U.msgBitLength), o(!d.isNeg(), "Can not sign a negative message");
    var Q = this.n.byteLength(), ie = $.getPrivate().toArray("be", Q), ee = d.toArray("be", Q);
    o(new e(ee).eq(d), "Can not sign message");
    for (var ne = new t({
      hash: this.hash,
      entropy: ie,
      nonce: ee,
      pers: U.pers,
      persEnc: U.persEnc || "utf8"
    }), ge = this.n.sub(new e(1)), be = 0; ; be++) {
      var Ee = U.k ? U.k(be) : new e(ne.generate(this.n.byteLength()));
      if (Ee = this._truncateToN(Ee, !0), !(Ee.cmpn(1) <= 0 || Ee.cmp(ge) >= 0)) {
        var xe = this.g.mul(Ee);
        if (!xe.isInfinity()) {
          var Le = xe.getX(), Ne = Le.umod(this.n);
          if (Ne.cmpn(0) !== 0) {
            var Re = Ee.invm(this.n).mul(Ne.mul($.getPrivate()).iadd(d));
            if (Re = Re.umod(this.n), Re.cmpn(0) !== 0) {
              var Xe = (xe.getY().isOdd() ? 1 : 0) | (Le.cmp(Ne) !== 0 ? 2 : 0);
              return U.canonical && Re.cmp(this.nh) > 0 && (Re = this.n.sub(Re), Xe ^= 1), new h({ r: Ne, s: Re, recoveryParam: Xe });
            }
          }
        }
      }
    }
  }, y.prototype.verify = function(d, $, N, U, V) {
    V || (V = {}), d = this._truncateToN(d, !1, V.msgBitLength), N = this.keyFromPublic(N, U), $ = new h($, "hex");
    var Q = $.r, ie = $.s;
    if (Q.cmpn(1) < 0 || Q.cmp(this.n) >= 0 || ie.cmpn(1) < 0 || ie.cmp(this.n) >= 0)
      return !1;
    var ee = ie.invm(this.n), ne = ee.mul(d).umod(this.n), ge = ee.mul(Q).umod(this.n), be;
    return this.curve._maxwellTrick ? (be = this.g.jmulAdd(ne, N.getPublic(), ge), be.isInfinity() ? !1 : be.eqXToP(Q)) : (be = this.g.mulAdd(ne, N.getPublic(), ge), be.isInfinity() ? !1 : be.getX().umod(this.n).cmp(Q) === 0);
  }, y.prototype.recoverPubKey = function(_, d, $, N) {
    o((3 & $) === $, "The recovery param is more than two bits"), d = new h(d, N);
    var U = this.n, V = new e(_), Q = d.r, ie = d.s, ee = $ & 1, ne = $ >> 1;
    if (Q.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ne)
      throw new Error("Unable to find sencond key candinate");
    ne ? Q = this.curve.pointFromX(Q.add(this.curve.n), ee) : Q = this.curve.pointFromX(Q, ee);
    var ge = d.r.invm(U), be = U.sub(V).mul(ge).umod(U), Ee = ie.mul(ge).umod(U);
    return this.g.mulAdd(be, Q, Ee);
  }, y.prototype.getKeyRecoveryParam = function(_, d, $, N) {
    if (d = new h(d, N), d.recoveryParam !== null)
      return d.recoveryParam;
    for (var U = 0; U < 4; U++) {
      var V;
      try {
        V = this.recoverPubKey(_, d, U);
      } catch {
        continue;
      }
      if (V.eq($))
        return U;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$2 = utils$l, assert$2 = utils$2.assert, parseBytes$2 = utils$2.parseBytes, cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(e, t) {
  this.eddsa = e, this._secret = parseBytes$2(t.secret), e.isPoint(t.pub) ? this._pub = t.pub : this._pubBytes = parseBytes$2(t.pub);
}
KeyPair$1.fromPublic = function(t, a) {
  return a instanceof KeyPair$1 ? a : new KeyPair$1(t, { pub: a });
};
KeyPair$1.fromSecret = function(t, a) {
  return a instanceof KeyPair$1 ? a : new KeyPair$1(t, { secret: a });
};
KeyPair$1.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function() {
  var t = this.eddsa, a = this.hash(), n = t.encodingLength - 1, u = a.slice(0, t.encodingLength);
  return u[0] &= 248, u[n] &= 127, u[n] |= 64, u;
});
cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function(t) {
  return assert$2(this._secret, "KeyPair can only verify"), this.eddsa.sign(t, this);
};
KeyPair$1.prototype.verify = function(t, a) {
  return this.eddsa.verify(t, a, this);
};
KeyPair$1.prototype.getSecret = function(t) {
  return assert$2(this._secret, "KeyPair is public only"), utils$2.encode(this.secret(), t);
};
KeyPair$1.prototype.getPublic = function(t) {
  return utils$2.encode(this.pubBytes(), t);
};
var key$1 = KeyPair$1, BN$3 = bnExports$2, utils$1 = utils$l, assert$1 = utils$1.assert, cachedProperty = utils$1.cachedProperty, parseBytes$1 = utils$1.parseBytes;
function Signature$1(e, t) {
  this.eddsa = e, typeof t != "object" && (t = parseBytes$1(t)), Array.isArray(t) && (assert$1(t.length === e.encodingLength * 2, "Signature has invalid size"), t = {
    R: t.slice(0, e.encodingLength),
    S: t.slice(e.encodingLength)
  }), assert$1(t.R && t.S, "Signature without R or S"), e.isPoint(t.R) && (this._R = t.R), t.S instanceof BN$3 && (this._S = t.S), this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded, this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash$1 = hash$3, curves = curves$1, utils = utils$l, assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = key$1, Signature = signature;
function EDDSA(e) {
  if (assert(e === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(e);
  e = curves[e].curve, this.curve = e, this.g = e.g, this.g.precompute(e.n.bitLength() + 1), this.pointClass = e.point().constructor, this.encodingLength = Math.ceil(e.n.bitLength() / 8), this.hash = hash$1.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(t, a) {
  t = parseBytes(t);
  var n = this.keyFromSecret(a), u = this.hashInt(n.messagePrefix(), t), o = this.g.mul(u), l = this.encodePoint(o), h = this.hashInt(l, n.pubBytes(), t).mul(n.priv()), y = u.add(h).umod(this.curve.n);
  return this.makeSignature({ R: o, S: y, Rencoded: l });
};
EDDSA.prototype.verify = function(t, a, n) {
  if (t = parseBytes(t), a = this.makeSignature(a), a.S().gte(a.eddsa.curve.n) || a.S().isNeg())
    return !1;
  var u = this.keyFromPublic(n), o = this.hashInt(a.Rencoded(), u.pubBytes(), t), l = this.g.mul(a.S()), h = a.R().add(u.pub().mul(o));
  return h.eq(l);
};
EDDSA.prototype.hashInt = function() {
  for (var t = this.hash(), a = 0; a < arguments.length; a++)
    t.update(arguments[a]);
  return utils.intFromLE(t.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(t) {
  return KeyPair.fromPublic(this, t);
};
EDDSA.prototype.keyFromSecret = function(t) {
  return KeyPair.fromSecret(this, t);
};
EDDSA.prototype.makeSignature = function(t) {
  return t instanceof Signature ? t : new Signature(this, t);
};
EDDSA.prototype.encodePoint = function(t) {
  var a = t.getY().toArray("le", this.encodingLength);
  return a[this.encodingLength - 1] |= t.getX().isOdd() ? 128 : 0, a;
};
EDDSA.prototype.decodePoint = function(t) {
  t = utils.parseBytes(t);
  var a = t.length - 1, n = t.slice(0, a).concat(t[a] & -129), u = (t[a] & 128) !== 0, o = utils.intFromLE(n);
  return this.curve.pointFromY(o, u);
};
EDDSA.prototype.encodeInt = function(t) {
  return t.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(t) {
  return utils.intFromLE(t);
};
EDDSA.prototype.isPoint = function(t) {
  return t instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(e) {
    var t = e;
    t.version = require$$0.version, t.utils = utils$l, t.rand = requireBrorand(), t.curve = curve, t.curves = curves$1, t.ec = requireEc(), t.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var bn = { exports: {} };
bn.exports;
(function(e) {
  (function(t, a) {
    function n(E, c) {
      if (!E)
        throw new Error(c || "Assertion failed");
    }
    function u(E, c) {
      E.super_ = c;
      var b = function() {
      };
      b.prototype = c.prototype, E.prototype = new b(), E.prototype.constructor = E;
    }
    function o(E, c, b) {
      if (o.isBN(E))
        return E;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, E !== null && ((c === "le" || c === "be") && (b = c, c = 10), this._init(E || 0, c || 10, b || "be"));
    }
    typeof t == "object" ? t.exports = o : a.BN = o, o.BN = o, o.wordSize = 26;
    var l;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? l = window.Buffer : l = buffer$1.Buffer;
    } catch {
    }
    o.isBN = function(c) {
      return c instanceof o ? !0 : c !== null && typeof c == "object" && c.constructor.wordSize === o.wordSize && Array.isArray(c.words);
    }, o.max = function(c, b) {
      return c.cmp(b) > 0 ? c : b;
    }, o.min = function(c, b) {
      return c.cmp(b) < 0 ? c : b;
    }, o.prototype._init = function(c, b, C) {
      if (typeof c == "number")
        return this._initNumber(c, b, C);
      if (typeof c == "object")
        return this._initArray(c, b, C);
      b === "hex" && (b = 16), n(b === (b | 0) && b >= 2 && b <= 36), c = c.toString().replace(/\s+/g, "");
      var x = 0;
      c[0] === "-" && (x++, this.negative = 1), x < c.length && (b === 16 ? this._parseHex(c, x, C) : (this._parseBase(c, b, x), C === "le" && this._initArray(this.toArray(), b, C)));
    }, o.prototype._initNumber = function(c, b, C) {
      c < 0 && (this.negative = 1, c = -c), c < 67108864 ? (this.words = [c & 67108863], this.length = 1) : c < 4503599627370496 ? (this.words = [
        c & 67108863,
        c / 67108864 & 67108863
      ], this.length = 2) : (n(c < 9007199254740992), this.words = [
        c & 67108863,
        c / 67108864 & 67108863,
        1
      ], this.length = 3), C === "le" && this._initArray(this.toArray(), b, C);
    }, o.prototype._initArray = function(c, b, C) {
      if (n(typeof c.length == "number"), c.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(c.length / 3), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var B, k, w = 0;
      if (C === "be")
        for (x = c.length - 1, B = 0; x >= 0; x -= 3)
          k = c[x] | c[x - 1] << 8 | c[x - 2] << 16, this.words[B] |= k << w & 67108863, this.words[B + 1] = k >>> 26 - w & 67108863, w += 24, w >= 26 && (w -= 26, B++);
      else if (C === "le")
        for (x = 0, B = 0; x < c.length; x += 3)
          k = c[x] | c[x + 1] << 8 | c[x + 2] << 16, this.words[B] |= k << w & 67108863, this.words[B + 1] = k >>> 26 - w & 67108863, w += 24, w >= 26 && (w -= 26, B++);
      return this._strip();
    };
    function h(E, c) {
      var b = E.charCodeAt(c);
      if (b >= 48 && b <= 57)
        return b - 48;
      if (b >= 65 && b <= 70)
        return b - 55;
      if (b >= 97 && b <= 102)
        return b - 87;
      n(!1, "Invalid character in " + E);
    }
    function y(E, c, b) {
      var C = h(E, b);
      return b - 1 >= c && (C |= h(E, b - 1) << 4), C;
    }
    o.prototype._parseHex = function(c, b, C) {
      this.length = Math.ceil((c.length - b) / 6), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var B = 0, k = 0, w;
      if (C === "be")
        for (x = c.length - 1; x >= b; x -= 2)
          w = y(c, b, x) << B, this.words[k] |= w & 67108863, B >= 18 ? (B -= 18, k += 1, this.words[k] |= w >>> 26) : B += 8;
      else {
        var T = c.length - b;
        for (x = T % 2 === 0 ? b + 1 : b; x < c.length; x += 2)
          w = y(c, b, x) << B, this.words[k] |= w & 67108863, B >= 18 ? (B -= 18, k += 1, this.words[k] |= w >>> 26) : B += 8;
      }
      this._strip();
    };
    function _(E, c, b, C) {
      for (var x = 0, B = 0, k = Math.min(E.length, b), w = c; w < k; w++) {
        var T = E.charCodeAt(w) - 48;
        x *= C, T >= 49 ? B = T - 49 + 10 : T >= 17 ? B = T - 17 + 10 : B = T, n(T >= 0 && B < C, "Invalid character"), x += B;
      }
      return x;
    }
    o.prototype._parseBase = function(c, b, C) {
      this.words = [0], this.length = 1;
      for (var x = 0, B = 1; B <= 67108863; B *= b)
        x++;
      x--, B = B / b | 0;
      for (var k = c.length - C, w = k % x, T = Math.min(k, k - w) + C, p = 0, F = C; F < T; F += x)
        p = _(c, F, F + x, b), this.imuln(B), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
      if (w !== 0) {
        var ye = 1;
        for (p = _(c, F, c.length, b), F = 0; F < w; F++)
          ye *= b;
        this.imuln(ye), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
      }
      this._strip();
    }, o.prototype.copy = function(c) {
      c.words = new Array(this.length);
      for (var b = 0; b < this.length; b++)
        c.words[b] = this.words[b];
      c.length = this.length, c.negative = this.negative, c.red = this.red;
    };
    function d(E, c) {
      E.words = c.words, E.length = c.length, E.negative = c.negative, E.red = c.red;
    }
    if (o.prototype._move = function(c) {
      d(c, this);
    }, o.prototype.clone = function() {
      var c = new o(null);
      return this.copy(c), c;
    }, o.prototype._expand = function(c) {
      for (; this.length < c; )
        this.words[this.length++] = 0;
      return this;
    }, o.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        o.prototype[Symbol.for("nodejs.util.inspect.custom")] = $;
      } catch {
        o.prototype.inspect = $;
      }
    else
      o.prototype.inspect = $;
    function $() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var N = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], U = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], V = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    o.prototype.toString = function(c, b) {
      c = c || 10, b = b | 0 || 1;
      var C;
      if (c === 16 || c === "hex") {
        C = "";
        for (var x = 0, B = 0, k = 0; k < this.length; k++) {
          var w = this.words[k], T = ((w << x | B) & 16777215).toString(16);
          B = w >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, k--), B !== 0 || k !== this.length - 1 ? C = N[6 - T.length] + T + C : C = T + C;
        }
        for (B !== 0 && (C = B.toString(16) + C); C.length % b !== 0; )
          C = "0" + C;
        return this.negative !== 0 && (C = "-" + C), C;
      }
      if (c === (c | 0) && c >= 2 && c <= 36) {
        var p = U[c], F = V[c];
        C = "";
        var ye = this.clone();
        for (ye.negative = 0; !ye.isZero(); ) {
          var _e = ye.modrn(F).toString(c);
          ye = ye.idivn(F), ye.isZero() ? C = _e + C : C = N[p - _e.length] + _e + C;
        }
        for (this.isZero() && (C = "0" + C); C.length % b !== 0; )
          C = "0" + C;
        return this.negative !== 0 && (C = "-" + C), C;
      }
      n(!1, "Base should be between 2 and 36");
    }, o.prototype.toNumber = function() {
      var c = this.words[0];
      return this.length === 2 ? c += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? c += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -c : c;
    }, o.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, l && (o.prototype.toBuffer = function(c, b) {
      return this.toArrayLike(l, c, b);
    }), o.prototype.toArray = function(c, b) {
      return this.toArrayLike(Array, c, b);
    };
    var Q = function(c, b) {
      return c.allocUnsafe ? c.allocUnsafe(b) : new c(b);
    };
    o.prototype.toArrayLike = function(c, b, C) {
      this._strip();
      var x = this.byteLength(), B = C || Math.max(1, x);
      n(x <= B, "byte array longer than desired length"), n(B > 0, "Requested array length <= 0");
      var k = Q(c, B), w = b === "le" ? "LE" : "BE";
      return this["_toArrayLike" + w](k, x), k;
    }, o.prototype._toArrayLikeLE = function(c, b) {
      for (var C = 0, x = 0, B = 0, k = 0; B < this.length; B++) {
        var w = this.words[B] << k | x;
        c[C++] = w & 255, C < c.length && (c[C++] = w >> 8 & 255), C < c.length && (c[C++] = w >> 16 & 255), k === 6 ? (C < c.length && (c[C++] = w >> 24 & 255), x = 0, k = 0) : (x = w >>> 24, k += 2);
      }
      if (C < c.length)
        for (c[C++] = x; C < c.length; )
          c[C++] = 0;
    }, o.prototype._toArrayLikeBE = function(c, b) {
      for (var C = c.length - 1, x = 0, B = 0, k = 0; B < this.length; B++) {
        var w = this.words[B] << k | x;
        c[C--] = w & 255, C >= 0 && (c[C--] = w >> 8 & 255), C >= 0 && (c[C--] = w >> 16 & 255), k === 6 ? (C >= 0 && (c[C--] = w >> 24 & 255), x = 0, k = 0) : (x = w >>> 24, k += 2);
      }
      if (C >= 0)
        for (c[C--] = x; C >= 0; )
          c[C--] = 0;
    }, Math.clz32 ? o.prototype._countBits = function(c) {
      return 32 - Math.clz32(c);
    } : o.prototype._countBits = function(c) {
      var b = c, C = 0;
      return b >= 4096 && (C += 13, b >>>= 13), b >= 64 && (C += 7, b >>>= 7), b >= 8 && (C += 4, b >>>= 4), b >= 2 && (C += 2, b >>>= 2), C + b;
    }, o.prototype._zeroBits = function(c) {
      if (c === 0)
        return 26;
      var b = c, C = 0;
      return b & 8191 || (C += 13, b >>>= 13), b & 127 || (C += 7, b >>>= 7), b & 15 || (C += 4, b >>>= 4), b & 3 || (C += 2, b >>>= 2), b & 1 || C++, C;
    }, o.prototype.bitLength = function() {
      var c = this.words[this.length - 1], b = this._countBits(c);
      return (this.length - 1) * 26 + b;
    };
    function ie(E) {
      for (var c = new Array(E.bitLength()), b = 0; b < c.length; b++) {
        var C = b / 26 | 0, x = b % 26;
        c[b] = E.words[C] >>> x & 1;
      }
      return c;
    }
    o.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var c = 0, b = 0; b < this.length; b++) {
        var C = this._zeroBits(this.words[b]);
        if (c += C, C !== 26)
          break;
      }
      return c;
    }, o.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o.prototype.toTwos = function(c) {
      return this.negative !== 0 ? this.abs().inotn(c).iaddn(1) : this.clone();
    }, o.prototype.fromTwos = function(c) {
      return this.testn(c - 1) ? this.notn(c).iaddn(1).ineg() : this.clone();
    }, o.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o.prototype.neg = function() {
      return this.clone().ineg();
    }, o.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o.prototype.iuor = function(c) {
      for (; this.length < c.length; )
        this.words[this.length++] = 0;
      for (var b = 0; b < c.length; b++)
        this.words[b] = this.words[b] | c.words[b];
      return this._strip();
    }, o.prototype.ior = function(c) {
      return n((this.negative | c.negative) === 0), this.iuor(c);
    }, o.prototype.or = function(c) {
      return this.length > c.length ? this.clone().ior(c) : c.clone().ior(this);
    }, o.prototype.uor = function(c) {
      return this.length > c.length ? this.clone().iuor(c) : c.clone().iuor(this);
    }, o.prototype.iuand = function(c) {
      var b;
      this.length > c.length ? b = c : b = this;
      for (var C = 0; C < b.length; C++)
        this.words[C] = this.words[C] & c.words[C];
      return this.length = b.length, this._strip();
    }, o.prototype.iand = function(c) {
      return n((this.negative | c.negative) === 0), this.iuand(c);
    }, o.prototype.and = function(c) {
      return this.length > c.length ? this.clone().iand(c) : c.clone().iand(this);
    }, o.prototype.uand = function(c) {
      return this.length > c.length ? this.clone().iuand(c) : c.clone().iuand(this);
    }, o.prototype.iuxor = function(c) {
      var b, C;
      this.length > c.length ? (b = this, C = c) : (b = c, C = this);
      for (var x = 0; x < C.length; x++)
        this.words[x] = b.words[x] ^ C.words[x];
      if (this !== b)
        for (; x < b.length; x++)
          this.words[x] = b.words[x];
      return this.length = b.length, this._strip();
    }, o.prototype.ixor = function(c) {
      return n((this.negative | c.negative) === 0), this.iuxor(c);
    }, o.prototype.xor = function(c) {
      return this.length > c.length ? this.clone().ixor(c) : c.clone().ixor(this);
    }, o.prototype.uxor = function(c) {
      return this.length > c.length ? this.clone().iuxor(c) : c.clone().iuxor(this);
    }, o.prototype.inotn = function(c) {
      n(typeof c == "number" && c >= 0);
      var b = Math.ceil(c / 26) | 0, C = c % 26;
      this._expand(b), C > 0 && b--;
      for (var x = 0; x < b; x++)
        this.words[x] = ~this.words[x] & 67108863;
      return C > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - C), this._strip();
    }, o.prototype.notn = function(c) {
      return this.clone().inotn(c);
    }, o.prototype.setn = function(c, b) {
      n(typeof c == "number" && c >= 0);
      var C = c / 26 | 0, x = c % 26;
      return this._expand(C + 1), b ? this.words[C] = this.words[C] | 1 << x : this.words[C] = this.words[C] & ~(1 << x), this._strip();
    }, o.prototype.iadd = function(c) {
      var b;
      if (this.negative !== 0 && c.negative === 0)
        return this.negative = 0, b = this.isub(c), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && c.negative !== 0)
        return c.negative = 0, b = this.isub(c), c.negative = 1, b._normSign();
      var C, x;
      this.length > c.length ? (C = this, x = c) : (C = c, x = this);
      for (var B = 0, k = 0; k < x.length; k++)
        b = (C.words[k] | 0) + (x.words[k] | 0) + B, this.words[k] = b & 67108863, B = b >>> 26;
      for (; B !== 0 && k < C.length; k++)
        b = (C.words[k] | 0) + B, this.words[k] = b & 67108863, B = b >>> 26;
      if (this.length = C.length, B !== 0)
        this.words[this.length] = B, this.length++;
      else if (C !== this)
        for (; k < C.length; k++)
          this.words[k] = C.words[k];
      return this;
    }, o.prototype.add = function(c) {
      var b;
      return c.negative !== 0 && this.negative === 0 ? (c.negative = 0, b = this.sub(c), c.negative ^= 1, b) : c.negative === 0 && this.negative !== 0 ? (this.negative = 0, b = c.sub(this), this.negative = 1, b) : this.length > c.length ? this.clone().iadd(c) : c.clone().iadd(this);
    }, o.prototype.isub = function(c) {
      if (c.negative !== 0) {
        c.negative = 0;
        var b = this.iadd(c);
        return c.negative = 1, b._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(c), this.negative = 1, this._normSign();
      var C = this.cmp(c);
      if (C === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var x, B;
      C > 0 ? (x = this, B = c) : (x = c, B = this);
      for (var k = 0, w = 0; w < B.length; w++)
        b = (x.words[w] | 0) - (B.words[w] | 0) + k, k = b >> 26, this.words[w] = b & 67108863;
      for (; k !== 0 && w < x.length; w++)
        b = (x.words[w] | 0) + k, k = b >> 26, this.words[w] = b & 67108863;
      if (k === 0 && w < x.length && x !== this)
        for (; w < x.length; w++)
          this.words[w] = x.words[w];
      return this.length = Math.max(this.length, w), x !== this && (this.negative = 1), this._strip();
    }, o.prototype.sub = function(c) {
      return this.clone().isub(c);
    };
    function ee(E, c, b) {
      b.negative = c.negative ^ E.negative;
      var C = E.length + c.length | 0;
      b.length = C, C = C - 1 | 0;
      var x = E.words[0] | 0, B = c.words[0] | 0, k = x * B, w = k & 67108863, T = k / 67108864 | 0;
      b.words[0] = w;
      for (var p = 1; p < C; p++) {
        for (var F = T >>> 26, ye = T & 67108863, _e = Math.min(p, c.length - 1), de = Math.max(0, p - E.length + 1); de <= _e; de++) {
          var P = p - de | 0;
          x = E.words[P] | 0, B = c.words[de] | 0, k = x * B + ye, F += k / 67108864 | 0, ye = k & 67108863;
        }
        b.words[p] = ye | 0, T = F | 0;
      }
      return T !== 0 ? b.words[p] = T | 0 : b.length--, b._strip();
    }
    var ne = function(c, b, C) {
      var x = c.words, B = b.words, k = C.words, w = 0, T, p, F, ye = x[0] | 0, _e = ye & 8191, de = ye >>> 13, P = x[1] | 0, H = P & 8191, he = P >>> 13, me = x[2] | 0, fe = me & 8191, re = me >>> 13, we = x[3] | 0, ke = we & 8191, Oe = we >>> 13, ce = x[4] | 0, j = ce & 8191, z = ce >>> 13, oe = x[5] | 0, Be = oe & 8191, Te = oe >>> 13, Pe = x[6] | 0, Ye = Pe & 8191, He = Pe >>> 13, ot = x[7] | 0, at = ot & 8191, Qe = ot >>> 13, Pt = x[8] | 0, It = Pt & 8191, pt = Pt >>> 13, Wt = x[9] | 0, Mt = Wt & 8191, vt = Wt >>> 13, Vt = B[0] | 0, Ct = Vt & 8191, lt = Vt >>> 13, zt = B[1] | 0, Tt = zt & 8191, dt = zt >>> 13, Yt = B[2] | 0, Dt = Yt & 8191, bt = Yt >>> 13, Jt = B[3] | 0, Bt = Jt & 8191, ut = Jt >>> 13, Ht = B[4] | 0, Rt = Ht & 8191, gt = Ht >>> 13, Qt = B[5] | 0, kt = Qt & 8191, rt = Qt >>> 13, Xt = B[6] | 0, J = Xt & 8191, ae = Xt >>> 13, ue = B[7] | 0, q = ue & 8191, le = ue >>> 13, Ce = B[8] | 0, Se = Ce & 8191, Ie = Ce >>> 13, Ve = B[9] | 0, Ge = Ve & 8191, qe = Ve >>> 13;
      C.negative = c.negative ^ b.negative, C.length = 19, T = Math.imul(_e, Ct), p = Math.imul(_e, lt), p = p + Math.imul(de, Ct) | 0, F = Math.imul(de, lt);
      var Nt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, T = Math.imul(H, Ct), p = Math.imul(H, lt), p = p + Math.imul(he, Ct) | 0, F = Math.imul(he, lt), T = T + Math.imul(_e, Tt) | 0, p = p + Math.imul(_e, dt) | 0, p = p + Math.imul(de, Tt) | 0, F = F + Math.imul(de, dt) | 0;
      var et = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, T = Math.imul(fe, Ct), p = Math.imul(fe, lt), p = p + Math.imul(re, Ct) | 0, F = Math.imul(re, lt), T = T + Math.imul(H, Tt) | 0, p = p + Math.imul(H, dt) | 0, p = p + Math.imul(he, Tt) | 0, F = F + Math.imul(he, dt) | 0, T = T + Math.imul(_e, Dt) | 0, p = p + Math.imul(_e, bt) | 0, p = p + Math.imul(de, Dt) | 0, F = F + Math.imul(de, bt) | 0;
      var _t = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, T = Math.imul(ke, Ct), p = Math.imul(ke, lt), p = p + Math.imul(Oe, Ct) | 0, F = Math.imul(Oe, lt), T = T + Math.imul(fe, Tt) | 0, p = p + Math.imul(fe, dt) | 0, p = p + Math.imul(re, Tt) | 0, F = F + Math.imul(re, dt) | 0, T = T + Math.imul(H, Dt) | 0, p = p + Math.imul(H, bt) | 0, p = p + Math.imul(he, Dt) | 0, F = F + Math.imul(he, bt) | 0, T = T + Math.imul(_e, Bt) | 0, p = p + Math.imul(_e, ut) | 0, p = p + Math.imul(de, Bt) | 0, F = F + Math.imul(de, ut) | 0;
      var $t = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, T = Math.imul(j, Ct), p = Math.imul(j, lt), p = p + Math.imul(z, Ct) | 0, F = Math.imul(z, lt), T = T + Math.imul(ke, Tt) | 0, p = p + Math.imul(ke, dt) | 0, p = p + Math.imul(Oe, Tt) | 0, F = F + Math.imul(Oe, dt) | 0, T = T + Math.imul(fe, Dt) | 0, p = p + Math.imul(fe, bt) | 0, p = p + Math.imul(re, Dt) | 0, F = F + Math.imul(re, bt) | 0, T = T + Math.imul(H, Bt) | 0, p = p + Math.imul(H, ut) | 0, p = p + Math.imul(he, Bt) | 0, F = F + Math.imul(he, ut) | 0, T = T + Math.imul(_e, Rt) | 0, p = p + Math.imul(_e, gt) | 0, p = p + Math.imul(de, Rt) | 0, F = F + Math.imul(de, gt) | 0;
      var St = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, T = Math.imul(Be, Ct), p = Math.imul(Be, lt), p = p + Math.imul(Te, Ct) | 0, F = Math.imul(Te, lt), T = T + Math.imul(j, Tt) | 0, p = p + Math.imul(j, dt) | 0, p = p + Math.imul(z, Tt) | 0, F = F + Math.imul(z, dt) | 0, T = T + Math.imul(ke, Dt) | 0, p = p + Math.imul(ke, bt) | 0, p = p + Math.imul(Oe, Dt) | 0, F = F + Math.imul(Oe, bt) | 0, T = T + Math.imul(fe, Bt) | 0, p = p + Math.imul(fe, ut) | 0, p = p + Math.imul(re, Bt) | 0, F = F + Math.imul(re, ut) | 0, T = T + Math.imul(H, Rt) | 0, p = p + Math.imul(H, gt) | 0, p = p + Math.imul(he, Rt) | 0, F = F + Math.imul(he, gt) | 0, T = T + Math.imul(_e, kt) | 0, p = p + Math.imul(_e, rt) | 0, p = p + Math.imul(de, kt) | 0, F = F + Math.imul(de, rt) | 0;
      var mt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, T = Math.imul(Ye, Ct), p = Math.imul(Ye, lt), p = p + Math.imul(He, Ct) | 0, F = Math.imul(He, lt), T = T + Math.imul(Be, Tt) | 0, p = p + Math.imul(Be, dt) | 0, p = p + Math.imul(Te, Tt) | 0, F = F + Math.imul(Te, dt) | 0, T = T + Math.imul(j, Dt) | 0, p = p + Math.imul(j, bt) | 0, p = p + Math.imul(z, Dt) | 0, F = F + Math.imul(z, bt) | 0, T = T + Math.imul(ke, Bt) | 0, p = p + Math.imul(ke, ut) | 0, p = p + Math.imul(Oe, Bt) | 0, F = F + Math.imul(Oe, ut) | 0, T = T + Math.imul(fe, Rt) | 0, p = p + Math.imul(fe, gt) | 0, p = p + Math.imul(re, Rt) | 0, F = F + Math.imul(re, gt) | 0, T = T + Math.imul(H, kt) | 0, p = p + Math.imul(H, rt) | 0, p = p + Math.imul(he, kt) | 0, F = F + Math.imul(he, rt) | 0, T = T + Math.imul(_e, J) | 0, p = p + Math.imul(_e, ae) | 0, p = p + Math.imul(de, J) | 0, F = F + Math.imul(de, ae) | 0;
      var xt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, T = Math.imul(at, Ct), p = Math.imul(at, lt), p = p + Math.imul(Qe, Ct) | 0, F = Math.imul(Qe, lt), T = T + Math.imul(Ye, Tt) | 0, p = p + Math.imul(Ye, dt) | 0, p = p + Math.imul(He, Tt) | 0, F = F + Math.imul(He, dt) | 0, T = T + Math.imul(Be, Dt) | 0, p = p + Math.imul(Be, bt) | 0, p = p + Math.imul(Te, Dt) | 0, F = F + Math.imul(Te, bt) | 0, T = T + Math.imul(j, Bt) | 0, p = p + Math.imul(j, ut) | 0, p = p + Math.imul(z, Bt) | 0, F = F + Math.imul(z, ut) | 0, T = T + Math.imul(ke, Rt) | 0, p = p + Math.imul(ke, gt) | 0, p = p + Math.imul(Oe, Rt) | 0, F = F + Math.imul(Oe, gt) | 0, T = T + Math.imul(fe, kt) | 0, p = p + Math.imul(fe, rt) | 0, p = p + Math.imul(re, kt) | 0, F = F + Math.imul(re, rt) | 0, T = T + Math.imul(H, J) | 0, p = p + Math.imul(H, ae) | 0, p = p + Math.imul(he, J) | 0, F = F + Math.imul(he, ae) | 0, T = T + Math.imul(_e, q) | 0, p = p + Math.imul(_e, le) | 0, p = p + Math.imul(de, q) | 0, F = F + Math.imul(de, le) | 0;
      var Et = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, T = Math.imul(It, Ct), p = Math.imul(It, lt), p = p + Math.imul(pt, Ct) | 0, F = Math.imul(pt, lt), T = T + Math.imul(at, Tt) | 0, p = p + Math.imul(at, dt) | 0, p = p + Math.imul(Qe, Tt) | 0, F = F + Math.imul(Qe, dt) | 0, T = T + Math.imul(Ye, Dt) | 0, p = p + Math.imul(Ye, bt) | 0, p = p + Math.imul(He, Dt) | 0, F = F + Math.imul(He, bt) | 0, T = T + Math.imul(Be, Bt) | 0, p = p + Math.imul(Be, ut) | 0, p = p + Math.imul(Te, Bt) | 0, F = F + Math.imul(Te, ut) | 0, T = T + Math.imul(j, Rt) | 0, p = p + Math.imul(j, gt) | 0, p = p + Math.imul(z, Rt) | 0, F = F + Math.imul(z, gt) | 0, T = T + Math.imul(ke, kt) | 0, p = p + Math.imul(ke, rt) | 0, p = p + Math.imul(Oe, kt) | 0, F = F + Math.imul(Oe, rt) | 0, T = T + Math.imul(fe, J) | 0, p = p + Math.imul(fe, ae) | 0, p = p + Math.imul(re, J) | 0, F = F + Math.imul(re, ae) | 0, T = T + Math.imul(H, q) | 0, p = p + Math.imul(H, le) | 0, p = p + Math.imul(he, q) | 0, F = F + Math.imul(he, le) | 0, T = T + Math.imul(_e, Se) | 0, p = p + Math.imul(_e, Ie) | 0, p = p + Math.imul(de, Se) | 0, F = F + Math.imul(de, Ie) | 0;
      var wt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, T = Math.imul(Mt, Ct), p = Math.imul(Mt, lt), p = p + Math.imul(vt, Ct) | 0, F = Math.imul(vt, lt), T = T + Math.imul(It, Tt) | 0, p = p + Math.imul(It, dt) | 0, p = p + Math.imul(pt, Tt) | 0, F = F + Math.imul(pt, dt) | 0, T = T + Math.imul(at, Dt) | 0, p = p + Math.imul(at, bt) | 0, p = p + Math.imul(Qe, Dt) | 0, F = F + Math.imul(Qe, bt) | 0, T = T + Math.imul(Ye, Bt) | 0, p = p + Math.imul(Ye, ut) | 0, p = p + Math.imul(He, Bt) | 0, F = F + Math.imul(He, ut) | 0, T = T + Math.imul(Be, Rt) | 0, p = p + Math.imul(Be, gt) | 0, p = p + Math.imul(Te, Rt) | 0, F = F + Math.imul(Te, gt) | 0, T = T + Math.imul(j, kt) | 0, p = p + Math.imul(j, rt) | 0, p = p + Math.imul(z, kt) | 0, F = F + Math.imul(z, rt) | 0, T = T + Math.imul(ke, J) | 0, p = p + Math.imul(ke, ae) | 0, p = p + Math.imul(Oe, J) | 0, F = F + Math.imul(Oe, ae) | 0, T = T + Math.imul(fe, q) | 0, p = p + Math.imul(fe, le) | 0, p = p + Math.imul(re, q) | 0, F = F + Math.imul(re, le) | 0, T = T + Math.imul(H, Se) | 0, p = p + Math.imul(H, Ie) | 0, p = p + Math.imul(he, Se) | 0, F = F + Math.imul(he, Ie) | 0, T = T + Math.imul(_e, Ge) | 0, p = p + Math.imul(_e, qe) | 0, p = p + Math.imul(de, Ge) | 0, F = F + Math.imul(de, qe) | 0;
      var tt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, T = Math.imul(Mt, Tt), p = Math.imul(Mt, dt), p = p + Math.imul(vt, Tt) | 0, F = Math.imul(vt, dt), T = T + Math.imul(It, Dt) | 0, p = p + Math.imul(It, bt) | 0, p = p + Math.imul(pt, Dt) | 0, F = F + Math.imul(pt, bt) | 0, T = T + Math.imul(at, Bt) | 0, p = p + Math.imul(at, ut) | 0, p = p + Math.imul(Qe, Bt) | 0, F = F + Math.imul(Qe, ut) | 0, T = T + Math.imul(Ye, Rt) | 0, p = p + Math.imul(Ye, gt) | 0, p = p + Math.imul(He, Rt) | 0, F = F + Math.imul(He, gt) | 0, T = T + Math.imul(Be, kt) | 0, p = p + Math.imul(Be, rt) | 0, p = p + Math.imul(Te, kt) | 0, F = F + Math.imul(Te, rt) | 0, T = T + Math.imul(j, J) | 0, p = p + Math.imul(j, ae) | 0, p = p + Math.imul(z, J) | 0, F = F + Math.imul(z, ae) | 0, T = T + Math.imul(ke, q) | 0, p = p + Math.imul(ke, le) | 0, p = p + Math.imul(Oe, q) | 0, F = F + Math.imul(Oe, le) | 0, T = T + Math.imul(fe, Se) | 0, p = p + Math.imul(fe, Ie) | 0, p = p + Math.imul(re, Se) | 0, F = F + Math.imul(re, Ie) | 0, T = T + Math.imul(H, Ge) | 0, p = p + Math.imul(H, qe) | 0, p = p + Math.imul(he, Ge) | 0, F = F + Math.imul(he, qe) | 0;
      var ht = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, T = Math.imul(Mt, Dt), p = Math.imul(Mt, bt), p = p + Math.imul(vt, Dt) | 0, F = Math.imul(vt, bt), T = T + Math.imul(It, Bt) | 0, p = p + Math.imul(It, ut) | 0, p = p + Math.imul(pt, Bt) | 0, F = F + Math.imul(pt, ut) | 0, T = T + Math.imul(at, Rt) | 0, p = p + Math.imul(at, gt) | 0, p = p + Math.imul(Qe, Rt) | 0, F = F + Math.imul(Qe, gt) | 0, T = T + Math.imul(Ye, kt) | 0, p = p + Math.imul(Ye, rt) | 0, p = p + Math.imul(He, kt) | 0, F = F + Math.imul(He, rt) | 0, T = T + Math.imul(Be, J) | 0, p = p + Math.imul(Be, ae) | 0, p = p + Math.imul(Te, J) | 0, F = F + Math.imul(Te, ae) | 0, T = T + Math.imul(j, q) | 0, p = p + Math.imul(j, le) | 0, p = p + Math.imul(z, q) | 0, F = F + Math.imul(z, le) | 0, T = T + Math.imul(ke, Se) | 0, p = p + Math.imul(ke, Ie) | 0, p = p + Math.imul(Oe, Se) | 0, F = F + Math.imul(Oe, Ie) | 0, T = T + Math.imul(fe, Ge) | 0, p = p + Math.imul(fe, qe) | 0, p = p + Math.imul(re, Ge) | 0, F = F + Math.imul(re, qe) | 0;
      var Je = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, T = Math.imul(Mt, Bt), p = Math.imul(Mt, ut), p = p + Math.imul(vt, Bt) | 0, F = Math.imul(vt, ut), T = T + Math.imul(It, Rt) | 0, p = p + Math.imul(It, gt) | 0, p = p + Math.imul(pt, Rt) | 0, F = F + Math.imul(pt, gt) | 0, T = T + Math.imul(at, kt) | 0, p = p + Math.imul(at, rt) | 0, p = p + Math.imul(Qe, kt) | 0, F = F + Math.imul(Qe, rt) | 0, T = T + Math.imul(Ye, J) | 0, p = p + Math.imul(Ye, ae) | 0, p = p + Math.imul(He, J) | 0, F = F + Math.imul(He, ae) | 0, T = T + Math.imul(Be, q) | 0, p = p + Math.imul(Be, le) | 0, p = p + Math.imul(Te, q) | 0, F = F + Math.imul(Te, le) | 0, T = T + Math.imul(j, Se) | 0, p = p + Math.imul(j, Ie) | 0, p = p + Math.imul(z, Se) | 0, F = F + Math.imul(z, Ie) | 0, T = T + Math.imul(ke, Ge) | 0, p = p + Math.imul(ke, qe) | 0, p = p + Math.imul(Oe, Ge) | 0, F = F + Math.imul(Oe, qe) | 0;
      var it = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, T = Math.imul(Mt, Rt), p = Math.imul(Mt, gt), p = p + Math.imul(vt, Rt) | 0, F = Math.imul(vt, gt), T = T + Math.imul(It, kt) | 0, p = p + Math.imul(It, rt) | 0, p = p + Math.imul(pt, kt) | 0, F = F + Math.imul(pt, rt) | 0, T = T + Math.imul(at, J) | 0, p = p + Math.imul(at, ae) | 0, p = p + Math.imul(Qe, J) | 0, F = F + Math.imul(Qe, ae) | 0, T = T + Math.imul(Ye, q) | 0, p = p + Math.imul(Ye, le) | 0, p = p + Math.imul(He, q) | 0, F = F + Math.imul(He, le) | 0, T = T + Math.imul(Be, Se) | 0, p = p + Math.imul(Be, Ie) | 0, p = p + Math.imul(Te, Se) | 0, F = F + Math.imul(Te, Ie) | 0, T = T + Math.imul(j, Ge) | 0, p = p + Math.imul(j, qe) | 0, p = p + Math.imul(z, Ge) | 0, F = F + Math.imul(z, qe) | 0;
      var nt = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, T = Math.imul(Mt, kt), p = Math.imul(Mt, rt), p = p + Math.imul(vt, kt) | 0, F = Math.imul(vt, rt), T = T + Math.imul(It, J) | 0, p = p + Math.imul(It, ae) | 0, p = p + Math.imul(pt, J) | 0, F = F + Math.imul(pt, ae) | 0, T = T + Math.imul(at, q) | 0, p = p + Math.imul(at, le) | 0, p = p + Math.imul(Qe, q) | 0, F = F + Math.imul(Qe, le) | 0, T = T + Math.imul(Ye, Se) | 0, p = p + Math.imul(Ye, Ie) | 0, p = p + Math.imul(He, Se) | 0, F = F + Math.imul(He, Ie) | 0, T = T + Math.imul(Be, Ge) | 0, p = p + Math.imul(Be, qe) | 0, p = p + Math.imul(Te, Ge) | 0, F = F + Math.imul(Te, qe) | 0;
      var Ze = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, T = Math.imul(Mt, J), p = Math.imul(Mt, ae), p = p + Math.imul(vt, J) | 0, F = Math.imul(vt, ae), T = T + Math.imul(It, q) | 0, p = p + Math.imul(It, le) | 0, p = p + Math.imul(pt, q) | 0, F = F + Math.imul(pt, le) | 0, T = T + Math.imul(at, Se) | 0, p = p + Math.imul(at, Ie) | 0, p = p + Math.imul(Qe, Se) | 0, F = F + Math.imul(Qe, Ie) | 0, T = T + Math.imul(Ye, Ge) | 0, p = p + Math.imul(Ye, qe) | 0, p = p + Math.imul(He, Ge) | 0, F = F + Math.imul(He, qe) | 0;
      var Me = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, T = Math.imul(Mt, q), p = Math.imul(Mt, le), p = p + Math.imul(vt, q) | 0, F = Math.imul(vt, le), T = T + Math.imul(It, Se) | 0, p = p + Math.imul(It, Ie) | 0, p = p + Math.imul(pt, Se) | 0, F = F + Math.imul(pt, Ie) | 0, T = T + Math.imul(at, Ge) | 0, p = p + Math.imul(at, qe) | 0, p = p + Math.imul(Qe, Ge) | 0, F = F + Math.imul(Qe, qe) | 0;
      var De = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, T = Math.imul(Mt, Se), p = Math.imul(Mt, Ie), p = p + Math.imul(vt, Se) | 0, F = Math.imul(vt, Ie), T = T + Math.imul(It, Ge) | 0, p = p + Math.imul(It, qe) | 0, p = p + Math.imul(pt, Ge) | 0, F = F + Math.imul(pt, qe) | 0;
      var ze = (w + T | 0) + ((p & 8191) << 13) | 0;
      w = (F + (p >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, T = Math.imul(Mt, Ge), p = Math.imul(Mt, qe), p = p + Math.imul(vt, Ge) | 0, F = Math.imul(vt, qe);
      var Ue = (w + T | 0) + ((p & 8191) << 13) | 0;
      return w = (F + (p >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, k[0] = Nt, k[1] = et, k[2] = _t, k[3] = $t, k[4] = St, k[5] = mt, k[6] = xt, k[7] = Et, k[8] = wt, k[9] = tt, k[10] = ht, k[11] = Je, k[12] = it, k[13] = nt, k[14] = Ze, k[15] = Me, k[16] = De, k[17] = ze, k[18] = Ue, w !== 0 && (k[19] = w, C.length++), C;
    };
    Math.imul || (ne = ee);
    function ge(E, c, b) {
      b.negative = c.negative ^ E.negative, b.length = E.length + c.length;
      for (var C = 0, x = 0, B = 0; B < b.length - 1; B++) {
        var k = x;
        x = 0;
        for (var w = C & 67108863, T = Math.min(B, c.length - 1), p = Math.max(0, B - E.length + 1); p <= T; p++) {
          var F = B - p, ye = E.words[F] | 0, _e = c.words[p] | 0, de = ye * _e, P = de & 67108863;
          k = k + (de / 67108864 | 0) | 0, P = P + w | 0, w = P & 67108863, k = k + (P >>> 26) | 0, x += k >>> 26, k &= 67108863;
        }
        b.words[B] = w, C = k, k = x;
      }
      return C !== 0 ? b.words[B] = C : b.length--, b._strip();
    }
    function be(E, c, b) {
      return ge(E, c, b);
    }
    o.prototype.mulTo = function(c, b) {
      var C, x = this.length + c.length;
      return this.length === 10 && c.length === 10 ? C = ne(this, c, b) : x < 63 ? C = ee(this, c, b) : x < 1024 ? C = ge(this, c, b) : C = be(this, c, b), C;
    }, o.prototype.mul = function(c) {
      var b = new o(null);
      return b.words = new Array(this.length + c.length), this.mulTo(c, b);
    }, o.prototype.mulf = function(c) {
      var b = new o(null);
      return b.words = new Array(this.length + c.length), be(this, c, b);
    }, o.prototype.imul = function(c) {
      return this.clone().mulTo(c, this);
    }, o.prototype.imuln = function(c) {
      var b = c < 0;
      b && (c = -c), n(typeof c == "number"), n(c < 67108864);
      for (var C = 0, x = 0; x < this.length; x++) {
        var B = (this.words[x] | 0) * c, k = (B & 67108863) + (C & 67108863);
        C >>= 26, C += B / 67108864 | 0, C += k >>> 26, this.words[x] = k & 67108863;
      }
      return C !== 0 && (this.words[x] = C, this.length++), this.length = c === 0 ? 1 : this.length, b ? this.ineg() : this;
    }, o.prototype.muln = function(c) {
      return this.clone().imuln(c);
    }, o.prototype.sqr = function() {
      return this.mul(this);
    }, o.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o.prototype.pow = function(c) {
      var b = ie(c);
      if (b.length === 0)
        return new o(1);
      for (var C = this, x = 0; x < b.length && b[x] === 0; x++, C = C.sqr())
        ;
      if (++x < b.length)
        for (var B = C.sqr(); x < b.length; x++, B = B.sqr())
          b[x] !== 0 && (C = C.mul(B));
      return C;
    }, o.prototype.iushln = function(c) {
      n(typeof c == "number" && c >= 0);
      var b = c % 26, C = (c - b) / 26, x = 67108863 >>> 26 - b << 26 - b, B;
      if (b !== 0) {
        var k = 0;
        for (B = 0; B < this.length; B++) {
          var w = this.words[B] & x, T = (this.words[B] | 0) - w << b;
          this.words[B] = T | k, k = w >>> 26 - b;
        }
        k && (this.words[B] = k, this.length++);
      }
      if (C !== 0) {
        for (B = this.length - 1; B >= 0; B--)
          this.words[B + C] = this.words[B];
        for (B = 0; B < C; B++)
          this.words[B] = 0;
        this.length += C;
      }
      return this._strip();
    }, o.prototype.ishln = function(c) {
      return n(this.negative === 0), this.iushln(c);
    }, o.prototype.iushrn = function(c, b, C) {
      n(typeof c == "number" && c >= 0);
      var x;
      b ? x = (b - b % 26) / 26 : x = 0;
      var B = c % 26, k = Math.min((c - B) / 26, this.length), w = 67108863 ^ 67108863 >>> B << B, T = C;
      if (x -= k, x = Math.max(0, x), T) {
        for (var p = 0; p < k; p++)
          T.words[p] = this.words[p];
        T.length = k;
      }
      if (k !== 0)
        if (this.length > k)
          for (this.length -= k, p = 0; p < this.length; p++)
            this.words[p] = this.words[p + k];
        else
          this.words[0] = 0, this.length = 1;
      var F = 0;
      for (p = this.length - 1; p >= 0 && (F !== 0 || p >= x); p--) {
        var ye = this.words[p] | 0;
        this.words[p] = F << 26 - B | ye >>> B, F = ye & w;
      }
      return T && F !== 0 && (T.words[T.length++] = F), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, o.prototype.ishrn = function(c, b, C) {
      return n(this.negative === 0), this.iushrn(c, b, C);
    }, o.prototype.shln = function(c) {
      return this.clone().ishln(c);
    }, o.prototype.ushln = function(c) {
      return this.clone().iushln(c);
    }, o.prototype.shrn = function(c) {
      return this.clone().ishrn(c);
    }, o.prototype.ushrn = function(c) {
      return this.clone().iushrn(c);
    }, o.prototype.testn = function(c) {
      n(typeof c == "number" && c >= 0);
      var b = c % 26, C = (c - b) / 26, x = 1 << b;
      if (this.length <= C)
        return !1;
      var B = this.words[C];
      return !!(B & x);
    }, o.prototype.imaskn = function(c) {
      n(typeof c == "number" && c >= 0);
      var b = c % 26, C = (c - b) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= C)
        return this;
      if (b !== 0 && C++, this.length = Math.min(C, this.length), b !== 0) {
        var x = 67108863 ^ 67108863 >>> b << b;
        this.words[this.length - 1] &= x;
      }
      return this._strip();
    }, o.prototype.maskn = function(c) {
      return this.clone().imaskn(c);
    }, o.prototype.iaddn = function(c) {
      return n(typeof c == "number"), n(c < 67108864), c < 0 ? this.isubn(-c) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= c ? (this.words[0] = c - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(c), this.negative = 1, this) : this._iaddn(c);
    }, o.prototype._iaddn = function(c) {
      this.words[0] += c;
      for (var b = 0; b < this.length && this.words[b] >= 67108864; b++)
        this.words[b] -= 67108864, b === this.length - 1 ? this.words[b + 1] = 1 : this.words[b + 1]++;
      return this.length = Math.max(this.length, b + 1), this;
    }, o.prototype.isubn = function(c) {
      if (n(typeof c == "number"), n(c < 67108864), c < 0)
        return this.iaddn(-c);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(c), this.negative = 1, this;
      if (this.words[0] -= c, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var b = 0; b < this.length && this.words[b] < 0; b++)
          this.words[b] += 67108864, this.words[b + 1] -= 1;
      return this._strip();
    }, o.prototype.addn = function(c) {
      return this.clone().iaddn(c);
    }, o.prototype.subn = function(c) {
      return this.clone().isubn(c);
    }, o.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o.prototype.abs = function() {
      return this.clone().iabs();
    }, o.prototype._ishlnsubmul = function(c, b, C) {
      var x = c.length + C, B;
      this._expand(x);
      var k, w = 0;
      for (B = 0; B < c.length; B++) {
        k = (this.words[B + C] | 0) + w;
        var T = (c.words[B] | 0) * b;
        k -= T & 67108863, w = (k >> 26) - (T / 67108864 | 0), this.words[B + C] = k & 67108863;
      }
      for (; B < this.length - C; B++)
        k = (this.words[B + C] | 0) + w, w = k >> 26, this.words[B + C] = k & 67108863;
      if (w === 0)
        return this._strip();
      for (n(w === -1), w = 0, B = 0; B < this.length; B++)
        k = -(this.words[B] | 0) + w, w = k >> 26, this.words[B] = k & 67108863;
      return this.negative = 1, this._strip();
    }, o.prototype._wordDiv = function(c, b) {
      var C = this.length - c.length, x = this.clone(), B = c, k = B.words[B.length - 1] | 0, w = this._countBits(k);
      C = 26 - w, C !== 0 && (B = B.ushln(C), x.iushln(C), k = B.words[B.length - 1] | 0);
      var T = x.length - B.length, p;
      if (b !== "mod") {
        p = new o(null), p.length = T + 1, p.words = new Array(p.length);
        for (var F = 0; F < p.length; F++)
          p.words[F] = 0;
      }
      var ye = x.clone()._ishlnsubmul(B, 1, T);
      ye.negative === 0 && (x = ye, p && (p.words[T] = 1));
      for (var _e = T - 1; _e >= 0; _e--) {
        var de = (x.words[B.length + _e] | 0) * 67108864 + (x.words[B.length + _e - 1] | 0);
        for (de = Math.min(de / k | 0, 67108863), x._ishlnsubmul(B, de, _e); x.negative !== 0; )
          de--, x.negative = 0, x._ishlnsubmul(B, 1, _e), x.isZero() || (x.negative ^= 1);
        p && (p.words[_e] = de);
      }
      return p && p._strip(), x._strip(), b !== "div" && C !== 0 && x.iushrn(C), {
        div: p || null,
        mod: x
      };
    }, o.prototype.divmod = function(c, b, C) {
      if (n(!c.isZero()), this.isZero())
        return {
          div: new o(0),
          mod: new o(0)
        };
      var x, B, k;
      return this.negative !== 0 && c.negative === 0 ? (k = this.neg().divmod(c, b), b !== "mod" && (x = k.div.neg()), b !== "div" && (B = k.mod.neg(), C && B.negative !== 0 && B.iadd(c)), {
        div: x,
        mod: B
      }) : this.negative === 0 && c.negative !== 0 ? (k = this.divmod(c.neg(), b), b !== "mod" && (x = k.div.neg()), {
        div: x,
        mod: k.mod
      }) : this.negative & c.negative ? (k = this.neg().divmod(c.neg(), b), b !== "div" && (B = k.mod.neg(), C && B.negative !== 0 && B.isub(c)), {
        div: k.div,
        mod: B
      }) : c.length > this.length || this.cmp(c) < 0 ? {
        div: new o(0),
        mod: this
      } : c.length === 1 ? b === "div" ? {
        div: this.divn(c.words[0]),
        mod: null
      } : b === "mod" ? {
        div: null,
        mod: new o(this.modrn(c.words[0]))
      } : {
        div: this.divn(c.words[0]),
        mod: new o(this.modrn(c.words[0]))
      } : this._wordDiv(c, b);
    }, o.prototype.div = function(c) {
      return this.divmod(c, "div", !1).div;
    }, o.prototype.mod = function(c) {
      return this.divmod(c, "mod", !1).mod;
    }, o.prototype.umod = function(c) {
      return this.divmod(c, "mod", !0).mod;
    }, o.prototype.divRound = function(c) {
      var b = this.divmod(c);
      if (b.mod.isZero())
        return b.div;
      var C = b.div.negative !== 0 ? b.mod.isub(c) : b.mod, x = c.ushrn(1), B = c.andln(1), k = C.cmp(x);
      return k < 0 || B === 1 && k === 0 ? b.div : b.div.negative !== 0 ? b.div.isubn(1) : b.div.iaddn(1);
    }, o.prototype.modrn = function(c) {
      var b = c < 0;
      b && (c = -c), n(c <= 67108863);
      for (var C = (1 << 26) % c, x = 0, B = this.length - 1; B >= 0; B--)
        x = (C * x + (this.words[B] | 0)) % c;
      return b ? -x : x;
    }, o.prototype.modn = function(c) {
      return this.modrn(c);
    }, o.prototype.idivn = function(c) {
      var b = c < 0;
      b && (c = -c), n(c <= 67108863);
      for (var C = 0, x = this.length - 1; x >= 0; x--) {
        var B = (this.words[x] | 0) + C * 67108864;
        this.words[x] = B / c | 0, C = B % c;
      }
      return this._strip(), b ? this.ineg() : this;
    }, o.prototype.divn = function(c) {
      return this.clone().idivn(c);
    }, o.prototype.egcd = function(c) {
      n(c.negative === 0), n(!c.isZero());
      var b = this, C = c.clone();
      b.negative !== 0 ? b = b.umod(c) : b = b.clone();
      for (var x = new o(1), B = new o(0), k = new o(0), w = new o(1), T = 0; b.isEven() && C.isEven(); )
        b.iushrn(1), C.iushrn(1), ++T;
      for (var p = C.clone(), F = b.clone(); !b.isZero(); ) {
        for (var ye = 0, _e = 1; !(b.words[0] & _e) && ye < 26; ++ye, _e <<= 1)
          ;
        if (ye > 0)
          for (b.iushrn(ye); ye-- > 0; )
            (x.isOdd() || B.isOdd()) && (x.iadd(p), B.isub(F)), x.iushrn(1), B.iushrn(1);
        for (var de = 0, P = 1; !(C.words[0] & P) && de < 26; ++de, P <<= 1)
          ;
        if (de > 0)
          for (C.iushrn(de); de-- > 0; )
            (k.isOdd() || w.isOdd()) && (k.iadd(p), w.isub(F)), k.iushrn(1), w.iushrn(1);
        b.cmp(C) >= 0 ? (b.isub(C), x.isub(k), B.isub(w)) : (C.isub(b), k.isub(x), w.isub(B));
      }
      return {
        a: k,
        b: w,
        gcd: C.iushln(T)
      };
    }, o.prototype._invmp = function(c) {
      n(c.negative === 0), n(!c.isZero());
      var b = this, C = c.clone();
      b.negative !== 0 ? b = b.umod(c) : b = b.clone();
      for (var x = new o(1), B = new o(0), k = C.clone(); b.cmpn(1) > 0 && C.cmpn(1) > 0; ) {
        for (var w = 0, T = 1; !(b.words[0] & T) && w < 26; ++w, T <<= 1)
          ;
        if (w > 0)
          for (b.iushrn(w); w-- > 0; )
            x.isOdd() && x.iadd(k), x.iushrn(1);
        for (var p = 0, F = 1; !(C.words[0] & F) && p < 26; ++p, F <<= 1)
          ;
        if (p > 0)
          for (C.iushrn(p); p-- > 0; )
            B.isOdd() && B.iadd(k), B.iushrn(1);
        b.cmp(C) >= 0 ? (b.isub(C), x.isub(B)) : (C.isub(b), B.isub(x));
      }
      var ye;
      return b.cmpn(1) === 0 ? ye = x : ye = B, ye.cmpn(0) < 0 && ye.iadd(c), ye;
    }, o.prototype.gcd = function(c) {
      if (this.isZero())
        return c.abs();
      if (c.isZero())
        return this.abs();
      var b = this.clone(), C = c.clone();
      b.negative = 0, C.negative = 0;
      for (var x = 0; b.isEven() && C.isEven(); x++)
        b.iushrn(1), C.iushrn(1);
      do {
        for (; b.isEven(); )
          b.iushrn(1);
        for (; C.isEven(); )
          C.iushrn(1);
        var B = b.cmp(C);
        if (B < 0) {
          var k = b;
          b = C, C = k;
        } else if (B === 0 || C.cmpn(1) === 0)
          break;
        b.isub(C);
      } while (!0);
      return C.iushln(x);
    }, o.prototype.invm = function(c) {
      return this.egcd(c).a.umod(c);
    }, o.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o.prototype.andln = function(c) {
      return this.words[0] & c;
    }, o.prototype.bincn = function(c) {
      n(typeof c == "number");
      var b = c % 26, C = (c - b) / 26, x = 1 << b;
      if (this.length <= C)
        return this._expand(C + 1), this.words[C] |= x, this;
      for (var B = x, k = C; B !== 0 && k < this.length; k++) {
        var w = this.words[k] | 0;
        w += B, B = w >>> 26, w &= 67108863, this.words[k] = w;
      }
      return B !== 0 && (this.words[k] = B, this.length++), this;
    }, o.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o.prototype.cmpn = function(c) {
      var b = c < 0;
      if (this.negative !== 0 && !b)
        return -1;
      if (this.negative === 0 && b)
        return 1;
      this._strip();
      var C;
      if (this.length > 1)
        C = 1;
      else {
        b && (c = -c), n(c <= 67108863, "Number is too big");
        var x = this.words[0] | 0;
        C = x === c ? 0 : x < c ? -1 : 1;
      }
      return this.negative !== 0 ? -C | 0 : C;
    }, o.prototype.cmp = function(c) {
      if (this.negative !== 0 && c.negative === 0)
        return -1;
      if (this.negative === 0 && c.negative !== 0)
        return 1;
      var b = this.ucmp(c);
      return this.negative !== 0 ? -b | 0 : b;
    }, o.prototype.ucmp = function(c) {
      if (this.length > c.length)
        return 1;
      if (this.length < c.length)
        return -1;
      for (var b = 0, C = this.length - 1; C >= 0; C--) {
        var x = this.words[C] | 0, B = c.words[C] | 0;
        if (x !== B) {
          x < B ? b = -1 : x > B && (b = 1);
          break;
        }
      }
      return b;
    }, o.prototype.gtn = function(c) {
      return this.cmpn(c) === 1;
    }, o.prototype.gt = function(c) {
      return this.cmp(c) === 1;
    }, o.prototype.gten = function(c) {
      return this.cmpn(c) >= 0;
    }, o.prototype.gte = function(c) {
      return this.cmp(c) >= 0;
    }, o.prototype.ltn = function(c) {
      return this.cmpn(c) === -1;
    }, o.prototype.lt = function(c) {
      return this.cmp(c) === -1;
    }, o.prototype.lten = function(c) {
      return this.cmpn(c) <= 0;
    }, o.prototype.lte = function(c) {
      return this.cmp(c) <= 0;
    }, o.prototype.eqn = function(c) {
      return this.cmpn(c) === 0;
    }, o.prototype.eq = function(c) {
      return this.cmp(c) === 0;
    }, o.red = function(c) {
      return new pe(c);
    }, o.prototype.toRed = function(c) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), c.convertTo(this)._forceRed(c);
    }, o.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o.prototype._forceRed = function(c) {
      return this.red = c, this;
    }, o.prototype.forceRed = function(c) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(c);
    }, o.prototype.redAdd = function(c) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, c);
    }, o.prototype.redIAdd = function(c) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, c);
    }, o.prototype.redSub = function(c) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, c);
    }, o.prototype.redISub = function(c) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, c);
    }, o.prototype.redShl = function(c) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, c);
    }, o.prototype.redMul = function(c) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.mul(this, c);
    }, o.prototype.redIMul = function(c) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.imul(this, c);
    }, o.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o.prototype.redPow = function(c) {
      return n(this.red && !c.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, c);
    };
    var Ee = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function xe(E, c) {
      this.name = E, this.p = new o(c, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    xe.prototype._tmp = function() {
      var c = new o(null);
      return c.words = new Array(Math.ceil(this.n / 13)), c;
    }, xe.prototype.ireduce = function(c) {
      var b = c, C;
      do
        this.split(b, this.tmp), b = this.imulK(b), b = b.iadd(this.tmp), C = b.bitLength();
      while (C > this.n);
      var x = C < this.n ? -1 : b.ucmp(this.p);
      return x === 0 ? (b.words[0] = 0, b.length = 1) : x > 0 ? b.isub(this.p) : b.strip !== void 0 ? b.strip() : b._strip(), b;
    }, xe.prototype.split = function(c, b) {
      c.iushrn(this.n, 0, b);
    }, xe.prototype.imulK = function(c) {
      return c.imul(this.k);
    };
    function Le() {
      xe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    u(Le, xe), Le.prototype.split = function(c, b) {
      for (var C = 4194303, x = Math.min(c.length, 9), B = 0; B < x; B++)
        b.words[B] = c.words[B];
      if (b.length = x, c.length <= 9) {
        c.words[0] = 0, c.length = 1;
        return;
      }
      var k = c.words[9];
      for (b.words[b.length++] = k & C, B = 10; B < c.length; B++) {
        var w = c.words[B] | 0;
        c.words[B - 10] = (w & C) << 4 | k >>> 22, k = w;
      }
      k >>>= 22, c.words[B - 10] = k, k === 0 && c.length > 10 ? c.length -= 10 : c.length -= 9;
    }, Le.prototype.imulK = function(c) {
      c.words[c.length] = 0, c.words[c.length + 1] = 0, c.length += 2;
      for (var b = 0, C = 0; C < c.length; C++) {
        var x = c.words[C] | 0;
        b += x * 977, c.words[C] = b & 67108863, b = x * 64 + (b / 67108864 | 0);
      }
      return c.words[c.length - 1] === 0 && (c.length--, c.words[c.length - 1] === 0 && c.length--), c;
    };
    function Ne() {
      xe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    u(Ne, xe);
    function Re() {
      xe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    u(Re, xe);
    function Xe() {
      xe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    u(Xe, xe), Xe.prototype.imulK = function(c) {
      for (var b = 0, C = 0; C < c.length; C++) {
        var x = (c.words[C] | 0) * 19 + b, B = x & 67108863;
        x >>>= 26, c.words[C] = B, b = x;
      }
      return b !== 0 && (c.words[c.length++] = b), c;
    }, o._prime = function(c) {
      if (Ee[c])
        return Ee[c];
      var b;
      if (c === "k256")
        b = new Le();
      else if (c === "p224")
        b = new Ne();
      else if (c === "p192")
        b = new Re();
      else if (c === "p25519")
        b = new Xe();
      else
        throw new Error("Unknown prime " + c);
      return Ee[c] = b, b;
    };
    function pe(E) {
      if (typeof E == "string") {
        var c = o._prime(E);
        this.m = c.p, this.prime = c;
      } else
        n(E.gtn(1), "modulus must be greater than 1"), this.m = E, this.prime = null;
    }
    pe.prototype._verify1 = function(c) {
      n(c.negative === 0, "red works only with positives"), n(c.red, "red works only with red numbers");
    }, pe.prototype._verify2 = function(c, b) {
      n((c.negative | b.negative) === 0, "red works only with positives"), n(
        c.red && c.red === b.red,
        "red works only with red numbers"
      );
    }, pe.prototype.imod = function(c) {
      return this.prime ? this.prime.ireduce(c)._forceRed(this) : (d(c, c.umod(this.m)._forceRed(this)), c);
    }, pe.prototype.neg = function(c) {
      return c.isZero() ? c.clone() : this.m.sub(c)._forceRed(this);
    }, pe.prototype.add = function(c, b) {
      this._verify2(c, b);
      var C = c.add(b);
      return C.cmp(this.m) >= 0 && C.isub(this.m), C._forceRed(this);
    }, pe.prototype.iadd = function(c, b) {
      this._verify2(c, b);
      var C = c.iadd(b);
      return C.cmp(this.m) >= 0 && C.isub(this.m), C;
    }, pe.prototype.sub = function(c, b) {
      this._verify2(c, b);
      var C = c.sub(b);
      return C.cmpn(0) < 0 && C.iadd(this.m), C._forceRed(this);
    }, pe.prototype.isub = function(c, b) {
      this._verify2(c, b);
      var C = c.isub(b);
      return C.cmpn(0) < 0 && C.iadd(this.m), C;
    }, pe.prototype.shl = function(c, b) {
      return this._verify1(c), this.imod(c.ushln(b));
    }, pe.prototype.imul = function(c, b) {
      return this._verify2(c, b), this.imod(c.imul(b));
    }, pe.prototype.mul = function(c, b) {
      return this._verify2(c, b), this.imod(c.mul(b));
    }, pe.prototype.isqr = function(c) {
      return this.imul(c, c.clone());
    }, pe.prototype.sqr = function(c) {
      return this.mul(c, c);
    }, pe.prototype.sqrt = function(c) {
      if (c.isZero())
        return c.clone();
      var b = this.m.andln(3);
      if (n(b % 2 === 1), b === 3) {
        var C = this.m.add(new o(1)).iushrn(2);
        return this.pow(c, C);
      }
      for (var x = this.m.subn(1), B = 0; !x.isZero() && x.andln(1) === 0; )
        B++, x.iushrn(1);
      n(!x.isZero());
      var k = new o(1).toRed(this), w = k.redNeg(), T = this.m.subn(1).iushrn(1), p = this.m.bitLength();
      for (p = new o(2 * p * p).toRed(this); this.pow(p, T).cmp(w) !== 0; )
        p.redIAdd(w);
      for (var F = this.pow(p, x), ye = this.pow(c, x.addn(1).iushrn(1)), _e = this.pow(c, x), de = B; _e.cmp(k) !== 0; ) {
        for (var P = _e, H = 0; P.cmp(k) !== 0; H++)
          P = P.redSqr();
        n(H < de);
        var he = this.pow(F, new o(1).iushln(de - H - 1));
        ye = ye.redMul(he), F = he.redSqr(), _e = _e.redMul(F), de = H;
      }
      return ye;
    }, pe.prototype.invm = function(c) {
      var b = c._invmp(this.m);
      return b.negative !== 0 ? (b.negative = 0, this.imod(b).redNeg()) : this.imod(b);
    }, pe.prototype.pow = function(c, b) {
      if (b.isZero())
        return new o(1).toRed(this);
      if (b.cmpn(1) === 0)
        return c.clone();
      var C = 4, x = new Array(1 << C);
      x[0] = new o(1).toRed(this), x[1] = c;
      for (var B = 2; B < x.length; B++)
        x[B] = this.mul(x[B - 1], c);
      var k = x[0], w = 0, T = 0, p = b.bitLength() % 26;
      for (p === 0 && (p = 26), B = b.length - 1; B >= 0; B--) {
        for (var F = b.words[B], ye = p - 1; ye >= 0; ye--) {
          var _e = F >> ye & 1;
          if (k !== x[0] && (k = this.sqr(k)), _e === 0 && w === 0) {
            T = 0;
            continue;
          }
          w <<= 1, w |= _e, T++, !(T !== C && (B !== 0 || ye !== 0)) && (k = this.mul(k, x[w]), T = 0, w = 0);
        }
        p = 26;
      }
      return k;
    }, pe.prototype.convertTo = function(c) {
      var b = c.umod(this.m);
      return b === c ? b.clone() : b;
    }, pe.prototype.convertFrom = function(c) {
      var b = c.clone();
      return b.red = null, b;
    }, o.mont = function(c) {
      return new O(c);
    };
    function O(E) {
      pe.call(this, E), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    u(O, pe), O.prototype.convertTo = function(c) {
      return this.imod(c.ushln(this.shift));
    }, O.prototype.convertFrom = function(c) {
      var b = this.imod(c.mul(this.rinv));
      return b.red = null, b;
    }, O.prototype.imul = function(c, b) {
      if (c.isZero() || b.isZero())
        return c.words[0] = 0, c.length = 1, c;
      var C = c.imul(b), x = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = C.isub(x).iushrn(this.shift), k = B;
      return B.cmp(this.m) >= 0 ? k = B.isub(this.m) : B.cmpn(0) < 0 && (k = B.iadd(this.m)), k._forceRed(this);
    }, O.prototype.mul = function(c, b) {
      if (c.isZero() || b.isZero())
        return new o(0)._forceRed(this);
      var C = c.mul(b), x = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = C.isub(x).iushrn(this.shift), k = B;
      return B.cmp(this.m) >= 0 ? k = B.isub(this.m) : B.cmpn(0) < 0 && (k = B.iadd(this.m)), k._forceRed(this);
    }, O.prototype.invm = function(c) {
      var b = this.imod(c._invmp(this.m).mul(this.r2));
      return b._forceRed(this);
    };
  })(e, commonjsGlobal);
})(bn);
var bnExports = bn.exports, asn1$c = {}, asn1$b = {}, api$1 = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(e, t) {
      if (e.indexOf)
        return e.indexOf(t);
      for (var a = 0; a < e.length; a++)
        if (e[a] === t)
          return a;
      return -1;
    }, Object_keys = function(e) {
      if (Object.keys)
        return Object.keys(e);
      var t = [];
      for (var a in e)
        t.push(a);
      return t;
    }, forEach = function(e, t) {
      if (e.forEach)
        return e.forEach(t);
      for (var a = 0; a < e.length; a++)
        t(e[a], a, e);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(e, t, a) {
          Object.defineProperty(e, t, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: a
          });
        };
      } catch {
        return function(t, a, n) {
          t[a] = n;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(t) {
      if (!(this instanceof Script))
        return new Script(t);
      this.code = t;
    };
    Script.prototype.runInContext = function(e) {
      if (!(e instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var t = document.createElement("iframe");
      t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t);
      var a = t.contentWindow, n = a.eval, u = a.execScript;
      !n && u && (u.call(a, "null"), n = a.eval), forEach(Object_keys(e), function(h) {
        a[h] = e[h];
      }), forEach(globals, function(h) {
        e[h] && (a[h] = e[h]);
      });
      var o = Object_keys(a), l = n.call(a, this.code);
      return forEach(Object_keys(a), function(h) {
        (h in e || indexOf(o, h) === -1) && (e[h] = a[h]);
      }), forEach(globals, function(h) {
        h in e || defineProp(e, h, a[h]);
      }), document.body.removeChild(t), l;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(e) {
      var t = Script.createContext(e), a = this.runInContext(t);
      return e && forEach(Object_keys(t), function(n) {
        e[n] = t[n];
      }), a;
    }, forEach(Object_keys(Script.prototype), function(e) {
      exports[e] = Script[e] = function(t) {
        var a = Script(t);
        return a[e].apply(a, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(e) {
      return e instanceof Context;
    }, exports.createScript = function(e) {
      return exports.Script(e);
    }, exports.createContext = Script.createContext = function(e) {
      var t = new Context();
      return typeof e == "object" && forEach(Object_keys(e), function(a) {
        t[a] = e[a];
      }), t;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(e) {
    var t = requireAsn1(), a = inherits_browserExports, n = e;
    n.define = function(l, h) {
      return new u(l, h);
    };
    function u(o, l) {
      this.name = o, this.body = l, this.decoders = {}, this.encoders = {};
    }
    u.prototype._createNamed = function(l) {
      var h;
      try {
        h = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        h = function(_) {
          this._initNamed(_);
        };
      }
      return a(h, l), h.prototype._initNamed = function(_) {
        l.call(this, _);
      }, new h(this);
    }, u.prototype._getDecoder = function(l) {
      return l = l || "der", this.decoders.hasOwnProperty(l) || (this.decoders[l] = this._createNamed(t.decoders[l])), this.decoders[l];
    }, u.prototype.decode = function(l, h, y) {
      return this._getDecoder(h).decode(l, y);
    }, u.prototype._getEncoder = function(l) {
      return l = l || "der", this.encoders.hasOwnProperty(l) || (this.encoders[l] = this._createNamed(t.encoders[l])), this.encoders[l];
    }, u.prototype.encode = function(l, h, y) {
      return this._getEncoder(h).encode(l, y);
    };
  }(api$1)), api$1;
}
var base = {}, reporter = {}, inherits = inherits_browserExports;
function Reporter(e) {
  this._reporterState = {
    obj: null,
    path: [],
    options: e || {},
    errors: []
  };
}
reporter.Reporter = Reporter;
Reporter.prototype.isError = function e(t) {
  return t instanceof ReporterError;
};
Reporter.prototype.save = function e() {
  var t = this._reporterState;
  return { obj: t.obj, pathLen: t.path.length };
};
Reporter.prototype.restore = function e(t) {
  var a = this._reporterState;
  a.obj = t.obj, a.path = a.path.slice(0, t.pathLen);
};
Reporter.prototype.enterKey = function e(t) {
  return this._reporterState.path.push(t);
};
Reporter.prototype.exitKey = function e(t) {
  var a = this._reporterState;
  a.path = a.path.slice(0, t - 1);
};
Reporter.prototype.leaveKey = function e(t, a, n) {
  var u = this._reporterState;
  this.exitKey(t), u.obj !== null && (u.obj[a] = n);
};
Reporter.prototype.path = function e() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function e() {
  var t = this._reporterState, a = t.obj;
  return t.obj = {}, a;
};
Reporter.prototype.leaveObject = function e(t) {
  var a = this._reporterState, n = a.obj;
  return a.obj = t, n;
};
Reporter.prototype.error = function e(t) {
  var a, n = this._reporterState, u = t instanceof ReporterError;
  if (u ? a = t : a = new ReporterError(n.path.map(function(o) {
    return "[" + JSON.stringify(o) + "]";
  }).join(""), t.message || t, t.stack), !n.options.partial)
    throw a;
  return u || n.errors.push(a), a;
};
Reporter.prototype.wrapResult = function e(t) {
  var a = this._reporterState;
  return a.options.partial ? {
    result: this.isError(t) ? null : t,
    errors: a.errors
  } : t;
};
function ReporterError(e, t) {
  this.path = e, this.rethrow(t);
}
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function e(t) {
  if (this.message = t + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (a) {
      this.stack = a.stack;
    }
  return this;
};
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer)
    return buffer;
  hasRequiredBuffer = 1;
  var e = inherits_browserExports, t = requireBase().Reporter, a = buffer$1.Buffer;
  function n(o, l) {
    if (t.call(this, l), !a.isBuffer(o)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = o, this.offset = 0, this.length = o.length;
  }
  e(n, t), buffer.DecoderBuffer = n, n.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, n.prototype.restore = function(l) {
    var h = new n(this.base);
    return h.offset = l.offset, h.length = this.offset, this.offset = l.offset, t.prototype.restore.call(this, l.reporter), h;
  }, n.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, n.prototype.readUInt8 = function(l) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(l || "DecoderBuffer overrun");
  }, n.prototype.skip = function(l, h) {
    if (!(this.offset + l <= this.length))
      return this.error(h || "DecoderBuffer overrun");
    var y = new n(this.base);
    return y._reporterState = this._reporterState, y.offset = this.offset, y.length = this.offset + l, this.offset += l, y;
  }, n.prototype.raw = function(l) {
    return this.base.slice(l ? l.offset : this.offset, this.length);
  };
  function u(o, l) {
    if (Array.isArray(o))
      this.length = 0, this.value = o.map(function(h) {
        return h instanceof u || (h = new u(h, l)), this.length += h.length, h;
      }, this);
    else if (typeof o == "number") {
      if (!(0 <= o && o <= 255))
        return l.error("non-byte EncoderBuffer value");
      this.value = o, this.length = 1;
    } else if (typeof o == "string")
      this.value = o, this.length = a.byteLength(o);
    else if (a.isBuffer(o))
      this.value = o, this.length = o.length;
    else
      return l.error("Unsupported type: " + typeof o);
  }
  return buffer.EncoderBuffer = u, u.prototype.join = function(l, h) {
    return l || (l = new a(this.length)), h || (h = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(y) {
      y.join(l, h), h += y.length;
    }) : (typeof this.value == "number" ? l[h] = this.value : typeof this.value == "string" ? l.write(this.value, h) : a.isBuffer(this.value) && this.value.copy(l, h), h += this.length)), l;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node;
  hasRequiredNode = 1;
  var e = requireBase().Reporter, t = requireBase().EncoderBuffer, a = requireBase().DecoderBuffer, n = minimalisticAssert, u = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], o = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(u), l = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function h(_, d) {
    var $ = {};
    this._baseState = $, $.enc = _, $.parent = d || null, $.children = null, $.tag = null, $.args = null, $.reverseArgs = null, $.choice = null, $.optional = !1, $.any = !1, $.obj = !1, $.use = null, $.useDecoder = null, $.key = null, $.default = null, $.explicit = null, $.implicit = null, $.contains = null, $.parent || ($.children = [], this._wrap());
  }
  node = h;
  var y = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return h.prototype.clone = function() {
    var d = this._baseState, $ = {};
    y.forEach(function(U) {
      $[U] = d[U];
    });
    var N = new this.constructor($.parent);
    return N._baseState = $, N;
  }, h.prototype._wrap = function() {
    var d = this._baseState;
    o.forEach(function($) {
      this[$] = function() {
        var U = new this.constructor(this);
        return d.children.push(U), U[$].apply(U, arguments);
      };
    }, this);
  }, h.prototype._init = function(d) {
    var $ = this._baseState;
    n($.parent === null), d.call(this), $.children = $.children.filter(function(N) {
      return N._baseState.parent === this;
    }, this), n.equal($.children.length, 1, "Root node can have only one child");
  }, h.prototype._useArgs = function(d) {
    var $ = this._baseState, N = d.filter(function(U) {
      return U instanceof this.constructor;
    }, this);
    d = d.filter(function(U) {
      return !(U instanceof this.constructor);
    }, this), N.length !== 0 && (n($.children === null), $.children = N, N.forEach(function(U) {
      U._baseState.parent = this;
    }, this)), d.length !== 0 && (n($.args === null), $.args = d, $.reverseArgs = d.map(function(U) {
      if (typeof U != "object" || U.constructor !== Object)
        return U;
      var V = {};
      return Object.keys(U).forEach(function(Q) {
        Q == (Q | 0) && (Q |= 0);
        var ie = U[Q];
        V[ie] = Q;
      }), V;
    }));
  }, l.forEach(function(_) {
    h.prototype[_] = function() {
      var $ = this._baseState;
      throw new Error(_ + " not implemented for encoding: " + $.enc);
    };
  }), u.forEach(function(_) {
    h.prototype[_] = function() {
      var $ = this._baseState, N = Array.prototype.slice.call(arguments);
      return n($.tag === null), $.tag = _, this._useArgs(N), this;
    };
  }), h.prototype.use = function(d) {
    n(d);
    var $ = this._baseState;
    return n($.use === null), $.use = d, this;
  }, h.prototype.optional = function() {
    var d = this._baseState;
    return d.optional = !0, this;
  }, h.prototype.def = function(d) {
    var $ = this._baseState;
    return n($.default === null), $.default = d, $.optional = !0, this;
  }, h.prototype.explicit = function(d) {
    var $ = this._baseState;
    return n($.explicit === null && $.implicit === null), $.explicit = d, this;
  }, h.prototype.implicit = function(d) {
    var $ = this._baseState;
    return n($.explicit === null && $.implicit === null), $.implicit = d, this;
  }, h.prototype.obj = function() {
    var d = this._baseState, $ = Array.prototype.slice.call(arguments);
    return d.obj = !0, $.length !== 0 && this._useArgs($), this;
  }, h.prototype.key = function(d) {
    var $ = this._baseState;
    return n($.key === null), $.key = d, this;
  }, h.prototype.any = function() {
    var d = this._baseState;
    return d.any = !0, this;
  }, h.prototype.choice = function(d) {
    var $ = this._baseState;
    return n($.choice === null), $.choice = d, this._useArgs(Object.keys(d).map(function(N) {
      return d[N];
    })), this;
  }, h.prototype.contains = function(d) {
    var $ = this._baseState;
    return n($.use === null), $.contains = d, this;
  }, h.prototype._decode = function(d, $) {
    var N = this._baseState;
    if (N.parent === null)
      return d.wrapResult(N.children[0]._decode(d, $));
    var U = N.default, V = !0, Q = null;
    if (N.key !== null && (Q = d.enterKey(N.key)), N.optional) {
      var ie = null;
      if (N.explicit !== null ? ie = N.explicit : N.implicit !== null ? ie = N.implicit : N.tag !== null && (ie = N.tag), ie === null && !N.any) {
        var ee = d.save();
        try {
          N.choice === null ? this._decodeGeneric(N.tag, d, $) : this._decodeChoice(d, $), V = !0;
        } catch {
          V = !1;
        }
        d.restore(ee);
      } else if (V = this._peekTag(d, ie, N.any), d.isError(V))
        return V;
    }
    var ne;
    if (N.obj && V && (ne = d.enterObject()), V) {
      if (N.explicit !== null) {
        var ge = this._decodeTag(d, N.explicit);
        if (d.isError(ge))
          return ge;
        d = ge;
      }
      var be = d.offset;
      if (N.use === null && N.choice === null) {
        if (N.any)
          var ee = d.save();
        var Ee = this._decodeTag(
          d,
          N.implicit !== null ? N.implicit : N.tag,
          N.any
        );
        if (d.isError(Ee))
          return Ee;
        N.any ? U = d.raw(ee) : d = Ee;
      }
      if ($ && $.track && N.tag !== null && $.track(d.path(), be, d.length, "tagged"), $ && $.track && N.tag !== null && $.track(d.path(), d.offset, d.length, "content"), N.any ? U = U : N.choice === null ? U = this._decodeGeneric(N.tag, d, $) : U = this._decodeChoice(d, $), d.isError(U))
        return U;
      if (!N.any && N.choice === null && N.children !== null && N.children.forEach(function(Ne) {
        Ne._decode(d, $);
      }), N.contains && (N.tag === "octstr" || N.tag === "bitstr")) {
        var xe = new a(U);
        U = this._getUse(N.contains, d._reporterState.obj)._decode(xe, $);
      }
    }
    return N.obj && V && (U = d.leaveObject(ne)), N.key !== null && (U !== null || V === !0) ? d.leaveKey(Q, N.key, U) : Q !== null && d.exitKey(Q), U;
  }, h.prototype._decodeGeneric = function(d, $, N) {
    var U = this._baseState;
    return d === "seq" || d === "set" ? null : d === "seqof" || d === "setof" ? this._decodeList($, d, U.args[0], N) : /str$/.test(d) ? this._decodeStr($, d, N) : d === "objid" && U.args ? this._decodeObjid($, U.args[0], U.args[1], N) : d === "objid" ? this._decodeObjid($, null, null, N) : d === "gentime" || d === "utctime" ? this._decodeTime($, d, N) : d === "null_" ? this._decodeNull($, N) : d === "bool" ? this._decodeBool($, N) : d === "objDesc" ? this._decodeStr($, d, N) : d === "int" || d === "enum" ? this._decodeInt($, U.args && U.args[0], N) : U.use !== null ? this._getUse(U.use, $._reporterState.obj)._decode($, N) : $.error("unknown tag: " + d);
  }, h.prototype._getUse = function(d, $) {
    var N = this._baseState;
    return N.useDecoder = this._use(d, $), n(N.useDecoder._baseState.parent === null), N.useDecoder = N.useDecoder._baseState.children[0], N.implicit !== N.useDecoder._baseState.implicit && (N.useDecoder = N.useDecoder.clone(), N.useDecoder._baseState.implicit = N.implicit), N.useDecoder;
  }, h.prototype._decodeChoice = function(d, $) {
    var N = this._baseState, U = null, V = !1;
    return Object.keys(N.choice).some(function(Q) {
      var ie = d.save(), ee = N.choice[Q];
      try {
        var ne = ee._decode(d, $);
        if (d.isError(ne))
          return !1;
        U = { type: Q, value: ne }, V = !0;
      } catch {
        return d.restore(ie), !1;
      }
      return !0;
    }, this), V ? U : d.error("Choice not matched");
  }, h.prototype._createEncoderBuffer = function(d) {
    return new t(d, this.reporter);
  }, h.prototype._encode = function(d, $, N) {
    var U = this._baseState;
    if (!(U.default !== null && U.default === d)) {
      var V = this._encodeValue(d, $, N);
      if (V !== void 0 && !this._skipDefault(V, $, N))
        return V;
    }
  }, h.prototype._encodeValue = function(d, $, N) {
    var U = this._baseState;
    if (U.parent === null)
      return U.children[0]._encode(d, $ || new e());
    var ee = null;
    if (this.reporter = $, U.optional && d === void 0)
      if (U.default !== null)
        d = U.default;
      else
        return;
    var V = null, Q = !1;
    if (U.any)
      ee = this._createEncoderBuffer(d);
    else if (U.choice)
      ee = this._encodeChoice(d, $);
    else if (U.contains)
      V = this._getUse(U.contains, N)._encode(d, $), Q = !0;
    else if (U.children)
      V = U.children.map(function(be) {
        if (be._baseState.tag === "null_")
          return be._encode(null, $, d);
        if (be._baseState.key === null)
          return $.error("Child should have a key");
        var Ee = $.enterKey(be._baseState.key);
        if (typeof d != "object")
          return $.error("Child expected, but input is not object");
        var xe = be._encode(d[be._baseState.key], $, d);
        return $.leaveKey(Ee), xe;
      }, this).filter(function(be) {
        return be;
      }), V = this._createEncoderBuffer(V);
    else if (U.tag === "seqof" || U.tag === "setof") {
      if (!(U.args && U.args.length === 1))
        return $.error("Too many args for : " + U.tag);
      if (!Array.isArray(d))
        return $.error("seqof/setof, but data is not Array");
      var ie = this.clone();
      ie._baseState.implicit = null, V = this._createEncoderBuffer(d.map(function(be) {
        var Ee = this._baseState;
        return this._getUse(Ee.args[0], d)._encode(be, $);
      }, ie));
    } else
      U.use !== null ? ee = this._getUse(U.use, N)._encode(d, $) : (V = this._encodePrimitive(U.tag, d), Q = !0);
    var ee;
    if (!U.any && U.choice === null) {
      var ne = U.implicit !== null ? U.implicit : U.tag, ge = U.implicit === null ? "universal" : "context";
      ne === null ? U.use === null && $.error("Tag could be omitted only for .use()") : U.use === null && (ee = this._encodeComposite(ne, Q, ge, V));
    }
    return U.explicit !== null && (ee = this._encodeComposite(U.explicit, !1, "context", ee)), ee;
  }, h.prototype._encodeChoice = function(d, $) {
    var N = this._baseState, U = N.choice[d.type];
    return U || n(
      !1,
      d.type + " not found in " + JSON.stringify(Object.keys(N.choice))
    ), U._encode(d.value, $);
  }, h.prototype._encodePrimitive = function(d, $) {
    var N = this._baseState;
    if (/str$/.test(d))
      return this._encodeStr($, d);
    if (d === "objid" && N.args)
      return this._encodeObjid($, N.reverseArgs[0], N.args[1]);
    if (d === "objid")
      return this._encodeObjid($, null, null);
    if (d === "gentime" || d === "utctime")
      return this._encodeTime($, d);
    if (d === "null_")
      return this._encodeNull();
    if (d === "int" || d === "enum")
      return this._encodeInt($, N.args && N.reverseArgs[0]);
    if (d === "bool")
      return this._encodeBool($);
    if (d === "objDesc")
      return this._encodeStr($, d);
    throw new Error("Unsupported tag: " + d);
  }, h.prototype._isNumstr = function(d) {
    return /^[0-9 ]*$/.test(d);
  }, h.prototype._isPrintstr = function(d) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(d);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(e) {
    var t = e;
    t.Reporter = reporter.Reporter, t.DecoderBuffer = requireBuffer().DecoderBuffer, t.EncoderBuffer = requireBuffer().EncoderBuffer, t.Node = requireNode();
  }(base)), base;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(e) {
    var t = requireConstants();
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = t._reverse(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = t._reverse(e.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(e) {
    var t = e;
    t._reverse = function(n) {
      var u = {};
      return Object.keys(n).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        var l = n[o];
        u[l] = o;
      }), u;
    }, t.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1)
    return der_1$1;
  hasRequiredDer$1 = 1;
  var e = inherits_browserExports, t = requireAsn1(), a = t.base, n = t.bignum, u = t.constants.der;
  function o(_) {
    this.enc = "der", this.name = _.name, this.entity = _, this.tree = new l(), this.tree._init(_.body);
  }
  der_1$1 = o, o.prototype.decode = function(d, $) {
    return d instanceof a.DecoderBuffer || (d = new a.DecoderBuffer(d, $)), this.tree._decode(d, $);
  };
  function l(_) {
    a.Node.call(this, "der", _);
  }
  e(l, a.Node), l.prototype._peekTag = function(d, $, N) {
    if (d.isEmpty())
      return !1;
    var U = d.save(), V = h(d, 'Failed to peek tag: "' + $ + '"');
    return d.isError(V) ? V : (d.restore(U), V.tag === $ || V.tagStr === $ || V.tagStr + "of" === $ || N);
  }, l.prototype._decodeTag = function(d, $, N) {
    var U = h(
      d,
      'Failed to decode tag of "' + $ + '"'
    );
    if (d.isError(U))
      return U;
    var V = y(
      d,
      U.primitive,
      'Failed to get length of "' + $ + '"'
    );
    if (d.isError(V))
      return V;
    if (!N && U.tag !== $ && U.tagStr !== $ && U.tagStr + "of" !== $)
      return d.error('Failed to match tag: "' + $ + '"');
    if (U.primitive || V !== null)
      return d.skip(V, 'Failed to match body of: "' + $ + '"');
    var Q = d.save(), ie = this._skipUntilEnd(
      d,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return d.isError(ie) ? ie : (V = d.offset - Q.offset, d.restore(Q), d.skip(V, 'Failed to match body of: "' + $ + '"'));
  }, l.prototype._skipUntilEnd = function(d, $) {
    for (; ; ) {
      var N = h(d, $);
      if (d.isError(N))
        return N;
      var U = y(d, N.primitive, $);
      if (d.isError(U))
        return U;
      var V;
      if (N.primitive || U !== null ? V = d.skip(U) : V = this._skipUntilEnd(d, $), d.isError(V))
        return V;
      if (N.tagStr === "end")
        break;
    }
  }, l.prototype._decodeList = function(d, $, N, U) {
    for (var V = []; !d.isEmpty(); ) {
      var Q = this._peekTag(d, "end");
      if (d.isError(Q))
        return Q;
      var ie = N.decode(d, "der", U);
      if (d.isError(ie) && Q)
        break;
      V.push(ie);
    }
    return V;
  }, l.prototype._decodeStr = function(d, $) {
    if ($ === "bitstr") {
      var N = d.readUInt8();
      return d.isError(N) ? N : { unused: N, data: d.raw() };
    } else if ($ === "bmpstr") {
      var U = d.raw();
      if (U.length % 2 === 1)
        return d.error("Decoding of string type: bmpstr length mismatch");
      for (var V = "", Q = 0; Q < U.length / 2; Q++)
        V += String.fromCharCode(U.readUInt16BE(Q * 2));
      return V;
    } else if ($ === "numstr") {
      var ie = d.raw().toString("ascii");
      return this._isNumstr(ie) ? ie : d.error("Decoding of string type: numstr unsupported characters");
    } else {
      if ($ === "octstr")
        return d.raw();
      if ($ === "objDesc")
        return d.raw();
      if ($ === "printstr") {
        var ee = d.raw().toString("ascii");
        return this._isPrintstr(ee) ? ee : d.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test($) ? d.raw().toString() : d.error("Decoding of string type: " + $ + " unsupported");
    }
  }, l.prototype._decodeObjid = function(d, $, N) {
    for (var U, V = [], Q = 0; !d.isEmpty(); ) {
      var ie = d.readUInt8();
      Q <<= 7, Q |= ie & 127, ie & 128 || (V.push(Q), Q = 0);
    }
    ie & 128 && V.push(Q);
    var ee = V[0] / 40 | 0, ne = V[0] % 40;
    if (N ? U = V : U = [ee, ne].concat(V.slice(1)), $) {
      var ge = $[U.join(" ")];
      ge === void 0 && (ge = $[U.join(".")]), ge !== void 0 && (U = ge);
    }
    return U;
  }, l.prototype._decodeTime = function(d, $) {
    var N = d.raw().toString();
    if ($ === "gentime")
      var U = N.slice(0, 4) | 0, V = N.slice(4, 6) | 0, Q = N.slice(6, 8) | 0, ie = N.slice(8, 10) | 0, ee = N.slice(10, 12) | 0, ne = N.slice(12, 14) | 0;
    else if ($ === "utctime") {
      var U = N.slice(0, 2) | 0, V = N.slice(2, 4) | 0, Q = N.slice(4, 6) | 0, ie = N.slice(6, 8) | 0, ee = N.slice(8, 10) | 0, ne = N.slice(10, 12) | 0;
      U < 70 ? U = 2e3 + U : U = 1900 + U;
    } else
      return d.error("Decoding " + $ + " time is not supported yet");
    return Date.UTC(U, V - 1, Q, ie, ee, ne, 0);
  }, l.prototype._decodeNull = function(d) {
    return null;
  }, l.prototype._decodeBool = function(d) {
    var $ = d.readUInt8();
    return d.isError($) ? $ : $ !== 0;
  }, l.prototype._decodeInt = function(d, $) {
    var N = d.raw(), U = new n(N);
    return $ && (U = $[U.toString(10)] || U), U;
  }, l.prototype._use = function(d, $) {
    return typeof d == "function" && (d = d($)), d._getDecoder("der").tree;
  };
  function h(_, d) {
    var $ = _.readUInt8(d);
    if (_.isError($))
      return $;
    var N = u.tagClass[$ >> 6], U = ($ & 32) === 0;
    if (($ & 31) === 31) {
      var V = $;
      for ($ = 0; (V & 128) === 128; ) {
        if (V = _.readUInt8(d), _.isError(V))
          return V;
        $ <<= 7, $ |= V & 127;
      }
    } else
      $ &= 31;
    var Q = u.tag[$];
    return {
      cls: N,
      primitive: U,
      tag: $,
      tagStr: Q
    };
  }
  function y(_, d, $) {
    var N = _.readUInt8($);
    if (_.isError(N))
      return N;
    if (!d && N === 128)
      return null;
    if (!(N & 128))
      return N;
    var U = N & 127;
    if (U > 4)
      return _.error("length octect is too long");
    N = 0;
    for (var V = 0; V < U; V++) {
      N <<= 8;
      var Q = _.readUInt8($);
      if (_.isError(Q))
        return Q;
      N |= Q;
    }
    return N;
  }
  return der_1$1;
}
var pem$2, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1)
    return pem$2;
  hasRequiredPem$1 = 1;
  var e = inherits_browserExports, t = buffer$1.Buffer, a = requireDer$1();
  function n(u) {
    a.call(this, u), this.enc = "pem";
  }
  return e(n, a), pem$2 = n, n.prototype.decode = function(o, l) {
    for (var h = o.toString().split(/[\r\n]+/g), y = l.label.toUpperCase(), _ = /^-----(BEGIN|END) ([^-]+)-----$/, d = -1, $ = -1, N = 0; N < h.length; N++) {
      var U = h[N].match(_);
      if (U !== null && U[2] === y)
        if (d === -1) {
          if (U[1] !== "BEGIN")
            break;
          d = N;
        } else {
          if (U[1] !== "END")
            break;
          $ = N;
          break;
        }
    }
    if (d === -1 || $ === -1)
      throw new Error("PEM section not found for: " + y);
    var V = h.slice(d + 1, $).join("");
    V.replace(/[^a-z0-9\+\/=]+/gi, "");
    var Q = new t(V, "base64");
    return a.prototype.decode.call(this, Q, l);
  }, pem$2;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(e) {
    var t = e;
    t.der = requireDer$1(), t.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer)
    return der_1;
  hasRequiredDer = 1;
  var e = inherits_browserExports, t = buffer$1.Buffer, a = requireAsn1(), n = a.base, u = a.constants.der;
  function o(_) {
    this.enc = "der", this.name = _.name, this.entity = _, this.tree = new l(), this.tree._init(_.body);
  }
  der_1 = o, o.prototype.encode = function(d, $) {
    return this.tree._encode(d, $).join();
  };
  function l(_) {
    n.Node.call(this, "der", _);
  }
  e(l, n.Node), l.prototype._encodeComposite = function(d, $, N, U) {
    var V = y(d, $, N, this.reporter);
    if (U.length < 128) {
      var ee = new t(2);
      return ee[0] = V, ee[1] = U.length, this._createEncoderBuffer([ee, U]);
    }
    for (var Q = 1, ie = U.length; ie >= 256; ie >>= 8)
      Q++;
    var ee = new t(1 + 1 + Q);
    ee[0] = V, ee[1] = 128 | Q;
    for (var ie = 1 + Q, ne = U.length; ne > 0; ie--, ne >>= 8)
      ee[ie] = ne & 255;
    return this._createEncoderBuffer([ee, U]);
  }, l.prototype._encodeStr = function(d, $) {
    if ($ === "bitstr")
      return this._createEncoderBuffer([d.unused | 0, d.data]);
    if ($ === "bmpstr") {
      for (var N = new t(d.length * 2), U = 0; U < d.length; U++)
        N.writeUInt16BE(d.charCodeAt(U), U * 2);
      return this._createEncoderBuffer(N);
    } else
      return $ === "numstr" ? this._isNumstr(d) ? this._createEncoderBuffer(d) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : $ === "printstr" ? this._isPrintstr(d) ? this._createEncoderBuffer(d) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test($) ? this._createEncoderBuffer(d) : $ === "objDesc" ? this._createEncoderBuffer(d) : this.reporter.error("Encoding of string type: " + $ + " unsupported");
  }, l.prototype._encodeObjid = function(d, $, N) {
    if (typeof d == "string") {
      if (!$)
        return this.reporter.error("string objid given, but no values map found");
      if (!$.hasOwnProperty(d))
        return this.reporter.error("objid not found in values map");
      d = $[d].split(/[\s\.]+/g);
      for (var U = 0; U < d.length; U++)
        d[U] |= 0;
    } else if (Array.isArray(d)) {
      d = d.slice();
      for (var U = 0; U < d.length; U++)
        d[U] |= 0;
    }
    if (!Array.isArray(d))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(d));
    if (!N) {
      if (d[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      d.splice(0, 2, d[0] * 40 + d[1]);
    }
    for (var V = 0, U = 0; U < d.length; U++) {
      var Q = d[U];
      for (V++; Q >= 128; Q >>= 7)
        V++;
    }
    for (var ie = new t(V), ee = ie.length - 1, U = d.length - 1; U >= 0; U--) {
      var Q = d[U];
      for (ie[ee--] = Q & 127; (Q >>= 7) > 0; )
        ie[ee--] = 128 | Q & 127;
    }
    return this._createEncoderBuffer(ie);
  };
  function h(_) {
    return _ < 10 ? "0" + _ : _;
  }
  l.prototype._encodeTime = function(d, $) {
    var N, U = new Date(d);
    return $ === "gentime" ? N = [
      h(U.getFullYear()),
      h(U.getUTCMonth() + 1),
      h(U.getUTCDate()),
      h(U.getUTCHours()),
      h(U.getUTCMinutes()),
      h(U.getUTCSeconds()),
      "Z"
    ].join("") : $ === "utctime" ? N = [
      h(U.getFullYear() % 100),
      h(U.getUTCMonth() + 1),
      h(U.getUTCDate()),
      h(U.getUTCHours()),
      h(U.getUTCMinutes()),
      h(U.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + $ + " time is not supported yet"), this._encodeStr(N, "octstr");
  }, l.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, l.prototype._encodeInt = function(d, $) {
    if (typeof d == "string") {
      if (!$)
        return this.reporter.error("String int or enum given, but no values map");
      if (!$.hasOwnProperty(d))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(d));
      d = $[d];
    }
    if (typeof d != "number" && !t.isBuffer(d)) {
      var N = d.toArray();
      !d.sign && N[0] & 128 && N.unshift(0), d = new t(N);
    }
    if (t.isBuffer(d)) {
      var U = d.length;
      d.length === 0 && U++;
      var Q = new t(U);
      return d.copy(Q), d.length === 0 && (Q[0] = 0), this._createEncoderBuffer(Q);
    }
    if (d < 128)
      return this._createEncoderBuffer(d);
    if (d < 256)
      return this._createEncoderBuffer([0, d]);
    for (var U = 1, V = d; V >= 256; V >>= 8)
      U++;
    for (var Q = new Array(U), V = Q.length - 1; V >= 0; V--)
      Q[V] = d & 255, d >>= 8;
    return Q[0] & 128 && Q.unshift(0), this._createEncoderBuffer(new t(Q));
  }, l.prototype._encodeBool = function(d) {
    return this._createEncoderBuffer(d ? 255 : 0);
  }, l.prototype._use = function(d, $) {
    return typeof d == "function" && (d = d($)), d._getEncoder("der").tree;
  }, l.prototype._skipDefault = function(d, $, N) {
    var U = this._baseState, V;
    if (U.default === null)
      return !1;
    var Q = d.join();
    if (U.defaultBuffer === void 0 && (U.defaultBuffer = this._encodeValue(U.default, $, N).join()), Q.length !== U.defaultBuffer.length)
      return !1;
    for (V = 0; V < Q.length; V++)
      if (Q[V] !== U.defaultBuffer[V])
        return !1;
    return !0;
  };
  function y(_, d, $, N) {
    var U;
    if (_ === "seqof" ? _ = "seq" : _ === "setof" && (_ = "set"), u.tagByName.hasOwnProperty(_))
      U = u.tagByName[_];
    else if (typeof _ == "number" && (_ | 0) === _)
      U = _;
    else
      return N.error("Unknown tag: " + _);
    return U >= 31 ? N.error("Multi-octet tag encoding unsupported") : (d || (U |= 32), U |= u.tagClassByName[$ || "universal"] << 6, U);
  }
  return der_1;
}
var pem$1, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem)
    return pem$1;
  hasRequiredPem = 1;
  var e = inherits_browserExports, t = requireDer();
  function a(n) {
    t.call(this, n), this.enc = "pem";
  }
  return e(a, t), pem$1 = a, a.prototype.encode = function(u, o) {
    for (var l = t.prototype.encode.call(this, u), h = l.toString("base64"), y = ["-----BEGIN " + o.label + "-----"], _ = 0; _ < h.length; _ += 64)
      y.push(h.slice(_, _ + 64));
    return y.push("-----END " + o.label + "-----"), y.join(`
`);
  }, pem$1;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(e) {
    var t = e;
    t.der = requireDer(), t.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1;
function requireAsn1() {
  return hasRequiredAsn1 || (hasRequiredAsn1 = 1, function(e) {
    var t = e;
    t.bignum = bnExports$2, t.define = requireApi().define, t.base = requireBase(), t.constants = requireConstants(), t.decoders = requireDecoders(), t.encoders = requireEncoders();
  }(asn1$b)), asn1$b;
}
var asn = requireAsn1(), Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$a = requireAsn1();
asn1$c.certificate = certificate;
var RSAPrivateKey = asn1$a.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$c.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$a.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$c.RSAPublicKey = RSAPublicKey;
var AlgorithmIdentifier = asn1$a.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PublicKey = asn1$a.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$c.PublicKey = PublicKey;
var PrivateKeyInfo = asn1$a.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$c.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$a.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$c.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$a.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$c.DSAPrivateKey = DSAPrivateKey;
asn1$c.DSAparam = asn1$a.define("DSAparam", function() {
  this.int();
});
var ECParameters = asn1$a.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
}), ECPrivateKey = asn1$a.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$c.ECPrivateKey = ECPrivateKey;
asn1$c.signature = asn1$a.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$5, Buffer$6 = safeBufferExports$2.Buffer, fixProc$1 = function(e, t) {
  var a = e.toString(), n = a.match(findProc), u;
  if (n) {
    var l = "aes" + n[1], h = Buffer$6.from(n[2], "hex"), y = Buffer$6.from(n[3].replace(/[\r\n]/g, ""), "base64"), _ = evp(t, h.slice(0, 8), parseInt(n[1], 10)).key, d = [], $ = ciphers$1.createDecipheriv(l, _, h);
    d.push($.update(y)), d.push($.final()), u = Buffer$6.concat(d);
  } else {
    var o = a.match(fullRegex);
    u = Buffer$6.from(o[2].replace(/[\r\n]/g, ""), "base64");
  }
  var N = a.match(startRegex)[1];
  return {
    tag: N,
    data: u
  };
}, asn1$9 = asn1$c, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$5, pbkdf2Sync = browser$7.pbkdf2Sync, Buffer$5 = safeBufferExports$2.Buffer;
function decrypt(e, t) {
  var a = e.algorithm.decrypt.kde.kdeparams.salt, n = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), u = aesid[e.algorithm.decrypt.cipher.algo.join(".")], o = e.algorithm.decrypt.cipher.iv, l = e.subjectPrivateKey, h = parseInt(u.split("-")[1], 10) / 8, y = pbkdf2Sync(t, a, n, h, "sha1"), _ = ciphers.createDecipheriv(u, y, o), d = [];
  return d.push(_.update(l)), d.push(_.final()), Buffer$5.concat(d);
}
function parseKeys$2(e) {
  var t;
  typeof e == "object" && !Buffer$5.isBuffer(e) && (t = e.passphrase, e = e.key), typeof e == "string" && (e = Buffer$5.from(e));
  var a = fixProc(e, t), n = a.tag, u = a.data, o, l;
  switch (n) {
    case "CERTIFICATE":
      l = asn1$9.certificate.decode(u, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (l || (l = asn1$9.PublicKey.decode(u, "der")), o = l.algorithm.algorithm.join("."), o) {
        case "1.2.840.113549.1.1.1":
          return asn1$9.RSAPublicKey.decode(l.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return l.subjectPrivateKey = l.subjectPublicKey, {
            type: "ec",
            data: l
          };
        case "1.2.840.10040.4.1":
          return l.algorithm.params.pub_key = asn1$9.DSAparam.decode(l.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: l.algorithm.params
          };
        default:
          throw new Error("unknown key id " + o);
      }
    case "ENCRYPTED PRIVATE KEY":
      u = asn1$9.EncryptedPrivateKey.decode(u, "der"), u = decrypt(u, t);
    case "PRIVATE KEY":
      switch (l = asn1$9.PrivateKey.decode(u, "der"), o = l.algorithm.algorithm.join("."), o) {
        case "1.2.840.113549.1.1.1":
          return asn1$9.RSAPrivateKey.decode(l.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: l.algorithm.curve,
            privateKey: asn1$9.ECPrivateKey.decode(l.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return l.algorithm.params.priv_key = asn1$9.DSAparam.decode(l.subjectPrivateKey, "der"), {
            type: "dsa",
            params: l.algorithm.params
          };
        default:
          throw new Error("unknown key id " + o);
      }
    case "RSA PUBLIC KEY":
      return asn1$9.RSAPublicKey.decode(u, "der");
    case "RSA PRIVATE KEY":
      return asn1$9.RSAPrivateKey.decode(u, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1$9.DSAPrivateKey.decode(u, "der")
      };
    case "EC PRIVATE KEY":
      return u = asn1$9.ECPrivateKey.decode(u, "der"), {
        curve: u.parameters.value,
        privateKey: u.privateKey
      };
    default:
      throw new Error("unknown key type " + n);
  }
}
parseKeys$2.signature = asn1$9.signature;
var parseAsn1 = parseKeys$2;
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign.exports;
  hasRequiredSign = 1;
  var e = safeBufferExports$2.Buffer, t = browser$8, a = browserifyRsa, n = requireElliptic().ec, u = bnExports, o = parseAsn1, l = require$$4, h = 1;
  function y(ee, ne, ge, be, Ee) {
    var xe = o(ne);
    if (xe.curve) {
      if (be !== "ecdsa" && be !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return _(ee, xe);
    } else if (xe.type === "dsa") {
      if (be !== "dsa")
        throw new Error("wrong private key type");
      return d(ee, xe, ge);
    }
    if (be !== "rsa" && be !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (ne.padding !== void 0 && ne.padding !== h)
      throw new Error("illegal or unsupported padding mode");
    ee = e.concat([Ee, ee]);
    for (var Le = xe.modulus.byteLength(), Ne = [0, 1]; ee.length + Ne.length + 1 < Le; )
      Ne.push(255);
    Ne.push(0);
    for (var Re = -1; ++Re < ee.length; )
      Ne.push(ee[Re]);
    var Xe = a(Ne, xe);
    return Xe;
  }
  function _(ee, ne) {
    var ge = l[ne.curve.join(".")];
    if (!ge)
      throw new Error("unknown curve " + ne.curve.join("."));
    var be = new n(ge), Ee = be.keyFromPrivate(ne.privateKey), xe = Ee.sign(ee);
    return e.from(xe.toDER());
  }
  function d(ee, ne, ge) {
    for (var be = ne.params.priv_key, Ee = ne.params.p, xe = ne.params.q, Le = ne.params.g, Ne = new u(0), Re, Xe = U(ee, xe).mod(xe), pe = !1, O = N(be, xe, ee, ge); pe === !1; )
      Re = Q(xe, O, ge), Ne = ie(Le, Re, Ee, xe), pe = Re.invm(xe).imul(Xe.add(be.mul(Ne))).mod(xe), pe.cmpn(0) === 0 && (pe = !1, Ne = new u(0));
    return $(Ne, pe);
  }
  function $(ee, ne) {
    ee = ee.toArray(), ne = ne.toArray(), ee[0] & 128 && (ee = [0].concat(ee)), ne[0] & 128 && (ne = [0].concat(ne));
    var ge = ee.length + ne.length + 4, be = [
      48,
      ge,
      2,
      ee.length
    ];
    return be = be.concat(ee, [2, ne.length], ne), e.from(be);
  }
  function N(ee, ne, ge, be) {
    if (ee = e.from(ee.toArray()), ee.length < ne.byteLength()) {
      var Ee = e.alloc(ne.byteLength() - ee.length);
      ee = e.concat([Ee, ee]);
    }
    var xe = ge.length, Le = V(ge, ne), Ne = e.alloc(xe);
    Ne.fill(1);
    var Re = e.alloc(xe);
    return Re = t(be, Re).update(Ne).update(e.from([0])).update(ee).update(Le).digest(), Ne = t(be, Re).update(Ne).digest(), Re = t(be, Re).update(Ne).update(e.from([1])).update(ee).update(Le).digest(), Ne = t(be, Re).update(Ne).digest(), { k: Re, v: Ne };
  }
  function U(ee, ne) {
    var ge = new u(ee), be = (ee.length << 3) - ne.bitLength();
    return be > 0 && ge.ishrn(be), ge;
  }
  function V(ee, ne) {
    ee = U(ee, ne), ee = ee.mod(ne);
    var ge = e.from(ee.toArray());
    if (ge.length < ne.byteLength()) {
      var be = e.alloc(ne.byteLength() - ge.length);
      ge = e.concat([be, ge]);
    }
    return ge;
  }
  function Q(ee, ne, ge) {
    var be, Ee;
    do {
      for (be = e.alloc(0); be.length * 8 < ee.bitLength(); )
        ne.v = t(ge, ne.k).update(ne.v).digest(), be = e.concat([be, ne.v]);
      Ee = U(be, ee), ne.k = t(ge, ne.k).update(ne.v).update(e.from([0])).digest(), ne.v = t(ge, ne.k).update(ne.v).digest();
    } while (Ee.cmp(ee) !== -1);
    return Ee;
  }
  function ie(ee, ne, ge, be) {
    return ee.toRed(u.mont(ge)).redPow(ne).fromRed().mod(be);
  }
  return sign.exports = y, sign.exports.getKey = N, sign.exports.makeKey = Q, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var e = safeBufferExports$2.Buffer, t = bnExports, a = requireElliptic().ec, n = parseAsn1, u = require$$4;
  function o(_, d, $, N, U) {
    var V = n($);
    if (V.type === "ec") {
      if (N !== "ecdsa" && N !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return l(_, d, V);
    } else if (V.type === "dsa") {
      if (N !== "dsa")
        throw new Error("wrong public key type");
      return h(_, d, V);
    }
    if (N !== "rsa" && N !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    d = e.concat([U, d]);
    for (var Q = V.modulus.byteLength(), ie = [1], ee = 0; d.length + ie.length + 2 < Q; )
      ie.push(255), ee += 1;
    ie.push(0);
    for (var ne = -1; ++ne < d.length; )
      ie.push(d[ne]);
    ie = e.from(ie);
    var ge = t.mont(V.modulus);
    _ = new t(_).toRed(ge), _ = _.redPow(new t(V.publicExponent)), _ = e.from(_.fromRed().toArray());
    var be = ee < 8 ? 1 : 0;
    for (Q = Math.min(_.length, ie.length), _.length !== ie.length && (be = 1), ne = -1; ++ne < Q; )
      be |= _[ne] ^ ie[ne];
    return be === 0;
  }
  function l(_, d, $) {
    var N = u[$.data.algorithm.curve.join(".")];
    if (!N)
      throw new Error("unknown curve " + $.data.algorithm.curve.join("."));
    var U = new a(N), V = $.data.subjectPrivateKey.data;
    return U.verify(d, _, V);
  }
  function h(_, d, $) {
    var N = $.data.p, U = $.data.q, V = $.data.g, Q = $.data.pub_key, ie = n.signature.decode(_, "der"), ee = ie.s, ne = ie.r;
    y(ee, U), y(ne, U);
    var ge = t.mont(N), be = ee.invm(U), Ee = V.toRed(ge).redPow(new t(d).mul(be).mod(U)).fromRed().mul(Q.toRed(ge).redPow(ne.mul(be).mod(U)).fromRed()).mod(N).mod(U);
    return Ee.cmp(ne) === 0;
  }
  function y(_, d) {
    if (_.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (_.cmp(d) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = o, verify_1;
}
var browser$3, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$3;
  hasRequiredBrowser$1 = 1;
  var e = safeBufferExports$2.Buffer, t = browser$9, a = readableBrowserExports, n = inherits_browserExports, u = requireSign(), o = requireVerify(), l = require$$6;
  Object.keys(l).forEach(function($) {
    l[$].id = e.from(l[$].id, "hex"), l[$.toLowerCase()] = l[$];
  });
  function h($) {
    a.Writable.call(this);
    var N = l[$];
    if (!N)
      throw new Error("Unknown message digest");
    this._hashType = N.hash, this._hash = t(N.hash), this._tag = N.id, this._signType = N.sign;
  }
  n(h, a.Writable), h.prototype._write = function(N, U, V) {
    this._hash.update(N), V();
  }, h.prototype.update = function(N, U) {
    return this._hash.update(typeof N == "string" ? e.from(N, U) : N), this;
  }, h.prototype.sign = function(N, U) {
    this.end();
    var V = this._hash.digest(), Q = u(V, N, this._hashType, this._signType, this._tag);
    return U ? Q.toString(U) : Q;
  };
  function y($) {
    a.Writable.call(this);
    var N = l[$];
    if (!N)
      throw new Error("Unknown message digest");
    this._hash = t(N.hash), this._tag = N.id, this._signType = N.sign;
  }
  n(y, a.Writable), y.prototype._write = function(N, U, V) {
    this._hash.update(N), V();
  }, y.prototype.update = function(N, U) {
    return this._hash.update(typeof N == "string" ? e.from(N, U) : N), this;
  }, y.prototype.verify = function(N, U, V) {
    var Q = typeof U == "string" ? e.from(U, V) : U;
    this.end();
    var ie = this._hash.digest();
    return o(Q, ie, N, this._signType, this._tag);
  };
  function _($) {
    return new h($);
  }
  function d($) {
    return new y($);
  }
  return browser$3 = {
    Sign: _,
    Verify: d,
    createSign: _,
    createVerify: d
  }, browser$3;
}
var browser$2, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$2;
  hasRequiredBrowser = 1;
  var e = requireElliptic(), t = bnExports$2;
  browser$2 = function(l) {
    return new n(l);
  };
  var a = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  a.p224 = a.secp224r1, a.p256 = a.secp256r1 = a.prime256v1, a.p192 = a.secp192r1 = a.prime192v1, a.p384 = a.secp384r1, a.p521 = a.secp521r1;
  function n(o) {
    this.curveType = a[o], this.curveType || (this.curveType = {
      name: o
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  n.prototype.generateKeys = function(o, l) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(o, l);
  }, n.prototype.computeSecret = function(o, l, h) {
    l = l || "utf8", buffer$1.Buffer.isBuffer(o) || (o = new buffer$1.Buffer(o, l));
    var y = this.curve.keyFromPublic(o).getPublic(), _ = y.mul(this.keys.getPrivate()).getX();
    return u(_, h, this.curveType.byteLength);
  }, n.prototype.getPublicKey = function(o, l) {
    var h = this.keys.getPublic(l === "compressed", !0);
    return l === "hybrid" && (h[h.length - 1] % 2 ? h[0] = 7 : h[0] = 6), u(h, o);
  }, n.prototype.getPrivateKey = function(o) {
    return u(this.keys.getPrivate(), o);
  }, n.prototype.setPublicKey = function(o, l) {
    return l = l || "utf8", buffer$1.Buffer.isBuffer(o) || (o = new buffer$1.Buffer(o, l)), this.keys._importPublic(o), this;
  }, n.prototype.setPrivateKey = function(o, l) {
    l = l || "utf8", buffer$1.Buffer.isBuffer(o) || (o = new buffer$1.Buffer(o, l));
    var h = new t(o);
    return h = h.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(h), this;
  };
  function u(o, l, h) {
    Array.isArray(o) || (o = o.toArray());
    var y = new buffer$1.Buffer(o);
    if (h && y.length < h) {
      var _ = new buffer$1.Buffer(h - y.length);
      _.fill(0), y = buffer$1.Buffer.concat([_, y]);
    }
    return l ? y.toString(l) : y;
  }
  return browser$2;
}
var browser$1 = {}, createHash$2 = browser$9, Buffer$4 = safeBufferExports$2.Buffer, mgf$2 = function(e, t) {
  for (var a = Buffer$4.alloc(0), n = 0, u; a.length < t; )
    u = i2ops(n++), a = Buffer$4.concat([a, createHash$2("sha1").update(e).update(u).digest()]);
  return a.slice(0, t);
};
function i2ops(e) {
  var t = Buffer$4.allocUnsafe(4);
  return t.writeUInt32BE(e, 0), t;
}
var xor$2 = function e(t, a) {
  for (var n = t.length, u = -1; ++u < n; )
    t[u] ^= a[u];
  return t;
}, BN$2 = bnExports$2, Buffer$3 = safeBufferExports$2.Buffer;
function withPublic$2(e, t) {
  return Buffer$3.from(e.toRed(BN$2.mont(t.modulus)).redPow(new BN$2(t.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$9, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports$2, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$2 = safeBufferExports$2.Buffer, publicEncrypt = function e(t, a, n) {
  var u;
  t.padding ? u = t.padding : n ? u = 1 : u = 4;
  var o = parseKeys$1(t), l;
  if (u === 4)
    l = oaep$1(o, a);
  else if (u === 1)
    l = pkcs1$2(o, a, n);
  else if (u === 3) {
    if (l = new BN$1(a), l.cmp(o.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return n ? crt$1(l, o) : withPublic$1(l, o);
};
function oaep$1(e, t) {
  var a = e.modulus.byteLength(), n = t.length, u = createHash$1("sha1").update(Buffer$2.alloc(0)).digest(), o = u.length, l = 2 * o;
  if (n > a - l - 2)
    throw new Error("message too long");
  var h = Buffer$2.alloc(a - n - l - 2), y = a - o - 1, _ = randomBytes(o), d = xor$1(Buffer$2.concat([u, h, Buffer$2.alloc(1, 1), t], y), mgf$1(_, y)), $ = xor$1(_, mgf$1(d, o));
  return new BN$1(Buffer$2.concat([Buffer$2.alloc(1), $, d], a));
}
function pkcs1$2(e, t, a) {
  var n = t.length, u = e.modulus.byteLength();
  if (n > u - 11)
    throw new Error("message too long");
  var o;
  return a ? o = Buffer$2.alloc(u - n - 3, 255) : o = nonZero(u - n - 3), new BN$1(Buffer$2.concat([Buffer$2.from([0, a ? 1 : 2]), o, Buffer$2.alloc(1), t], u));
}
function nonZero(e) {
  for (var t = Buffer$2.allocUnsafe(e), a = 0, n = randomBytes(e * 2), u = 0, o; a < e; )
    u === n.length && (n = randomBytes(e * 2), u = 0), o = n[u++], o && (t[a++] = o);
  return t;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports$2, crt = browserifyRsa, createHash = browser$9, withPublic = withPublic_1, Buffer$1 = safeBufferExports$2.Buffer, privateDecrypt = function e(t, a, n) {
  var u;
  t.padding ? u = t.padding : n ? u = 1 : u = 4;
  var o = parseKeys(t), l = o.modulus.byteLength();
  if (a.length > l || new BN(a).cmp(o.modulus) >= 0)
    throw new Error("decryption error");
  var h;
  n ? h = withPublic(new BN(a), o) : h = crt(a, o);
  var y = Buffer$1.alloc(l - h.length);
  if (h = Buffer$1.concat([y, h], l), u === 4)
    return oaep(o, h);
  if (u === 1)
    return pkcs1$1(o, h, n);
  if (u === 3)
    return h;
  throw new Error("unknown padding");
};
function oaep(e, t) {
  var a = e.modulus.byteLength(), n = createHash("sha1").update(Buffer$1.alloc(0)).digest(), u = n.length;
  if (t[0] !== 0)
    throw new Error("decryption error");
  var o = t.slice(1, u + 1), l = t.slice(u + 1), h = xor(o, mgf(l, u)), y = xor(l, mgf(h, a - u - 1));
  if (compare(n, y.slice(0, u)))
    throw new Error("decryption error");
  for (var _ = u; y[_] === 0; )
    _++;
  if (y[_++] !== 1)
    throw new Error("decryption error");
  return y.slice(_);
}
function pkcs1$1(e, t, a) {
  for (var n = t.slice(0, 2), u = 2, o = 0; t[u++] !== 0; )
    if (u >= t.length) {
      o++;
      break;
    }
  var l = t.slice(2, u - 1);
  if ((n.toString("hex") !== "0002" && !a || n.toString("hex") !== "0001" && a) && o++, l.length < 8 && o++, o)
    throw new Error("decryption error");
  return t.slice(u);
}
function compare(e, t) {
  e = Buffer$1.from(e), t = Buffer$1.from(t);
  var a = 0, n = e.length;
  e.length !== t.length && (a++, n = Math.min(e.length, t.length));
  for (var u = -1; ++u < n; )
    a += e[u] ^ t[u];
  return a;
}
(function(e) {
  e.publicEncrypt = publicEncrypt, e.privateDecrypt = privateDecrypt, e.privateEncrypt = function(a, n) {
    return e.publicEncrypt(a, n, !0);
  }, e.publicDecrypt = function(a, n) {
    return e.privateDecrypt(a, n, !0);
  };
})(browser$1);
var browser = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$2, randombytes = browserExports, Buffer = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(e, t) {
  if (typeof e != "number" || e !== e)
    throw new TypeError("offset must be a number");
  if (e > kMaxUint32 || e < 0)
    throw new TypeError("offset must be a uint32");
  if (e > kBufferMaxLength || e > t)
    throw new RangeError("offset out of range");
}
function assertSize(e, t, a) {
  if (typeof e != "number" || e !== e)
    throw new TypeError("size must be a number");
  if (e > kMaxUint32 || e < 0)
    throw new TypeError("size must be a uint32");
  if (e + t > a || e > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$2 && crypto$2.getRandomValues || !api$2.browser ? (browser.randomFill = randomFill, browser.randomFillSync = randomFillSync) : (browser.randomFill = oldBrowser, browser.randomFillSync = oldBrowser);
function randomFill(e, t, a, n) {
  if (!Buffer.isBuffer(e) && !(e instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof t == "function")
    n = t, t = 0, a = e.length;
  else if (typeof a == "function")
    n = a, a = e.length - t;
  else if (typeof n != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(t, e.length), assertSize(a, t, e.length), actualFill(e, t, a, n);
}
function actualFill(e, t, a, n) {
  if (api$2.browser) {
    var u = e.buffer, o = new Uint8Array(u, t, a);
    if (crypto$2.getRandomValues(o), n) {
      api$2.nextTick(function() {
        n(null, e);
      });
      return;
    }
    return e;
  }
  if (n) {
    randombytes(a, function(h, y) {
      if (h)
        return n(h);
      y.copy(e, t), n(null, e);
    });
    return;
  }
  var l = randombytes(a);
  return l.copy(e, t), e;
}
function randomFillSync(e, t, a) {
  if (typeof t > "u" && (t = 0), !Buffer.isBuffer(e) && !(e instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(t, e.length), a === void 0 && (a = e.length - t), assertSize(a, t, e.length), actualFill(e, t, a);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$9, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$8;
  var e = algos, t = Object.keys(e), a = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(t);
  cryptoBrowserify.getHashes = function() {
    return a;
  };
  var n = browser$7;
  cryptoBrowserify.pbkdf2 = n.pbkdf2, cryptoBrowserify.pbkdf2Sync = n.pbkdf2Sync;
  var u = browser$6;
  cryptoBrowserify.Cipher = u.Cipher, cryptoBrowserify.createCipher = u.createCipher, cryptoBrowserify.Cipheriv = u.Cipheriv, cryptoBrowserify.createCipheriv = u.createCipheriv, cryptoBrowserify.Decipher = u.Decipher, cryptoBrowserify.createDecipher = u.createDecipher, cryptoBrowserify.Decipheriv = u.Decipheriv, cryptoBrowserify.createDecipheriv = u.createDecipheriv, cryptoBrowserify.getCiphers = u.getCiphers, cryptoBrowserify.listCiphers = u.listCiphers;
  var o = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = o.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = o.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = o.getDiffieHellman, cryptoBrowserify.createDiffieHellman = o.createDiffieHellman, cryptoBrowserify.DiffieHellman = o.DiffieHellman;
  var l = requireBrowser$1();
  cryptoBrowserify.createSign = l.createSign, cryptoBrowserify.Sign = l.Sign, cryptoBrowserify.createVerify = l.createVerify, cryptoBrowserify.Verify = l.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var h = browser$1;
  cryptoBrowserify.publicEncrypt = h.publicEncrypt, cryptoBrowserify.privateEncrypt = h.privateEncrypt, cryptoBrowserify.publicDecrypt = h.publicDecrypt, cryptoBrowserify.privateDecrypt = h.privateDecrypt;
  var y = browser;
  return cryptoBrowserify.randomFill = y.randomFill, cryptoBrowserify.randomFillSync = y.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
var cryptoBrowserifyExports = requireCryptoBrowserify();
const crypto$1 = /* @__PURE__ */ getDefaultExportFromCjs(cryptoBrowserifyExports), zero = new BigInteger$5(0);
function invariant(e, t) {
  if (!e)
    throw new Error(t);
}
function padTo(e, t) {
  invariant(buffer$1.Buffer.isBuffer(e), "Type error: n must be a buffer");
  const a = t - e.length;
  invariant(a > -1, "Negative padding.  Very uncomfortable.");
  const n = buffer$1.Buffer.alloc(t);
  return n.fill(0, 0, a), e.copy(n, a), invariant(n.length === t, "Padding failed"), n;
}
function padToN(e, t) {
  return invariant(e.bigNum === !0), padTo(e.toBuffer(), t.N_length_bits / 8);
}
function getx(e, t, a, n) {
  invariant(buffer$1.Buffer.isBuffer(t), "Type error: salt (salt) must be a buffer"), invariant(buffer$1.Buffer.isBuffer(a), "Type error: identity (I) must be a buffer"), invariant(buffer$1.Buffer.isBuffer(n), "Type error: password (P) must be a buffer");
  const u = buffer$1.Buffer.from(
    cryptoBrowserifyExports.createHash(e.hash).update(buffer$1.Buffer.concat([a, buffer$1.Buffer.from(":"), n])).digest()
  ), o = buffer$1.Buffer.from(
    cryptoBrowserifyExports.createHash(e.hash).update(t).update(u).digest()
  );
  return BigInteger$5.fromBuffer(o);
}
function computeVerifier(e, t, a, n) {
  invariant(buffer$1.Buffer.isBuffer(t), "Type error: salt (salt) must be a buffer"), invariant(buffer$1.Buffer.isBuffer(a), "Type error: identity (I) must be a buffer"), invariant(buffer$1.Buffer.isBuffer(n), "Type error: password (P) must be a buffer");
  const u = e.g.powm(getx(e, t, a, n), e.N);
  return padToN(u, e);
}
function getk(e) {
  const t = cryptoBrowserifyExports.createHash(e.hash).update(padToN(e.N, e)).update(padToN(e.g, e)).digest();
  return BigInteger$5.fromBuffer(t);
}
async function genKey(e = 32) {
  return new Promise((t, a) => {
    cryptoBrowserifyExports.randomBytes(e, function(n, u) {
      n && a(n), t(buffer$1.Buffer.from(u));
    });
  });
}
function getB(e, t, a, n) {
  invariant(a.bigNum === !0), invariant(t.bigNum === !0), invariant(n.bigNum === !0);
  var u = e.N, o = t.mul(a).add(e.g.powm(n, u)).mod(u);
  return padToN(o, e);
}
function getA(e, t) {
  return invariant(t.bigNum === !0), Math.ceil(t.bitLength() / 8) < 256 / 8 && console.warn(
    "getA: client key length",
    t.bitLength(),
    "is less than the recommended 256"
  ), padToN(e.g.powm(t, e.N), e);
}
function getu(e, t, a) {
  invariant(buffer$1.Buffer.isBuffer(t), "Type error: A must be a buffer"), invariant(
    t.length === e.N_length_bits / 8,
    "A was " + t.length + ", expected " + e.N_length_bits / 8
  ), invariant(buffer$1.Buffer.isBuffer(a), "Type error: B must be a buffer"), invariant(
    a.length === e.N_length_bits / 8,
    "B was " + a.length + ", expected " + e.N_length_bits / 8
  );
  const n = cryptoBrowserifyExports.createHash(e.hash).update(t).update(a).digest();
  return BigInteger$5.fromBuffer(n);
}
function client_getS(e, t, a, n, u, o) {
  invariant(t.bigNum === !0), invariant(a.bigNum === !0), invariant(n.bigNum === !0), invariant(u.bigNum === !0), invariant(o.bigNum === !0);
  const { g: l, N: h } = e;
  if (zero.ge(u) || h.le(u))
    throw new Error("invalid server-supplied 'B', must be 1..N-1");
  const y = u.sub(t.mul(l.powm(a, h))).powm(n.add(o.mul(a)), h).mod(h);
  return padToN(y, e);
}
function server_getS(e, t, a, n, u) {
  invariant(t.bigNum === !0), invariant(a.bigNum === !0), invariant(n.bigNum === !0), invariant(u.bigNum === !0);
  const { N: o } = e;
  if (zero.ge(a) || o.le(a))
    throw new Error("invalid client-supplied 'A', must be 1..N-1");
  const l = a.mul(t.powm(u, o)).powm(n, o).mod(o);
  return padToN(l, e);
}
function getK(e, t) {
  return invariant(buffer$1.Buffer.isBuffer(t), "Type error: S must be a buffer"), invariant(
    t.length === e.N_length_bits / 8,
    "S was " + t.length + ", expected " + e.N_length_bits / 8
  ), buffer$1.Buffer.from(cryptoBrowserifyExports.createHash(e.hash).update(t).digest());
}
function getM1(e, t, a, n) {
  return invariant(buffer$1.Buffer.isBuffer(t), "Type error: A must be a buffer"), invariant(
    t.length === e.N_length_bits / 8,
    "A was " + t.length + ", expected " + e.N_length_bits / 8
  ), invariant(buffer$1.Buffer.isBuffer(a), "Type error: B must be a buffer"), invariant(
    a.length === e.N_length_bits / 8,
    "B was " + a.length + ", expected " + e.N_length_bits / 8
  ), invariant(buffer$1.Buffer.isBuffer(n), "Type error: S must be a buffer"), invariant(
    n.length === e.N_length_bits / 8,
    "S was " + n.length + ", expected " + e.N_length_bits / 8
  ), buffer$1.Buffer.from(
    cryptoBrowserifyExports.createHash(e.hash).update(t).update(a).update(n).digest()
  );
}
function getM2(e, t, a, n) {
  return invariant(buffer$1.Buffer.isBuffer(t), "Type error: A must be a buffer"), invariant(
    t.length === e.N_length_bits / 8,
    "A was " + t.length + ", expected " + e.N_length_bits / 8
  ), invariant(buffer$1.Buffer.isBuffer(a), "Type error: M must be a buffer"), invariant(buffer$1.Buffer.isBuffer(n), "Type error: K must be a buffer"), buffer$1.Buffer.from(
    cryptoBrowserifyExports.createHash(e.hash).update(t).update(a).update(n).digest()
  );
}
function equal(e, t) {
  var a = e.length - t.length;
  if (a)
    return !1;
  for (var n = 0; n < e.length; n++)
    a |= e[n] ^ t[n];
  return a === 0;
}
class Client {
  constructor(t, a, n, u, o) {
    invariant(
      buffer$1.Buffer.isBuffer(a),
      "Type error: salt (salt) must be a buffer"
    ), invariant(
      buffer$1.Buffer.isBuffer(n),
      "Type error: identity (I) must be a buffer"
    ), invariant(
      buffer$1.Buffer.isBuffer(u),
      "Type error: password (P) must be a buffer"
    ), invariant(
      buffer$1.Buffer.isBuffer(o),
      "Type error: secret1 must be a buffer"
    );
    const l = BigInteger$5.fromBuffer(o);
    this._private = {
      params: t,
      k_num: getk(t),
      x_num: getx(t, a, n, u),
      a_num: l,
      A_buf: getA(t, l)
    };
  }
  computeA() {
    return this._private.A_buf;
  }
  setB(t) {
    var a = this._private, n = BigInteger$5.fromBuffer(t), u = getu(a.params, a.A_buf, t), o = client_getS(a.params, a.k_num, a.x_num, a.a_num, n, u);
    a.K_buf = getK(a.params, o), a.M1_buf = getM1(a.params, a.A_buf, t, o), a.M2_buf = getM2(a.params, a.A_buf, a.M1_buf, a.K_buf), a.u_num = u, a.S_buf = o;
  }
  computeM1() {
    return invariant(
      typeof this._private.M1_buf < "u",
      "incomplete protocol"
    ), this._private.M1_buf;
  }
  checkM2(t) {
    invariant(
      typeof this._private.M2_buf < "u" && equal(this._private.M2_buf, t),
      "M2 didn't check"
    );
  }
  computeK() {
    return invariant(
      typeof this._private.K_buf < "u",
      "incomplete protocol"
    ), this._private.K_buf;
  }
}
class Server {
  constructor(t, a, n) {
    invariant(
      buffer$1.Buffer.isBuffer(a),
      "Type error: verifier must be a buffer"
    ), invariant(
      buffer$1.Buffer.isBuffer(n),
      "Type error: secret2 must be a buffer"
    );
    const u = getk(t), o = BigInteger$5.fromBuffer(n), l = BigInteger$5.fromBuffer(a);
    this._private = {
      params: t,
      k_num: u,
      b_num: o,
      v_num: l,
      B_buf: getB(t, u, l, o)
    };
  }
  computeB() {
    return this._private.B_buf;
  }
  setA(t) {
    const a = this._private, n = BigInteger$5.fromBuffer(t), u = getu(a.params, t, a.B_buf), o = server_getS(a.params, a.v_num, n, a.b_num, u);
    a.K_buf = getK(a.params, o), a.M1_buf = getM1(a.params, t, a.B_buf, o), a.M2_buf = getM2(a.params, t, a.M1_buf, a.K_buf), a.u_num = u, a.S_buf = o;
  }
  checkM1(t) {
    return invariant(
      typeof this._private.M1_buf < "u",
      "incomplete protocol"
    ), invariant(
      equal(this._private.M1_buf, t),
      "client did not use the same password"
    ), this._private.M2_buf;
  }
  computeK() {
    return invariant(
      typeof this._private.K_buf < "u",
      "incomplete protocol"
    ), this._private.K_buf;
  }
}
async function decodeBase64(e) {
  let t = "data:application/octet-binary;base64,";
  t += e;
  const n = await (await fetch(t)).arrayBuffer();
  return new Uint8Array(n);
}
async function encodeBase64(e) {
  const t = await new Promise((n, u) => {
    const o = new FileReader();
    o.onload = () => {
      typeof o.result == "string" ? n(o.result) : u();
    }, o.onerror = u, o.readAsDataURL(new Blob([e]));
  }), a = t.indexOf(",");
  if (a === -1)
    throw new Error(`unexpected data uri output: ${t}`);
  return t.slice(a + 1);
}
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
(function(e) {
  (function(t) {
    var a = function(J) {
      var ae, ue = new Float64Array(16);
      if (J)
        for (ae = 0; ae < J.length; ae++)
          ue[ae] = J[ae];
      return ue;
    }, n = function() {
      throw new Error("no PRNG");
    }, u = new Uint8Array(16), o = new Uint8Array(32);
    o[0] = 9;
    var l = a(), h = a([1]), y = a([56129, 1]), _ = a([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), d = a([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), $ = a([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), N = a([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), U = a([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function V(J, ae, ue, q) {
      J[ae] = ue >> 24 & 255, J[ae + 1] = ue >> 16 & 255, J[ae + 2] = ue >> 8 & 255, J[ae + 3] = ue & 255, J[ae + 4] = q >> 24 & 255, J[ae + 5] = q >> 16 & 255, J[ae + 6] = q >> 8 & 255, J[ae + 7] = q & 255;
    }
    function Q(J, ae, ue, q, le) {
      var Ce, Se = 0;
      for (Ce = 0; Ce < le; Ce++)
        Se |= J[ae + Ce] ^ ue[q + Ce];
      return (1 & Se - 1 >>> 8) - 1;
    }
    function ie(J, ae, ue, q) {
      return Q(J, ae, ue, q, 16);
    }
    function ee(J, ae, ue, q) {
      return Q(J, ae, ue, q, 32);
    }
    function ne(J, ae, ue, q) {
      for (var le = q[0] & 255 | (q[1] & 255) << 8 | (q[2] & 255) << 16 | (q[3] & 255) << 24, Ce = ue[0] & 255 | (ue[1] & 255) << 8 | (ue[2] & 255) << 16 | (ue[3] & 255) << 24, Se = ue[4] & 255 | (ue[5] & 255) << 8 | (ue[6] & 255) << 16 | (ue[7] & 255) << 24, Ie = ue[8] & 255 | (ue[9] & 255) << 8 | (ue[10] & 255) << 16 | (ue[11] & 255) << 24, Ve = ue[12] & 255 | (ue[13] & 255) << 8 | (ue[14] & 255) << 16 | (ue[15] & 255) << 24, Ge = q[4] & 255 | (q[5] & 255) << 8 | (q[6] & 255) << 16 | (q[7] & 255) << 24, qe = ae[0] & 255 | (ae[1] & 255) << 8 | (ae[2] & 255) << 16 | (ae[3] & 255) << 24, Nt = ae[4] & 255 | (ae[5] & 255) << 8 | (ae[6] & 255) << 16 | (ae[7] & 255) << 24, et = ae[8] & 255 | (ae[9] & 255) << 8 | (ae[10] & 255) << 16 | (ae[11] & 255) << 24, _t = ae[12] & 255 | (ae[13] & 255) << 8 | (ae[14] & 255) << 16 | (ae[15] & 255) << 24, $t = q[8] & 255 | (q[9] & 255) << 8 | (q[10] & 255) << 16 | (q[11] & 255) << 24, St = ue[16] & 255 | (ue[17] & 255) << 8 | (ue[18] & 255) << 16 | (ue[19] & 255) << 24, mt = ue[20] & 255 | (ue[21] & 255) << 8 | (ue[22] & 255) << 16 | (ue[23] & 255) << 24, xt = ue[24] & 255 | (ue[25] & 255) << 8 | (ue[26] & 255) << 16 | (ue[27] & 255) << 24, Et = ue[28] & 255 | (ue[29] & 255) << 8 | (ue[30] & 255) << 16 | (ue[31] & 255) << 24, wt = q[12] & 255 | (q[13] & 255) << 8 | (q[14] & 255) << 16 | (q[15] & 255) << 24, tt = le, ht = Ce, Je = Se, it = Ie, nt = Ve, Ze = Ge, Me = qe, De = Nt, ze = et, Ue = _t, Ke = $t, We = St, ct = mt, Lt = xt, Ft = Et, At = wt, $e, Ot = 0; Ot < 20; Ot += 2)
        $e = tt + ct | 0, nt ^= $e << 7 | $e >>> 32 - 7, $e = nt + tt | 0, ze ^= $e << 9 | $e >>> 32 - 9, $e = ze + nt | 0, ct ^= $e << 13 | $e >>> 32 - 13, $e = ct + ze | 0, tt ^= $e << 18 | $e >>> 32 - 18, $e = Ze + ht | 0, Ue ^= $e << 7 | $e >>> 32 - 7, $e = Ue + Ze | 0, Lt ^= $e << 9 | $e >>> 32 - 9, $e = Lt + Ue | 0, ht ^= $e << 13 | $e >>> 32 - 13, $e = ht + Lt | 0, Ze ^= $e << 18 | $e >>> 32 - 18, $e = Ke + Me | 0, Ft ^= $e << 7 | $e >>> 32 - 7, $e = Ft + Ke | 0, Je ^= $e << 9 | $e >>> 32 - 9, $e = Je + Ft | 0, Me ^= $e << 13 | $e >>> 32 - 13, $e = Me + Je | 0, Ke ^= $e << 18 | $e >>> 32 - 18, $e = At + We | 0, it ^= $e << 7 | $e >>> 32 - 7, $e = it + At | 0, De ^= $e << 9 | $e >>> 32 - 9, $e = De + it | 0, We ^= $e << 13 | $e >>> 32 - 13, $e = We + De | 0, At ^= $e << 18 | $e >>> 32 - 18, $e = tt + it | 0, ht ^= $e << 7 | $e >>> 32 - 7, $e = ht + tt | 0, Je ^= $e << 9 | $e >>> 32 - 9, $e = Je + ht | 0, it ^= $e << 13 | $e >>> 32 - 13, $e = it + Je | 0, tt ^= $e << 18 | $e >>> 32 - 18, $e = Ze + nt | 0, Me ^= $e << 7 | $e >>> 32 - 7, $e = Me + Ze | 0, De ^= $e << 9 | $e >>> 32 - 9, $e = De + Me | 0, nt ^= $e << 13 | $e >>> 32 - 13, $e = nt + De | 0, Ze ^= $e << 18 | $e >>> 32 - 18, $e = Ke + Ue | 0, We ^= $e << 7 | $e >>> 32 - 7, $e = We + Ke | 0, ze ^= $e << 9 | $e >>> 32 - 9, $e = ze + We | 0, Ue ^= $e << 13 | $e >>> 32 - 13, $e = Ue + ze | 0, Ke ^= $e << 18 | $e >>> 32 - 18, $e = At + Ft | 0, ct ^= $e << 7 | $e >>> 32 - 7, $e = ct + At | 0, Lt ^= $e << 9 | $e >>> 32 - 9, $e = Lt + ct | 0, Ft ^= $e << 13 | $e >>> 32 - 13, $e = Ft + Lt | 0, At ^= $e << 18 | $e >>> 32 - 18;
      tt = tt + le | 0, ht = ht + Ce | 0, Je = Je + Se | 0, it = it + Ie | 0, nt = nt + Ve | 0, Ze = Ze + Ge | 0, Me = Me + qe | 0, De = De + Nt | 0, ze = ze + et | 0, Ue = Ue + _t | 0, Ke = Ke + $t | 0, We = We + St | 0, ct = ct + mt | 0, Lt = Lt + xt | 0, Ft = Ft + Et | 0, At = At + wt | 0, J[0] = tt >>> 0 & 255, J[1] = tt >>> 8 & 255, J[2] = tt >>> 16 & 255, J[3] = tt >>> 24 & 255, J[4] = ht >>> 0 & 255, J[5] = ht >>> 8 & 255, J[6] = ht >>> 16 & 255, J[7] = ht >>> 24 & 255, J[8] = Je >>> 0 & 255, J[9] = Je >>> 8 & 255, J[10] = Je >>> 16 & 255, J[11] = Je >>> 24 & 255, J[12] = it >>> 0 & 255, J[13] = it >>> 8 & 255, J[14] = it >>> 16 & 255, J[15] = it >>> 24 & 255, J[16] = nt >>> 0 & 255, J[17] = nt >>> 8 & 255, J[18] = nt >>> 16 & 255, J[19] = nt >>> 24 & 255, J[20] = Ze >>> 0 & 255, J[21] = Ze >>> 8 & 255, J[22] = Ze >>> 16 & 255, J[23] = Ze >>> 24 & 255, J[24] = Me >>> 0 & 255, J[25] = Me >>> 8 & 255, J[26] = Me >>> 16 & 255, J[27] = Me >>> 24 & 255, J[28] = De >>> 0 & 255, J[29] = De >>> 8 & 255, J[30] = De >>> 16 & 255, J[31] = De >>> 24 & 255, J[32] = ze >>> 0 & 255, J[33] = ze >>> 8 & 255, J[34] = ze >>> 16 & 255, J[35] = ze >>> 24 & 255, J[36] = Ue >>> 0 & 255, J[37] = Ue >>> 8 & 255, J[38] = Ue >>> 16 & 255, J[39] = Ue >>> 24 & 255, J[40] = Ke >>> 0 & 255, J[41] = Ke >>> 8 & 255, J[42] = Ke >>> 16 & 255, J[43] = Ke >>> 24 & 255, J[44] = We >>> 0 & 255, J[45] = We >>> 8 & 255, J[46] = We >>> 16 & 255, J[47] = We >>> 24 & 255, J[48] = ct >>> 0 & 255, J[49] = ct >>> 8 & 255, J[50] = ct >>> 16 & 255, J[51] = ct >>> 24 & 255, J[52] = Lt >>> 0 & 255, J[53] = Lt >>> 8 & 255, J[54] = Lt >>> 16 & 255, J[55] = Lt >>> 24 & 255, J[56] = Ft >>> 0 & 255, J[57] = Ft >>> 8 & 255, J[58] = Ft >>> 16 & 255, J[59] = Ft >>> 24 & 255, J[60] = At >>> 0 & 255, J[61] = At >>> 8 & 255, J[62] = At >>> 16 & 255, J[63] = At >>> 24 & 255;
    }
    function ge(J, ae, ue, q) {
      for (var le = q[0] & 255 | (q[1] & 255) << 8 | (q[2] & 255) << 16 | (q[3] & 255) << 24, Ce = ue[0] & 255 | (ue[1] & 255) << 8 | (ue[2] & 255) << 16 | (ue[3] & 255) << 24, Se = ue[4] & 255 | (ue[5] & 255) << 8 | (ue[6] & 255) << 16 | (ue[7] & 255) << 24, Ie = ue[8] & 255 | (ue[9] & 255) << 8 | (ue[10] & 255) << 16 | (ue[11] & 255) << 24, Ve = ue[12] & 255 | (ue[13] & 255) << 8 | (ue[14] & 255) << 16 | (ue[15] & 255) << 24, Ge = q[4] & 255 | (q[5] & 255) << 8 | (q[6] & 255) << 16 | (q[7] & 255) << 24, qe = ae[0] & 255 | (ae[1] & 255) << 8 | (ae[2] & 255) << 16 | (ae[3] & 255) << 24, Nt = ae[4] & 255 | (ae[5] & 255) << 8 | (ae[6] & 255) << 16 | (ae[7] & 255) << 24, et = ae[8] & 255 | (ae[9] & 255) << 8 | (ae[10] & 255) << 16 | (ae[11] & 255) << 24, _t = ae[12] & 255 | (ae[13] & 255) << 8 | (ae[14] & 255) << 16 | (ae[15] & 255) << 24, $t = q[8] & 255 | (q[9] & 255) << 8 | (q[10] & 255) << 16 | (q[11] & 255) << 24, St = ue[16] & 255 | (ue[17] & 255) << 8 | (ue[18] & 255) << 16 | (ue[19] & 255) << 24, mt = ue[20] & 255 | (ue[21] & 255) << 8 | (ue[22] & 255) << 16 | (ue[23] & 255) << 24, xt = ue[24] & 255 | (ue[25] & 255) << 8 | (ue[26] & 255) << 16 | (ue[27] & 255) << 24, Et = ue[28] & 255 | (ue[29] & 255) << 8 | (ue[30] & 255) << 16 | (ue[31] & 255) << 24, wt = q[12] & 255 | (q[13] & 255) << 8 | (q[14] & 255) << 16 | (q[15] & 255) << 24, tt = le, ht = Ce, Je = Se, it = Ie, nt = Ve, Ze = Ge, Me = qe, De = Nt, ze = et, Ue = _t, Ke = $t, We = St, ct = mt, Lt = xt, Ft = Et, At = wt, $e, Ot = 0; Ot < 20; Ot += 2)
        $e = tt + ct | 0, nt ^= $e << 7 | $e >>> 32 - 7, $e = nt + tt | 0, ze ^= $e << 9 | $e >>> 32 - 9, $e = ze + nt | 0, ct ^= $e << 13 | $e >>> 32 - 13, $e = ct + ze | 0, tt ^= $e << 18 | $e >>> 32 - 18, $e = Ze + ht | 0, Ue ^= $e << 7 | $e >>> 32 - 7, $e = Ue + Ze | 0, Lt ^= $e << 9 | $e >>> 32 - 9, $e = Lt + Ue | 0, ht ^= $e << 13 | $e >>> 32 - 13, $e = ht + Lt | 0, Ze ^= $e << 18 | $e >>> 32 - 18, $e = Ke + Me | 0, Ft ^= $e << 7 | $e >>> 32 - 7, $e = Ft + Ke | 0, Je ^= $e << 9 | $e >>> 32 - 9, $e = Je + Ft | 0, Me ^= $e << 13 | $e >>> 32 - 13, $e = Me + Je | 0, Ke ^= $e << 18 | $e >>> 32 - 18, $e = At + We | 0, it ^= $e << 7 | $e >>> 32 - 7, $e = it + At | 0, De ^= $e << 9 | $e >>> 32 - 9, $e = De + it | 0, We ^= $e << 13 | $e >>> 32 - 13, $e = We + De | 0, At ^= $e << 18 | $e >>> 32 - 18, $e = tt + it | 0, ht ^= $e << 7 | $e >>> 32 - 7, $e = ht + tt | 0, Je ^= $e << 9 | $e >>> 32 - 9, $e = Je + ht | 0, it ^= $e << 13 | $e >>> 32 - 13, $e = it + Je | 0, tt ^= $e << 18 | $e >>> 32 - 18, $e = Ze + nt | 0, Me ^= $e << 7 | $e >>> 32 - 7, $e = Me + Ze | 0, De ^= $e << 9 | $e >>> 32 - 9, $e = De + Me | 0, nt ^= $e << 13 | $e >>> 32 - 13, $e = nt + De | 0, Ze ^= $e << 18 | $e >>> 32 - 18, $e = Ke + Ue | 0, We ^= $e << 7 | $e >>> 32 - 7, $e = We + Ke | 0, ze ^= $e << 9 | $e >>> 32 - 9, $e = ze + We | 0, Ue ^= $e << 13 | $e >>> 32 - 13, $e = Ue + ze | 0, Ke ^= $e << 18 | $e >>> 32 - 18, $e = At + Ft | 0, ct ^= $e << 7 | $e >>> 32 - 7, $e = ct + At | 0, Lt ^= $e << 9 | $e >>> 32 - 9, $e = Lt + ct | 0, Ft ^= $e << 13 | $e >>> 32 - 13, $e = Ft + Lt | 0, At ^= $e << 18 | $e >>> 32 - 18;
      J[0] = tt >>> 0 & 255, J[1] = tt >>> 8 & 255, J[2] = tt >>> 16 & 255, J[3] = tt >>> 24 & 255, J[4] = Ze >>> 0 & 255, J[5] = Ze >>> 8 & 255, J[6] = Ze >>> 16 & 255, J[7] = Ze >>> 24 & 255, J[8] = Ke >>> 0 & 255, J[9] = Ke >>> 8 & 255, J[10] = Ke >>> 16 & 255, J[11] = Ke >>> 24 & 255, J[12] = At >>> 0 & 255, J[13] = At >>> 8 & 255, J[14] = At >>> 16 & 255, J[15] = At >>> 24 & 255, J[16] = Me >>> 0 & 255, J[17] = Me >>> 8 & 255, J[18] = Me >>> 16 & 255, J[19] = Me >>> 24 & 255, J[20] = De >>> 0 & 255, J[21] = De >>> 8 & 255, J[22] = De >>> 16 & 255, J[23] = De >>> 24 & 255, J[24] = ze >>> 0 & 255, J[25] = ze >>> 8 & 255, J[26] = ze >>> 16 & 255, J[27] = ze >>> 24 & 255, J[28] = Ue >>> 0 & 255, J[29] = Ue >>> 8 & 255, J[30] = Ue >>> 16 & 255, J[31] = Ue >>> 24 & 255;
    }
    function be(J, ae, ue, q) {
      ne(J, ae, ue, q);
    }
    function Ee(J, ae, ue, q) {
      ge(J, ae, ue, q);
    }
    var xe = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function Le(J, ae, ue, q, le, Ce, Se) {
      var Ie = new Uint8Array(16), Ve = new Uint8Array(64), Ge, qe;
      for (qe = 0; qe < 16; qe++)
        Ie[qe] = 0;
      for (qe = 0; qe < 8; qe++)
        Ie[qe] = Ce[qe];
      for (; le >= 64; ) {
        for (be(Ve, Ie, Se, xe), qe = 0; qe < 64; qe++)
          J[ae + qe] = ue[q + qe] ^ Ve[qe];
        for (Ge = 1, qe = 8; qe < 16; qe++)
          Ge = Ge + (Ie[qe] & 255) | 0, Ie[qe] = Ge & 255, Ge >>>= 8;
        le -= 64, ae += 64, q += 64;
      }
      if (le > 0)
        for (be(Ve, Ie, Se, xe), qe = 0; qe < le; qe++)
          J[ae + qe] = ue[q + qe] ^ Ve[qe];
      return 0;
    }
    function Ne(J, ae, ue, q, le) {
      var Ce = new Uint8Array(16), Se = new Uint8Array(64), Ie, Ve;
      for (Ve = 0; Ve < 16; Ve++)
        Ce[Ve] = 0;
      for (Ve = 0; Ve < 8; Ve++)
        Ce[Ve] = q[Ve];
      for (; ue >= 64; ) {
        for (be(Se, Ce, le, xe), Ve = 0; Ve < 64; Ve++)
          J[ae + Ve] = Se[Ve];
        for (Ie = 1, Ve = 8; Ve < 16; Ve++)
          Ie = Ie + (Ce[Ve] & 255) | 0, Ce[Ve] = Ie & 255, Ie >>>= 8;
        ue -= 64, ae += 64;
      }
      if (ue > 0)
        for (be(Se, Ce, le, xe), Ve = 0; Ve < ue; Ve++)
          J[ae + Ve] = Se[Ve];
      return 0;
    }
    function Re(J, ae, ue, q, le) {
      var Ce = new Uint8Array(32);
      Ee(Ce, q, le, xe);
      for (var Se = new Uint8Array(8), Ie = 0; Ie < 8; Ie++)
        Se[Ie] = q[Ie + 16];
      return Ne(J, ae, ue, Se, Ce);
    }
    function Xe(J, ae, ue, q, le, Ce, Se) {
      var Ie = new Uint8Array(32);
      Ee(Ie, Ce, Se, xe);
      for (var Ve = new Uint8Array(8), Ge = 0; Ge < 8; Ge++)
        Ve[Ge] = Ce[Ge + 16];
      return Le(J, ae, ue, q, le, Ve, Ie);
    }
    var pe = function(J) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var ae, ue, q, le, Ce, Se, Ie, Ve;
      ae = J[0] & 255 | (J[1] & 255) << 8, this.r[0] = ae & 8191, ue = J[2] & 255 | (J[3] & 255) << 8, this.r[1] = (ae >>> 13 | ue << 3) & 8191, q = J[4] & 255 | (J[5] & 255) << 8, this.r[2] = (ue >>> 10 | q << 6) & 7939, le = J[6] & 255 | (J[7] & 255) << 8, this.r[3] = (q >>> 7 | le << 9) & 8191, Ce = J[8] & 255 | (J[9] & 255) << 8, this.r[4] = (le >>> 4 | Ce << 12) & 255, this.r[5] = Ce >>> 1 & 8190, Se = J[10] & 255 | (J[11] & 255) << 8, this.r[6] = (Ce >>> 14 | Se << 2) & 8191, Ie = J[12] & 255 | (J[13] & 255) << 8, this.r[7] = (Se >>> 11 | Ie << 5) & 8065, Ve = J[14] & 255 | (J[15] & 255) << 8, this.r[8] = (Ie >>> 8 | Ve << 8) & 8191, this.r[9] = Ve >>> 5 & 127, this.pad[0] = J[16] & 255 | (J[17] & 255) << 8, this.pad[1] = J[18] & 255 | (J[19] & 255) << 8, this.pad[2] = J[20] & 255 | (J[21] & 255) << 8, this.pad[3] = J[22] & 255 | (J[23] & 255) << 8, this.pad[4] = J[24] & 255 | (J[25] & 255) << 8, this.pad[5] = J[26] & 255 | (J[27] & 255) << 8, this.pad[6] = J[28] & 255 | (J[29] & 255) << 8, this.pad[7] = J[30] & 255 | (J[31] & 255) << 8;
    };
    pe.prototype.blocks = function(J, ae, ue) {
      for (var q = this.fin ? 0 : 2048, le, Ce, Se, Ie, Ve, Ge, qe, Nt, et, _t, $t, St, mt, xt, Et, wt, tt, ht, Je, it = this.h[0], nt = this.h[1], Ze = this.h[2], Me = this.h[3], De = this.h[4], ze = this.h[5], Ue = this.h[6], Ke = this.h[7], We = this.h[8], ct = this.h[9], Lt = this.r[0], Ft = this.r[1], At = this.r[2], $e = this.r[3], Ot = this.r[4], jt = this.r[5], Gt = this.r[6], Ut = this.r[7], qt = this.r[8], Kt = this.r[9]; ue >= 16; )
        le = J[ae + 0] & 255 | (J[ae + 1] & 255) << 8, it += le & 8191, Ce = J[ae + 2] & 255 | (J[ae + 3] & 255) << 8, nt += (le >>> 13 | Ce << 3) & 8191, Se = J[ae + 4] & 255 | (J[ae + 5] & 255) << 8, Ze += (Ce >>> 10 | Se << 6) & 8191, Ie = J[ae + 6] & 255 | (J[ae + 7] & 255) << 8, Me += (Se >>> 7 | Ie << 9) & 8191, Ve = J[ae + 8] & 255 | (J[ae + 9] & 255) << 8, De += (Ie >>> 4 | Ve << 12) & 8191, ze += Ve >>> 1 & 8191, Ge = J[ae + 10] & 255 | (J[ae + 11] & 255) << 8, Ue += (Ve >>> 14 | Ge << 2) & 8191, qe = J[ae + 12] & 255 | (J[ae + 13] & 255) << 8, Ke += (Ge >>> 11 | qe << 5) & 8191, Nt = J[ae + 14] & 255 | (J[ae + 15] & 255) << 8, We += (qe >>> 8 | Nt << 8) & 8191, ct += Nt >>> 5 | q, et = 0, _t = et, _t += it * Lt, _t += nt * (5 * Kt), _t += Ze * (5 * qt), _t += Me * (5 * Ut), _t += De * (5 * Gt), et = _t >>> 13, _t &= 8191, _t += ze * (5 * jt), _t += Ue * (5 * Ot), _t += Ke * (5 * $e), _t += We * (5 * At), _t += ct * (5 * Ft), et += _t >>> 13, _t &= 8191, $t = et, $t += it * Ft, $t += nt * Lt, $t += Ze * (5 * Kt), $t += Me * (5 * qt), $t += De * (5 * Ut), et = $t >>> 13, $t &= 8191, $t += ze * (5 * Gt), $t += Ue * (5 * jt), $t += Ke * (5 * Ot), $t += We * (5 * $e), $t += ct * (5 * At), et += $t >>> 13, $t &= 8191, St = et, St += it * At, St += nt * Ft, St += Ze * Lt, St += Me * (5 * Kt), St += De * (5 * qt), et = St >>> 13, St &= 8191, St += ze * (5 * Ut), St += Ue * (5 * Gt), St += Ke * (5 * jt), St += We * (5 * Ot), St += ct * (5 * $e), et += St >>> 13, St &= 8191, mt = et, mt += it * $e, mt += nt * At, mt += Ze * Ft, mt += Me * Lt, mt += De * (5 * Kt), et = mt >>> 13, mt &= 8191, mt += ze * (5 * qt), mt += Ue * (5 * Ut), mt += Ke * (5 * Gt), mt += We * (5 * jt), mt += ct * (5 * Ot), et += mt >>> 13, mt &= 8191, xt = et, xt += it * Ot, xt += nt * $e, xt += Ze * At, xt += Me * Ft, xt += De * Lt, et = xt >>> 13, xt &= 8191, xt += ze * (5 * Kt), xt += Ue * (5 * qt), xt += Ke * (5 * Ut), xt += We * (5 * Gt), xt += ct * (5 * jt), et += xt >>> 13, xt &= 8191, Et = et, Et += it * jt, Et += nt * Ot, Et += Ze * $e, Et += Me * At, Et += De * Ft, et = Et >>> 13, Et &= 8191, Et += ze * Lt, Et += Ue * (5 * Kt), Et += Ke * (5 * qt), Et += We * (5 * Ut), Et += ct * (5 * Gt), et += Et >>> 13, Et &= 8191, wt = et, wt += it * Gt, wt += nt * jt, wt += Ze * Ot, wt += Me * $e, wt += De * At, et = wt >>> 13, wt &= 8191, wt += ze * Ft, wt += Ue * Lt, wt += Ke * (5 * Kt), wt += We * (5 * qt), wt += ct * (5 * Ut), et += wt >>> 13, wt &= 8191, tt = et, tt += it * Ut, tt += nt * Gt, tt += Ze * jt, tt += Me * Ot, tt += De * $e, et = tt >>> 13, tt &= 8191, tt += ze * At, tt += Ue * Ft, tt += Ke * Lt, tt += We * (5 * Kt), tt += ct * (5 * qt), et += tt >>> 13, tt &= 8191, ht = et, ht += it * qt, ht += nt * Ut, ht += Ze * Gt, ht += Me * jt, ht += De * Ot, et = ht >>> 13, ht &= 8191, ht += ze * $e, ht += Ue * At, ht += Ke * Ft, ht += We * Lt, ht += ct * (5 * Kt), et += ht >>> 13, ht &= 8191, Je = et, Je += it * Kt, Je += nt * qt, Je += Ze * Ut, Je += Me * Gt, Je += De * jt, et = Je >>> 13, Je &= 8191, Je += ze * Ot, Je += Ue * $e, Je += Ke * At, Je += We * Ft, Je += ct * Lt, et += Je >>> 13, Je &= 8191, et = (et << 2) + et | 0, et = et + _t | 0, _t = et & 8191, et = et >>> 13, $t += et, it = _t, nt = $t, Ze = St, Me = mt, De = xt, ze = Et, Ue = wt, Ke = tt, We = ht, ct = Je, ae += 16, ue -= 16;
      this.h[0] = it, this.h[1] = nt, this.h[2] = Ze, this.h[3] = Me, this.h[4] = De, this.h[5] = ze, this.h[6] = Ue, this.h[7] = Ke, this.h[8] = We, this.h[9] = ct;
    }, pe.prototype.finish = function(J, ae) {
      var ue = new Uint16Array(10), q, le, Ce, Se;
      if (this.leftover) {
        for (Se = this.leftover, this.buffer[Se++] = 1; Se < 16; Se++)
          this.buffer[Se] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (q = this.h[1] >>> 13, this.h[1] &= 8191, Se = 2; Se < 10; Se++)
        this.h[Se] += q, q = this.h[Se] >>> 13, this.h[Se] &= 8191;
      for (this.h[0] += q * 5, q = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += q, q = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += q, ue[0] = this.h[0] + 5, q = ue[0] >>> 13, ue[0] &= 8191, Se = 1; Se < 10; Se++)
        ue[Se] = this.h[Se] + q, q = ue[Se] >>> 13, ue[Se] &= 8191;
      for (ue[9] -= 8192, le = (q ^ 1) - 1, Se = 0; Se < 10; Se++)
        ue[Se] &= le;
      for (le = ~le, Se = 0; Se < 10; Se++)
        this.h[Se] = this.h[Se] & le | ue[Se];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Ce = this.h[0] + this.pad[0], this.h[0] = Ce & 65535, Se = 1; Se < 8; Se++)
        Ce = (this.h[Se] + this.pad[Se] | 0) + (Ce >>> 16) | 0, this.h[Se] = Ce & 65535;
      J[ae + 0] = this.h[0] >>> 0 & 255, J[ae + 1] = this.h[0] >>> 8 & 255, J[ae + 2] = this.h[1] >>> 0 & 255, J[ae + 3] = this.h[1] >>> 8 & 255, J[ae + 4] = this.h[2] >>> 0 & 255, J[ae + 5] = this.h[2] >>> 8 & 255, J[ae + 6] = this.h[3] >>> 0 & 255, J[ae + 7] = this.h[3] >>> 8 & 255, J[ae + 8] = this.h[4] >>> 0 & 255, J[ae + 9] = this.h[4] >>> 8 & 255, J[ae + 10] = this.h[5] >>> 0 & 255, J[ae + 11] = this.h[5] >>> 8 & 255, J[ae + 12] = this.h[6] >>> 0 & 255, J[ae + 13] = this.h[6] >>> 8 & 255, J[ae + 14] = this.h[7] >>> 0 & 255, J[ae + 15] = this.h[7] >>> 8 & 255;
    }, pe.prototype.update = function(J, ae, ue) {
      var q, le;
      if (this.leftover) {
        for (le = 16 - this.leftover, le > ue && (le = ue), q = 0; q < le; q++)
          this.buffer[this.leftover + q] = J[ae + q];
        if (ue -= le, ae += le, this.leftover += le, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (ue >= 16 && (le = ue - ue % 16, this.blocks(J, ae, le), ae += le, ue -= le), ue) {
        for (q = 0; q < ue; q++)
          this.buffer[this.leftover + q] = J[ae + q];
        this.leftover += ue;
      }
    };
    function O(J, ae, ue, q, le, Ce) {
      var Se = new pe(Ce);
      return Se.update(ue, q, le), Se.finish(J, ae), 0;
    }
    function E(J, ae, ue, q, le, Ce) {
      var Se = new Uint8Array(16);
      return O(Se, 0, ue, q, le, Ce), ie(J, ae, Se, 0);
    }
    function c(J, ae, ue, q, le) {
      var Ce;
      if (ue < 32)
        return -1;
      for (Xe(J, 0, ae, 0, ue, q, le), O(J, 16, J, 32, ue - 32, J), Ce = 0; Ce < 16; Ce++)
        J[Ce] = 0;
      return 0;
    }
    function b(J, ae, ue, q, le) {
      var Ce, Se = new Uint8Array(32);
      if (ue < 32 || (Re(Se, 0, 32, q, le), E(ae, 16, ae, 32, ue - 32, Se) !== 0))
        return -1;
      for (Xe(J, 0, ae, 0, ue, q, le), Ce = 0; Ce < 32; Ce++)
        J[Ce] = 0;
      return 0;
    }
    function C(J, ae) {
      var ue;
      for (ue = 0; ue < 16; ue++)
        J[ue] = ae[ue] | 0;
    }
    function x(J) {
      var ae, ue, q = 1;
      for (ae = 0; ae < 16; ae++)
        ue = J[ae] + q + 65535, q = Math.floor(ue / 65536), J[ae] = ue - q * 65536;
      J[0] += q - 1 + 37 * (q - 1);
    }
    function B(J, ae, ue) {
      for (var q, le = ~(ue - 1), Ce = 0; Ce < 16; Ce++)
        q = le & (J[Ce] ^ ae[Ce]), J[Ce] ^= q, ae[Ce] ^= q;
    }
    function k(J, ae) {
      var ue, q, le, Ce = a(), Se = a();
      for (ue = 0; ue < 16; ue++)
        Se[ue] = ae[ue];
      for (x(Se), x(Se), x(Se), q = 0; q < 2; q++) {
        for (Ce[0] = Se[0] - 65517, ue = 1; ue < 15; ue++)
          Ce[ue] = Se[ue] - 65535 - (Ce[ue - 1] >> 16 & 1), Ce[ue - 1] &= 65535;
        Ce[15] = Se[15] - 32767 - (Ce[14] >> 16 & 1), le = Ce[15] >> 16 & 1, Ce[14] &= 65535, B(Se, Ce, 1 - le);
      }
      for (ue = 0; ue < 16; ue++)
        J[2 * ue] = Se[ue] & 255, J[2 * ue + 1] = Se[ue] >> 8;
    }
    function w(J, ae) {
      var ue = new Uint8Array(32), q = new Uint8Array(32);
      return k(ue, J), k(q, ae), ee(ue, 0, q, 0);
    }
    function T(J) {
      var ae = new Uint8Array(32);
      return k(ae, J), ae[0] & 1;
    }
    function p(J, ae) {
      var ue;
      for (ue = 0; ue < 16; ue++)
        J[ue] = ae[2 * ue] + (ae[2 * ue + 1] << 8);
      J[15] &= 32767;
    }
    function F(J, ae, ue) {
      for (var q = 0; q < 16; q++)
        J[q] = ae[q] + ue[q];
    }
    function ye(J, ae, ue) {
      for (var q = 0; q < 16; q++)
        J[q] = ae[q] - ue[q];
    }
    function _e(J, ae, ue) {
      var q, le, Ce = 0, Se = 0, Ie = 0, Ve = 0, Ge = 0, qe = 0, Nt = 0, et = 0, _t = 0, $t = 0, St = 0, mt = 0, xt = 0, Et = 0, wt = 0, tt = 0, ht = 0, Je = 0, it = 0, nt = 0, Ze = 0, Me = 0, De = 0, ze = 0, Ue = 0, Ke = 0, We = 0, ct = 0, Lt = 0, Ft = 0, At = 0, $e = ue[0], Ot = ue[1], jt = ue[2], Gt = ue[3], Ut = ue[4], qt = ue[5], Kt = ue[6], ir = ue[7], Zt = ue[8], er = ue[9], te = ue[10], se = ue[11], ve = ue[12], Ae = ue[13], Fe = ue[14], je = ue[15];
      q = ae[0], Ce += q * $e, Se += q * Ot, Ie += q * jt, Ve += q * Gt, Ge += q * Ut, qe += q * qt, Nt += q * Kt, et += q * ir, _t += q * Zt, $t += q * er, St += q * te, mt += q * se, xt += q * ve, Et += q * Ae, wt += q * Fe, tt += q * je, q = ae[1], Se += q * $e, Ie += q * Ot, Ve += q * jt, Ge += q * Gt, qe += q * Ut, Nt += q * qt, et += q * Kt, _t += q * ir, $t += q * Zt, St += q * er, mt += q * te, xt += q * se, Et += q * ve, wt += q * Ae, tt += q * Fe, ht += q * je, q = ae[2], Ie += q * $e, Ve += q * Ot, Ge += q * jt, qe += q * Gt, Nt += q * Ut, et += q * qt, _t += q * Kt, $t += q * ir, St += q * Zt, mt += q * er, xt += q * te, Et += q * se, wt += q * ve, tt += q * Ae, ht += q * Fe, Je += q * je, q = ae[3], Ve += q * $e, Ge += q * Ot, qe += q * jt, Nt += q * Gt, et += q * Ut, _t += q * qt, $t += q * Kt, St += q * ir, mt += q * Zt, xt += q * er, Et += q * te, wt += q * se, tt += q * ve, ht += q * Ae, Je += q * Fe, it += q * je, q = ae[4], Ge += q * $e, qe += q * Ot, Nt += q * jt, et += q * Gt, _t += q * Ut, $t += q * qt, St += q * Kt, mt += q * ir, xt += q * Zt, Et += q * er, wt += q * te, tt += q * se, ht += q * ve, Je += q * Ae, it += q * Fe, nt += q * je, q = ae[5], qe += q * $e, Nt += q * Ot, et += q * jt, _t += q * Gt, $t += q * Ut, St += q * qt, mt += q * Kt, xt += q * ir, Et += q * Zt, wt += q * er, tt += q * te, ht += q * se, Je += q * ve, it += q * Ae, nt += q * Fe, Ze += q * je, q = ae[6], Nt += q * $e, et += q * Ot, _t += q * jt, $t += q * Gt, St += q * Ut, mt += q * qt, xt += q * Kt, Et += q * ir, wt += q * Zt, tt += q * er, ht += q * te, Je += q * se, it += q * ve, nt += q * Ae, Ze += q * Fe, Me += q * je, q = ae[7], et += q * $e, _t += q * Ot, $t += q * jt, St += q * Gt, mt += q * Ut, xt += q * qt, Et += q * Kt, wt += q * ir, tt += q * Zt, ht += q * er, Je += q * te, it += q * se, nt += q * ve, Ze += q * Ae, Me += q * Fe, De += q * je, q = ae[8], _t += q * $e, $t += q * Ot, St += q * jt, mt += q * Gt, xt += q * Ut, Et += q * qt, wt += q * Kt, tt += q * ir, ht += q * Zt, Je += q * er, it += q * te, nt += q * se, Ze += q * ve, Me += q * Ae, De += q * Fe, ze += q * je, q = ae[9], $t += q * $e, St += q * Ot, mt += q * jt, xt += q * Gt, Et += q * Ut, wt += q * qt, tt += q * Kt, ht += q * ir, Je += q * Zt, it += q * er, nt += q * te, Ze += q * se, Me += q * ve, De += q * Ae, ze += q * Fe, Ue += q * je, q = ae[10], St += q * $e, mt += q * Ot, xt += q * jt, Et += q * Gt, wt += q * Ut, tt += q * qt, ht += q * Kt, Je += q * ir, it += q * Zt, nt += q * er, Ze += q * te, Me += q * se, De += q * ve, ze += q * Ae, Ue += q * Fe, Ke += q * je, q = ae[11], mt += q * $e, xt += q * Ot, Et += q * jt, wt += q * Gt, tt += q * Ut, ht += q * qt, Je += q * Kt, it += q * ir, nt += q * Zt, Ze += q * er, Me += q * te, De += q * se, ze += q * ve, Ue += q * Ae, Ke += q * Fe, We += q * je, q = ae[12], xt += q * $e, Et += q * Ot, wt += q * jt, tt += q * Gt, ht += q * Ut, Je += q * qt, it += q * Kt, nt += q * ir, Ze += q * Zt, Me += q * er, De += q * te, ze += q * se, Ue += q * ve, Ke += q * Ae, We += q * Fe, ct += q * je, q = ae[13], Et += q * $e, wt += q * Ot, tt += q * jt, ht += q * Gt, Je += q * Ut, it += q * qt, nt += q * Kt, Ze += q * ir, Me += q * Zt, De += q * er, ze += q * te, Ue += q * se, Ke += q * ve, We += q * Ae, ct += q * Fe, Lt += q * je, q = ae[14], wt += q * $e, tt += q * Ot, ht += q * jt, Je += q * Gt, it += q * Ut, nt += q * qt, Ze += q * Kt, Me += q * ir, De += q * Zt, ze += q * er, Ue += q * te, Ke += q * se, We += q * ve, ct += q * Ae, Lt += q * Fe, Ft += q * je, q = ae[15], tt += q * $e, ht += q * Ot, Je += q * jt, it += q * Gt, nt += q * Ut, Ze += q * qt, Me += q * Kt, De += q * ir, ze += q * Zt, Ue += q * er, Ke += q * te, We += q * se, ct += q * ve, Lt += q * Ae, Ft += q * Fe, At += q * je, Ce += 38 * ht, Se += 38 * Je, Ie += 38 * it, Ve += 38 * nt, Ge += 38 * Ze, qe += 38 * Me, Nt += 38 * De, et += 38 * ze, _t += 38 * Ue, $t += 38 * Ke, St += 38 * We, mt += 38 * ct, xt += 38 * Lt, Et += 38 * Ft, wt += 38 * At, le = 1, q = Ce + le + 65535, le = Math.floor(q / 65536), Ce = q - le * 65536, q = Se + le + 65535, le = Math.floor(q / 65536), Se = q - le * 65536, q = Ie + le + 65535, le = Math.floor(q / 65536), Ie = q - le * 65536, q = Ve + le + 65535, le = Math.floor(q / 65536), Ve = q - le * 65536, q = Ge + le + 65535, le = Math.floor(q / 65536), Ge = q - le * 65536, q = qe + le + 65535, le = Math.floor(q / 65536), qe = q - le * 65536, q = Nt + le + 65535, le = Math.floor(q / 65536), Nt = q - le * 65536, q = et + le + 65535, le = Math.floor(q / 65536), et = q - le * 65536, q = _t + le + 65535, le = Math.floor(q / 65536), _t = q - le * 65536, q = $t + le + 65535, le = Math.floor(q / 65536), $t = q - le * 65536, q = St + le + 65535, le = Math.floor(q / 65536), St = q - le * 65536, q = mt + le + 65535, le = Math.floor(q / 65536), mt = q - le * 65536, q = xt + le + 65535, le = Math.floor(q / 65536), xt = q - le * 65536, q = Et + le + 65535, le = Math.floor(q / 65536), Et = q - le * 65536, q = wt + le + 65535, le = Math.floor(q / 65536), wt = q - le * 65536, q = tt + le + 65535, le = Math.floor(q / 65536), tt = q - le * 65536, Ce += le - 1 + 37 * (le - 1), le = 1, q = Ce + le + 65535, le = Math.floor(q / 65536), Ce = q - le * 65536, q = Se + le + 65535, le = Math.floor(q / 65536), Se = q - le * 65536, q = Ie + le + 65535, le = Math.floor(q / 65536), Ie = q - le * 65536, q = Ve + le + 65535, le = Math.floor(q / 65536), Ve = q - le * 65536, q = Ge + le + 65535, le = Math.floor(q / 65536), Ge = q - le * 65536, q = qe + le + 65535, le = Math.floor(q / 65536), qe = q - le * 65536, q = Nt + le + 65535, le = Math.floor(q / 65536), Nt = q - le * 65536, q = et + le + 65535, le = Math.floor(q / 65536), et = q - le * 65536, q = _t + le + 65535, le = Math.floor(q / 65536), _t = q - le * 65536, q = $t + le + 65535, le = Math.floor(q / 65536), $t = q - le * 65536, q = St + le + 65535, le = Math.floor(q / 65536), St = q - le * 65536, q = mt + le + 65535, le = Math.floor(q / 65536), mt = q - le * 65536, q = xt + le + 65535, le = Math.floor(q / 65536), xt = q - le * 65536, q = Et + le + 65535, le = Math.floor(q / 65536), Et = q - le * 65536, q = wt + le + 65535, le = Math.floor(q / 65536), wt = q - le * 65536, q = tt + le + 65535, le = Math.floor(q / 65536), tt = q - le * 65536, Ce += le - 1 + 37 * (le - 1), J[0] = Ce, J[1] = Se, J[2] = Ie, J[3] = Ve, J[4] = Ge, J[5] = qe, J[6] = Nt, J[7] = et, J[8] = _t, J[9] = $t, J[10] = St, J[11] = mt, J[12] = xt, J[13] = Et, J[14] = wt, J[15] = tt;
    }
    function de(J, ae) {
      _e(J, ae, ae);
    }
    function P(J, ae) {
      var ue = a(), q;
      for (q = 0; q < 16; q++)
        ue[q] = ae[q];
      for (q = 253; q >= 0; q--)
        de(ue, ue), q !== 2 && q !== 4 && _e(ue, ue, ae);
      for (q = 0; q < 16; q++)
        J[q] = ue[q];
    }
    function H(J, ae) {
      var ue = a(), q;
      for (q = 0; q < 16; q++)
        ue[q] = ae[q];
      for (q = 250; q >= 0; q--)
        de(ue, ue), q !== 1 && _e(ue, ue, ae);
      for (q = 0; q < 16; q++)
        J[q] = ue[q];
    }
    function he(J, ae, ue) {
      var q = new Uint8Array(32), le = new Float64Array(80), Ce, Se, Ie = a(), Ve = a(), Ge = a(), qe = a(), Nt = a(), et = a();
      for (Se = 0; Se < 31; Se++)
        q[Se] = ae[Se];
      for (q[31] = ae[31] & 127 | 64, q[0] &= 248, p(le, ue), Se = 0; Se < 16; Se++)
        Ve[Se] = le[Se], qe[Se] = Ie[Se] = Ge[Se] = 0;
      for (Ie[0] = qe[0] = 1, Se = 254; Se >= 0; --Se)
        Ce = q[Se >>> 3] >>> (Se & 7) & 1, B(Ie, Ve, Ce), B(Ge, qe, Ce), F(Nt, Ie, Ge), ye(Ie, Ie, Ge), F(Ge, Ve, qe), ye(Ve, Ve, qe), de(qe, Nt), de(et, Ie), _e(Ie, Ge, Ie), _e(Ge, Ve, Nt), F(Nt, Ie, Ge), ye(Ie, Ie, Ge), de(Ve, Ie), ye(Ge, qe, et), _e(Ie, Ge, y), F(Ie, Ie, qe), _e(Ge, Ge, Ie), _e(Ie, qe, et), _e(qe, Ve, le), de(Ve, Nt), B(Ie, Ve, Ce), B(Ge, qe, Ce);
      for (Se = 0; Se < 16; Se++)
        le[Se + 16] = Ie[Se], le[Se + 32] = Ge[Se], le[Se + 48] = Ve[Se], le[Se + 64] = qe[Se];
      var _t = le.subarray(32), $t = le.subarray(16);
      return P(_t, _t), _e($t, $t, _t), k(J, $t), 0;
    }
    function me(J, ae) {
      return he(J, ae, o);
    }
    function fe(J, ae) {
      return n(ae, 32), me(J, ae);
    }
    function re(J, ae, ue) {
      var q = new Uint8Array(32);
      return he(q, ue, ae), Ee(J, u, q, xe);
    }
    var we = c, ke = b;
    function Oe(J, ae, ue, q, le, Ce) {
      var Se = new Uint8Array(32);
      return re(Se, le, Ce), we(J, ae, ue, q, Se);
    }
    function ce(J, ae, ue, q, le, Ce) {
      var Se = new Uint8Array(32);
      return re(Se, le, Ce), ke(J, ae, ue, q, Se);
    }
    var j = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function z(J, ae, ue, q) {
      for (var le = new Int32Array(16), Ce = new Int32Array(16), Se, Ie, Ve, Ge, qe, Nt, et, _t, $t, St, mt, xt, Et, wt, tt, ht, Je, it, nt, Ze, Me, De, ze, Ue, Ke, We, ct = J[0], Lt = J[1], Ft = J[2], At = J[3], $e = J[4], Ot = J[5], jt = J[6], Gt = J[7], Ut = ae[0], qt = ae[1], Kt = ae[2], ir = ae[3], Zt = ae[4], er = ae[5], te = ae[6], se = ae[7], ve = 0; q >= 128; ) {
        for (nt = 0; nt < 16; nt++)
          Ze = 8 * nt + ve, le[nt] = ue[Ze + 0] << 24 | ue[Ze + 1] << 16 | ue[Ze + 2] << 8 | ue[Ze + 3], Ce[nt] = ue[Ze + 4] << 24 | ue[Ze + 5] << 16 | ue[Ze + 6] << 8 | ue[Ze + 7];
        for (nt = 0; nt < 80; nt++)
          if (Se = ct, Ie = Lt, Ve = Ft, Ge = At, qe = $e, Nt = Ot, et = jt, _t = Gt, $t = Ut, St = qt, mt = Kt, xt = ir, Et = Zt, wt = er, tt = te, ht = se, Me = Gt, De = se, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = ($e >>> 14 | Zt << 32 - 14) ^ ($e >>> 18 | Zt << 32 - 18) ^ (Zt >>> 41 - 32 | $e << 32 - (41 - 32)), De = (Zt >>> 14 | $e << 32 - 14) ^ (Zt >>> 18 | $e << 32 - 18) ^ ($e >>> 41 - 32 | Zt << 32 - (41 - 32)), ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Me = $e & Ot ^ ~$e & jt, De = Zt & er ^ ~Zt & te, ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Me = j[nt * 2], De = j[nt * 2 + 1], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Me = le[nt % 16], De = Ce[nt % 16], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, Je = Ke & 65535 | We << 16, it = ze & 65535 | Ue << 16, Me = Je, De = it, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = (ct >>> 28 | Ut << 32 - 28) ^ (Ut >>> 34 - 32 | ct << 32 - (34 - 32)) ^ (Ut >>> 39 - 32 | ct << 32 - (39 - 32)), De = (Ut >>> 28 | ct << 32 - 28) ^ (ct >>> 34 - 32 | Ut << 32 - (34 - 32)) ^ (ct >>> 39 - 32 | Ut << 32 - (39 - 32)), ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Me = ct & Lt ^ ct & Ft ^ Lt & Ft, De = Ut & qt ^ Ut & Kt ^ qt & Kt, ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, _t = Ke & 65535 | We << 16, ht = ze & 65535 | Ue << 16, Me = Ge, De = xt, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = Je, De = it, ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, Ge = Ke & 65535 | We << 16, xt = ze & 65535 | Ue << 16, Lt = Se, Ft = Ie, At = Ve, $e = Ge, Ot = qe, jt = Nt, Gt = et, ct = _t, qt = $t, Kt = St, ir = mt, Zt = xt, er = Et, te = wt, se = tt, Ut = ht, nt % 16 === 15)
            for (Ze = 0; Ze < 16; Ze++)
              Me = le[Ze], De = Ce[Ze], ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = le[(Ze + 9) % 16], De = Ce[(Ze + 9) % 16], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Je = le[(Ze + 1) % 16], it = Ce[(Ze + 1) % 16], Me = (Je >>> 1 | it << 32 - 1) ^ (Je >>> 8 | it << 32 - 8) ^ Je >>> 7, De = (it >>> 1 | Je << 32 - 1) ^ (it >>> 8 | Je << 32 - 8) ^ (it >>> 7 | Je << 32 - 7), ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Je = le[(Ze + 14) % 16], it = Ce[(Ze + 14) % 16], Me = (Je >>> 19 | it << 32 - 19) ^ (it >>> 61 - 32 | Je << 32 - (61 - 32)) ^ Je >>> 6, De = (it >>> 19 | Je << 32 - 19) ^ (Je >>> 61 - 32 | it << 32 - (61 - 32)) ^ (it >>> 6 | Je << 32 - 6), ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, le[Ze] = Ke & 65535 | We << 16, Ce[Ze] = ze & 65535 | Ue << 16;
        Me = ct, De = Ut, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = J[0], De = ae[0], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, J[0] = ct = Ke & 65535 | We << 16, ae[0] = Ut = ze & 65535 | Ue << 16, Me = Lt, De = qt, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = J[1], De = ae[1], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, J[1] = Lt = Ke & 65535 | We << 16, ae[1] = qt = ze & 65535 | Ue << 16, Me = Ft, De = Kt, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = J[2], De = ae[2], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, J[2] = Ft = Ke & 65535 | We << 16, ae[2] = Kt = ze & 65535 | Ue << 16, Me = At, De = ir, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = J[3], De = ae[3], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, J[3] = At = Ke & 65535 | We << 16, ae[3] = ir = ze & 65535 | Ue << 16, Me = $e, De = Zt, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = J[4], De = ae[4], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, J[4] = $e = Ke & 65535 | We << 16, ae[4] = Zt = ze & 65535 | Ue << 16, Me = Ot, De = er, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = J[5], De = ae[5], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, J[5] = Ot = Ke & 65535 | We << 16, ae[5] = er = ze & 65535 | Ue << 16, Me = jt, De = te, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = J[6], De = ae[6], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, J[6] = jt = Ke & 65535 | We << 16, ae[6] = te = ze & 65535 | Ue << 16, Me = Gt, De = se, ze = De & 65535, Ue = De >>> 16, Ke = Me & 65535, We = Me >>> 16, Me = J[7], De = ae[7], ze += De & 65535, Ue += De >>> 16, Ke += Me & 65535, We += Me >>> 16, Ue += ze >>> 16, Ke += Ue >>> 16, We += Ke >>> 16, J[7] = Gt = Ke & 65535 | We << 16, ae[7] = se = ze & 65535 | Ue << 16, ve += 128, q -= 128;
      }
      return q;
    }
    function oe(J, ae, ue) {
      var q = new Int32Array(8), le = new Int32Array(8), Ce = new Uint8Array(256), Se, Ie = ue;
      for (q[0] = 1779033703, q[1] = 3144134277, q[2] = 1013904242, q[3] = 2773480762, q[4] = 1359893119, q[5] = 2600822924, q[6] = 528734635, q[7] = 1541459225, le[0] = 4089235720, le[1] = 2227873595, le[2] = 4271175723, le[3] = 1595750129, le[4] = 2917565137, le[5] = 725511199, le[6] = 4215389547, le[7] = 327033209, z(q, le, ae, ue), ue %= 128, Se = 0; Se < ue; Se++)
        Ce[Se] = ae[Ie - ue + Se];
      for (Ce[ue] = 128, ue = 256 - 128 * (ue < 112 ? 1 : 0), Ce[ue - 9] = 0, V(Ce, ue - 8, Ie / 536870912 | 0, Ie << 3), z(q, le, Ce, ue), Se = 0; Se < 8; Se++)
        V(J, 8 * Se, q[Se], le[Se]);
      return 0;
    }
    function Be(J, ae) {
      var ue = a(), q = a(), le = a(), Ce = a(), Se = a(), Ie = a(), Ve = a(), Ge = a(), qe = a();
      ye(ue, J[1], J[0]), ye(qe, ae[1], ae[0]), _e(ue, ue, qe), F(q, J[0], J[1]), F(qe, ae[0], ae[1]), _e(q, q, qe), _e(le, J[3], ae[3]), _e(le, le, d), _e(Ce, J[2], ae[2]), F(Ce, Ce, Ce), ye(Se, q, ue), ye(Ie, Ce, le), F(Ve, Ce, le), F(Ge, q, ue), _e(J[0], Se, Ie), _e(J[1], Ge, Ve), _e(J[2], Ve, Ie), _e(J[3], Se, Ge);
    }
    function Te(J, ae, ue) {
      var q;
      for (q = 0; q < 4; q++)
        B(J[q], ae[q], ue);
    }
    function Pe(J, ae) {
      var ue = a(), q = a(), le = a();
      P(le, ae[2]), _e(ue, ae[0], le), _e(q, ae[1], le), k(J, q), J[31] ^= T(ue) << 7;
    }
    function Ye(J, ae, ue) {
      var q, le;
      for (C(J[0], l), C(J[1], h), C(J[2], h), C(J[3], l), le = 255; le >= 0; --le)
        q = ue[le / 8 | 0] >> (le & 7) & 1, Te(J, ae, q), Be(ae, J), Be(J, J), Te(J, ae, q);
    }
    function He(J, ae) {
      var ue = [a(), a(), a(), a()];
      C(ue[0], $), C(ue[1], N), C(ue[2], h), _e(ue[3], $, N), Ye(J, ue, ae);
    }
    function ot(J, ae, ue) {
      var q = new Uint8Array(64), le = [a(), a(), a(), a()], Ce;
      for (ue || n(ae, 32), oe(q, ae, 32), q[0] &= 248, q[31] &= 127, q[31] |= 64, He(le, q), Pe(J, le), Ce = 0; Ce < 32; Ce++)
        ae[Ce + 32] = J[Ce];
      return 0;
    }
    var at = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Qe(J, ae) {
      var ue, q, le, Ce;
      for (q = 63; q >= 32; --q) {
        for (ue = 0, le = q - 32, Ce = q - 12; le < Ce; ++le)
          ae[le] += ue - 16 * ae[q] * at[le - (q - 32)], ue = Math.floor((ae[le] + 128) / 256), ae[le] -= ue * 256;
        ae[le] += ue, ae[q] = 0;
      }
      for (ue = 0, le = 0; le < 32; le++)
        ae[le] += ue - (ae[31] >> 4) * at[le], ue = ae[le] >> 8, ae[le] &= 255;
      for (le = 0; le < 32; le++)
        ae[le] -= ue * at[le];
      for (q = 0; q < 32; q++)
        ae[q + 1] += ae[q] >> 8, J[q] = ae[q] & 255;
    }
    function Pt(J) {
      var ae = new Float64Array(64), ue;
      for (ue = 0; ue < 64; ue++)
        ae[ue] = J[ue];
      for (ue = 0; ue < 64; ue++)
        J[ue] = 0;
      Qe(J, ae);
    }
    function It(J, ae, ue, q) {
      var le = new Uint8Array(64), Ce = new Uint8Array(64), Se = new Uint8Array(64), Ie, Ve, Ge = new Float64Array(64), qe = [a(), a(), a(), a()];
      oe(le, q, 32), le[0] &= 248, le[31] &= 127, le[31] |= 64;
      var Nt = ue + 64;
      for (Ie = 0; Ie < ue; Ie++)
        J[64 + Ie] = ae[Ie];
      for (Ie = 0; Ie < 32; Ie++)
        J[32 + Ie] = le[32 + Ie];
      for (oe(Se, J.subarray(32), ue + 32), Pt(Se), He(qe, Se), Pe(J, qe), Ie = 32; Ie < 64; Ie++)
        J[Ie] = q[Ie];
      for (oe(Ce, J, ue + 64), Pt(Ce), Ie = 0; Ie < 64; Ie++)
        Ge[Ie] = 0;
      for (Ie = 0; Ie < 32; Ie++)
        Ge[Ie] = Se[Ie];
      for (Ie = 0; Ie < 32; Ie++)
        for (Ve = 0; Ve < 32; Ve++)
          Ge[Ie + Ve] += Ce[Ie] * le[Ve];
      return Qe(J.subarray(32), Ge), Nt;
    }
    function pt(J, ae) {
      var ue = a(), q = a(), le = a(), Ce = a(), Se = a(), Ie = a(), Ve = a();
      return C(J[2], h), p(J[1], ae), de(le, J[1]), _e(Ce, le, _), ye(le, le, J[2]), F(Ce, J[2], Ce), de(Se, Ce), de(Ie, Se), _e(Ve, Ie, Se), _e(ue, Ve, le), _e(ue, ue, Ce), H(ue, ue), _e(ue, ue, le), _e(ue, ue, Ce), _e(ue, ue, Ce), _e(J[0], ue, Ce), de(q, J[0]), _e(q, q, Ce), w(q, le) && _e(J[0], J[0], U), de(q, J[0]), _e(q, q, Ce), w(q, le) ? -1 : (T(J[0]) === ae[31] >> 7 && ye(J[0], l, J[0]), _e(J[3], J[0], J[1]), 0);
    }
    function Wt(J, ae, ue, q) {
      var le, Ce = new Uint8Array(32), Se = new Uint8Array(64), Ie = [a(), a(), a(), a()], Ve = [a(), a(), a(), a()];
      if (ue < 64 || pt(Ve, q))
        return -1;
      for (le = 0; le < ue; le++)
        J[le] = ae[le];
      for (le = 0; le < 32; le++)
        J[le + 32] = q[le];
      if (oe(Se, J, ue), Pt(Se), Ye(Ie, Ve, Se), He(Ve, ae.subarray(32)), Be(Ie, Ve), Pe(Ce, Ie), ue -= 64, ee(ae, 0, Ce, 0)) {
        for (le = 0; le < ue; le++)
          J[le] = 0;
        return -1;
      }
      for (le = 0; le < ue; le++)
        J[le] = ae[le + 64];
      return ue;
    }
    var Mt = 32, vt = 24, Vt = 32, Ct = 16, lt = 32, zt = 32, Tt = 32, dt = 32, Yt = 32, Dt = vt, bt = Vt, Jt = Ct, Bt = 64, ut = 32, Ht = 64, Rt = 32, gt = 64;
    t.lowlevel = {
      crypto_core_hsalsa20: Ee,
      crypto_stream_xor: Xe,
      crypto_stream: Re,
      crypto_stream_salsa20_xor: Le,
      crypto_stream_salsa20: Ne,
      crypto_onetimeauth: O,
      crypto_onetimeauth_verify: E,
      crypto_verify_16: ie,
      crypto_verify_32: ee,
      crypto_secretbox: c,
      crypto_secretbox_open: b,
      crypto_scalarmult: he,
      crypto_scalarmult_base: me,
      crypto_box_beforenm: re,
      crypto_box_afternm: we,
      crypto_box: Oe,
      crypto_box_open: ce,
      crypto_box_keypair: fe,
      crypto_hash: oe,
      crypto_sign: It,
      crypto_sign_keypair: ot,
      crypto_sign_open: Wt,
      crypto_secretbox_KEYBYTES: Mt,
      crypto_secretbox_NONCEBYTES: vt,
      crypto_secretbox_ZEROBYTES: Vt,
      crypto_secretbox_BOXZEROBYTES: Ct,
      crypto_scalarmult_BYTES: lt,
      crypto_scalarmult_SCALARBYTES: zt,
      crypto_box_PUBLICKEYBYTES: Tt,
      crypto_box_SECRETKEYBYTES: dt,
      crypto_box_BEFORENMBYTES: Yt,
      crypto_box_NONCEBYTES: Dt,
      crypto_box_ZEROBYTES: bt,
      crypto_box_BOXZEROBYTES: Jt,
      crypto_sign_BYTES: Bt,
      crypto_sign_PUBLICKEYBYTES: ut,
      crypto_sign_SECRETKEYBYTES: Ht,
      crypto_sign_SEEDBYTES: Rt,
      crypto_hash_BYTES: gt,
      gf: a,
      D: _,
      L: at,
      pack25519: k,
      unpack25519: p,
      M: _e,
      A: F,
      S: de,
      Z: ye,
      pow2523: H,
      add: Be,
      set25519: C,
      modL: Qe,
      scalarmult: Ye,
      scalarbase: He
    };
    function Qt(J, ae) {
      if (J.length !== Mt)
        throw new Error("bad key size");
      if (ae.length !== vt)
        throw new Error("bad nonce size");
    }
    function kt(J, ae) {
      if (J.length !== Tt)
        throw new Error("bad public key size");
      if (ae.length !== dt)
        throw new Error("bad secret key size");
    }
    function rt() {
      for (var J = 0; J < arguments.length; J++)
        if (!(arguments[J] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Xt(J) {
      for (var ae = 0; ae < J.length; ae++)
        J[ae] = 0;
    }
    t.randomBytes = function(J) {
      var ae = new Uint8Array(J);
      return n(ae, J), ae;
    }, t.secretbox = function(J, ae, ue) {
      rt(J, ae, ue), Qt(ue, ae);
      for (var q = new Uint8Array(Vt + J.length), le = new Uint8Array(q.length), Ce = 0; Ce < J.length; Ce++)
        q[Ce + Vt] = J[Ce];
      return c(le, q, q.length, ae, ue), le.subarray(Ct);
    }, t.secretbox.open = function(J, ae, ue) {
      rt(J, ae, ue), Qt(ue, ae);
      for (var q = new Uint8Array(Ct + J.length), le = new Uint8Array(q.length), Ce = 0; Ce < J.length; Ce++)
        q[Ce + Ct] = J[Ce];
      return q.length < 32 || b(le, q, q.length, ae, ue) !== 0 ? null : le.subarray(Vt);
    }, t.secretbox.keyLength = Mt, t.secretbox.nonceLength = vt, t.secretbox.overheadLength = Ct, t.scalarMult = function(J, ae) {
      if (rt(J, ae), J.length !== zt)
        throw new Error("bad n size");
      if (ae.length !== lt)
        throw new Error("bad p size");
      var ue = new Uint8Array(lt);
      return he(ue, J, ae), ue;
    }, t.scalarMult.base = function(J) {
      if (rt(J), J.length !== zt)
        throw new Error("bad n size");
      var ae = new Uint8Array(lt);
      return me(ae, J), ae;
    }, t.scalarMult.scalarLength = zt, t.scalarMult.groupElementLength = lt, t.box = function(J, ae, ue, q) {
      var le = t.box.before(ue, q);
      return t.secretbox(J, ae, le);
    }, t.box.before = function(J, ae) {
      rt(J, ae), kt(J, ae);
      var ue = new Uint8Array(Yt);
      return re(ue, J, ae), ue;
    }, t.box.after = t.secretbox, t.box.open = function(J, ae, ue, q) {
      var le = t.box.before(ue, q);
      return t.secretbox.open(J, ae, le);
    }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
      var J = new Uint8Array(Tt), ae = new Uint8Array(dt);
      return fe(J, ae), { publicKey: J, secretKey: ae };
    }, t.box.keyPair.fromSecretKey = function(J) {
      if (rt(J), J.length !== dt)
        throw new Error("bad secret key size");
      var ae = new Uint8Array(Tt);
      return me(ae, J), { publicKey: ae, secretKey: new Uint8Array(J) };
    }, t.box.publicKeyLength = Tt, t.box.secretKeyLength = dt, t.box.sharedKeyLength = Yt, t.box.nonceLength = Dt, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function(J, ae) {
      if (rt(J, ae), ae.length !== Ht)
        throw new Error("bad secret key size");
      var ue = new Uint8Array(Bt + J.length);
      return It(ue, J, J.length, ae), ue;
    }, t.sign.open = function(J, ae) {
      if (rt(J, ae), ae.length !== ut)
        throw new Error("bad public key size");
      var ue = new Uint8Array(J.length), q = Wt(ue, J, J.length, ae);
      if (q < 0)
        return null;
      for (var le = new Uint8Array(q), Ce = 0; Ce < le.length; Ce++)
        le[Ce] = ue[Ce];
      return le;
    }, t.sign.detached = function(J, ae) {
      for (var ue = t.sign(J, ae), q = new Uint8Array(Bt), le = 0; le < q.length; le++)
        q[le] = ue[le];
      return q;
    }, t.sign.detached.verify = function(J, ae, ue) {
      if (rt(J, ae, ue), ae.length !== Bt)
        throw new Error("bad signature size");
      if (ue.length !== ut)
        throw new Error("bad public key size");
      var q = new Uint8Array(Bt + J.length), le = new Uint8Array(Bt + J.length), Ce;
      for (Ce = 0; Ce < Bt; Ce++)
        q[Ce] = ae[Ce];
      for (Ce = 0; Ce < J.length; Ce++)
        q[Ce + Bt] = J[Ce];
      return Wt(le, q, q.length, ue) >= 0;
    }, t.sign.keyPair = function() {
      var J = new Uint8Array(ut), ae = new Uint8Array(Ht);
      return ot(J, ae), { publicKey: J, secretKey: ae };
    }, t.sign.keyPair.fromSecretKey = function(J) {
      if (rt(J), J.length !== Ht)
        throw new Error("bad secret key size");
      for (var ae = new Uint8Array(ut), ue = 0; ue < ae.length; ue++)
        ae[ue] = J[32 + ue];
      return { publicKey: ae, secretKey: new Uint8Array(J) };
    }, t.sign.keyPair.fromSeed = function(J) {
      if (rt(J), J.length !== Rt)
        throw new Error("bad seed size");
      for (var ae = new Uint8Array(ut), ue = new Uint8Array(Ht), q = 0; q < 32; q++)
        ue[q] = J[q];
      return ot(ae, ue, !0), { publicKey: ae, secretKey: ue };
    }, t.sign.publicKeyLength = ut, t.sign.secretKeyLength = Ht, t.sign.seedLength = Rt, t.sign.signatureLength = Bt, t.hash = function(J) {
      rt(J);
      var ae = new Uint8Array(gt);
      return oe(ae, J, J.length), ae;
    }, t.hash.hashLength = gt, t.verify = function(J, ae) {
      return rt(J, ae), J.length === 0 || ae.length === 0 || J.length !== ae.length ? !1 : Q(J, 0, ae, 0, J.length) === 0;
    }, t.setPRNG = function(J) {
      n = J;
    }, function() {
      var J = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (J && J.getRandomValues) {
        var ae = 65536;
        t.setPRNG(function(ue, q) {
          var le, Ce = new Uint8Array(q);
          for (le = 0; le < q; le += ae)
            J.getRandomValues(Ce.subarray(le, le + Math.min(q - le, ae)));
          for (le = 0; le < q; le++)
            ue[le] = Ce[le];
          Xt(Ce);
        });
      } else
        typeof commonjsRequire < "u" && (J = requireCryptoBrowserify(), J && J.randomBytes && t.setPRNG(function(ue, q) {
          var le, Ce = J.randomBytes(q);
          for (le = 0; le < q; le++)
            ue[le] = Ce[le];
          Xt(Ce);
        }));
    }();
  })(e.exports ? e.exports : self.nacl = self.nacl || {});
})(naclFast);
var naclFastExports = naclFast.exports;
const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
function normalizeInput(e) {
  let t;
  if (e instanceof Uint8Array)
    t = e;
  else if (typeof e == "string")
    t = new TextEncoder().encode(e);
  else
    throw new Error(ERROR_MSG_INPUT);
  return t;
}
function toHex(e) {
  return Array.prototype.map.call(e, function(t) {
    return (t < 16 ? "0" : "") + t.toString(16);
  }).join("");
}
function uint32ToHex(e) {
  return (4294967296 + e).toString(16).substring(1);
}
function debugPrint(e, t, a) {
  let n = `
` + e + " = ";
  for (let u = 0; u < t.length; u += 2) {
    if (a === 32)
      n += uint32ToHex(t[u]).toUpperCase(), n += " ", n += uint32ToHex(t[u + 1]).toUpperCase();
    else if (a === 64)
      n += uint32ToHex(t[u + 1]).toUpperCase(), n += uint32ToHex(t[u]).toUpperCase();
    else
      throw new Error("Invalid size " + a);
    u % 6 === 4 ? n += `
` + new Array(e.length + 4).join(" ") : u < t.length - 2 && (n += " ");
  }
  console.log(n);
}
function testSpeed(e, t, a) {
  let n = (/* @__PURE__ */ new Date()).getTime();
  const u = new Uint8Array(t);
  for (let l = 0; l < t; l++)
    u[l] = l % 256;
  const o = (/* @__PURE__ */ new Date()).getTime();
  console.log("Generated random input in " + (o - n) + "ms"), n = o;
  for (let l = 0; l < a; l++) {
    const h = e(u), y = (/* @__PURE__ */ new Date()).getTime(), _ = y - n;
    n = y, console.log("Hashed in " + _ + "ms: " + h.substring(0, 20) + "..."), console.log(
      Math.round(t / (1 << 20) / (_ / 1e3) * 100) / 100 + " MB PER SECOND"
    );
  }
}
var util$4 = {
  normalizeInput,
  toHex,
  debugPrint,
  testSpeed
};
const util$3 = util$4;
function ADD64AA(e, t, a) {
  const n = e[t] + e[a];
  let u = e[t + 1] + e[a + 1];
  n >= 4294967296 && u++, e[t] = n, e[t + 1] = u;
}
function ADD64AC(e, t, a, n) {
  let u = e[t] + a;
  a < 0 && (u += 4294967296);
  let o = e[t + 1] + n;
  u >= 4294967296 && o++, e[t] = u, e[t + 1] = o;
}
function B2B_GET32(e, t) {
  return e[t] ^ e[t + 1] << 8 ^ e[t + 2] << 16 ^ e[t + 3] << 24;
}
function B2B_G(e, t, a, n, u, o) {
  const l = m$1[u], h = m$1[u + 1], y = m$1[o], _ = m$1[o + 1];
  ADD64AA(v$1, e, t), ADD64AC(v$1, e, l, h);
  let d = v$1[n] ^ v$1[e], $ = v$1[n + 1] ^ v$1[e + 1];
  v$1[n] = $, v$1[n + 1] = d, ADD64AA(v$1, a, n), d = v$1[t] ^ v$1[a], $ = v$1[t + 1] ^ v$1[a + 1], v$1[t] = d >>> 24 ^ $ << 8, v$1[t + 1] = $ >>> 24 ^ d << 8, ADD64AA(v$1, e, t), ADD64AC(v$1, e, y, _), d = v$1[n] ^ v$1[e], $ = v$1[n + 1] ^ v$1[e + 1], v$1[n] = d >>> 16 ^ $ << 16, v$1[n + 1] = $ >>> 16 ^ d << 16, ADD64AA(v$1, a, n), d = v$1[t] ^ v$1[a], $ = v$1[t + 1] ^ v$1[a + 1], v$1[t] = $ >>> 31 ^ d << 1, v$1[t + 1] = d >>> 31 ^ $ << 1;
}
const BLAKE2B_IV32 = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), SIGMA8 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
], SIGMA82 = new Uint8Array(
  SIGMA8.map(function(e) {
    return e * 2;
  })
), v$1 = new Uint32Array(32), m$1 = new Uint32Array(32);
function blake2bCompress(e, t) {
  let a = 0;
  for (a = 0; a < 16; a++)
    v$1[a] = e.h[a], v$1[a + 16] = BLAKE2B_IV32[a];
  for (v$1[24] = v$1[24] ^ e.t, v$1[25] = v$1[25] ^ e.t / 4294967296, t && (v$1[28] = ~v$1[28], v$1[29] = ~v$1[29]), a = 0; a < 32; a++)
    m$1[a] = B2B_GET32(e.b, 4 * a);
  for (a = 0; a < 12; a++)
    B2B_G(0, 8, 16, 24, SIGMA82[a * 16 + 0], SIGMA82[a * 16 + 1]), B2B_G(2, 10, 18, 26, SIGMA82[a * 16 + 2], SIGMA82[a * 16 + 3]), B2B_G(4, 12, 20, 28, SIGMA82[a * 16 + 4], SIGMA82[a * 16 + 5]), B2B_G(6, 14, 22, 30, SIGMA82[a * 16 + 6], SIGMA82[a * 16 + 7]), B2B_G(0, 10, 20, 30, SIGMA82[a * 16 + 8], SIGMA82[a * 16 + 9]), B2B_G(2, 12, 22, 24, SIGMA82[a * 16 + 10], SIGMA82[a * 16 + 11]), B2B_G(4, 14, 16, 26, SIGMA82[a * 16 + 12], SIGMA82[a * 16 + 13]), B2B_G(6, 8, 18, 28, SIGMA82[a * 16 + 14], SIGMA82[a * 16 + 15]);
  for (a = 0; a < 16; a++)
    e.h[a] = e.h[a] ^ v$1[a] ^ v$1[a + 16];
}
const parameterBlock = new Uint8Array([
  0,
  0,
  0,
  0,
  //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0,
  //  4: leaf length, sequential mode
  0,
  0,
  0,
  0,
  //  8: node offset
  0,
  0,
  0,
  0,
  // 12: node offset
  0,
  0,
  0,
  0,
  // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0,
  // 20: rfu
  0,
  0,
  0,
  0,
  // 24: rfu
  0,
  0,
  0,
  0,
  // 28: rfu
  0,
  0,
  0,
  0,
  // 32: salt
  0,
  0,
  0,
  0,
  // 36: salt
  0,
  0,
  0,
  0,
  // 40: salt
  0,
  0,
  0,
  0,
  // 44: salt
  0,
  0,
  0,
  0,
  // 48: personal
  0,
  0,
  0,
  0,
  // 52: personal
  0,
  0,
  0,
  0,
  // 56: personal
  0,
  0,
  0,
  0
  // 60: personal
]);
function blake2bInit(e, t, a, n) {
  if (e === 0 || e > 64)
    throw new Error("Illegal output length, expected 0 < length <= 64");
  if (t && t.length > 64)
    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
  if (a && a.length !== 16)
    throw new Error("Illegal salt, expected Uint8Array with length is 16");
  if (n && n.length !== 16)
    throw new Error("Illegal personal, expected Uint8Array with length is 16");
  const u = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0,
    // input count
    c: 0,
    // pointer within buffer
    outlen: e
    // output length in bytes
  };
  parameterBlock.fill(0), parameterBlock[0] = e, t && (parameterBlock[1] = t.length), parameterBlock[2] = 1, parameterBlock[3] = 1, a && parameterBlock.set(a, 32), n && parameterBlock.set(n, 48);
  for (let o = 0; o < 16; o++)
    u.h[o] = BLAKE2B_IV32[o] ^ B2B_GET32(parameterBlock, o * 4);
  return t && (blake2bUpdate(u, t), u.c = 128), u;
}
function blake2bUpdate(e, t) {
  for (let a = 0; a < t.length; a++)
    e.c === 128 && (e.t += e.c, blake2bCompress(e, !1), e.c = 0), e.b[e.c++] = t[a];
}
function blake2bFinal(e) {
  for (e.t += e.c; e.c < 128; )
    e.b[e.c++] = 0;
  blake2bCompress(e, !0);
  const t = new Uint8Array(e.outlen);
  for (let a = 0; a < e.outlen; a++)
    t[a] = e.h[a >> 2] >> 8 * (a & 3);
  return t;
}
function blake2b(e, t, a, n, u) {
  a = a || 64, e = util$3.normalizeInput(e), n && (n = util$3.normalizeInput(n)), u && (u = util$3.normalizeInput(u));
  const o = blake2bInit(a, t, n, u);
  return blake2bUpdate(o, e), blake2bFinal(o);
}
function blake2bHex(e, t, a, n, u) {
  const o = blake2b(e, t, a, n, u);
  return util$3.toHex(o);
}
var blake2b_1 = {
  blake2b,
  blake2bHex,
  blake2bInit,
  blake2bUpdate,
  blake2bFinal
};
const util$2 = util$4;
function B2S_GET32(e, t) {
  return e[t] ^ e[t + 1] << 8 ^ e[t + 2] << 16 ^ e[t + 3] << 24;
}
function B2S_G(e, t, a, n, u, o) {
  v[e] = v[e] + v[t] + u, v[n] = ROTR32(v[n] ^ v[e], 16), v[a] = v[a] + v[n], v[t] = ROTR32(v[t] ^ v[a], 12), v[e] = v[e] + v[t] + o, v[n] = ROTR32(v[n] ^ v[e], 8), v[a] = v[a] + v[n], v[t] = ROTR32(v[t] ^ v[a], 7);
}
function ROTR32(e, t) {
  return e >>> t ^ e << 32 - t;
}
const BLAKE2S_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0
]), v = new Uint32Array(16), m = new Uint32Array(16);
function blake2sCompress(e, t) {
  let a = 0;
  for (a = 0; a < 8; a++)
    v[a] = e.h[a], v[a + 8] = BLAKE2S_IV[a];
  for (v[12] ^= e.t, v[13] ^= e.t / 4294967296, t && (v[14] = ~v[14]), a = 0; a < 16; a++)
    m[a] = B2S_GET32(e.b, 4 * a);
  for (a = 0; a < 10; a++)
    B2S_G(0, 4, 8, 12, m[SIGMA[a * 16 + 0]], m[SIGMA[a * 16 + 1]]), B2S_G(1, 5, 9, 13, m[SIGMA[a * 16 + 2]], m[SIGMA[a * 16 + 3]]), B2S_G(2, 6, 10, 14, m[SIGMA[a * 16 + 4]], m[SIGMA[a * 16 + 5]]), B2S_G(3, 7, 11, 15, m[SIGMA[a * 16 + 6]], m[SIGMA[a * 16 + 7]]), B2S_G(0, 5, 10, 15, m[SIGMA[a * 16 + 8]], m[SIGMA[a * 16 + 9]]), B2S_G(1, 6, 11, 12, m[SIGMA[a * 16 + 10]], m[SIGMA[a * 16 + 11]]), B2S_G(2, 7, 8, 13, m[SIGMA[a * 16 + 12]], m[SIGMA[a * 16 + 13]]), B2S_G(3, 4, 9, 14, m[SIGMA[a * 16 + 14]], m[SIGMA[a * 16 + 15]]);
  for (a = 0; a < 8; a++)
    e.h[a] ^= v[a] ^ v[a + 8];
}
function blake2sInit(e, t) {
  if (!(e > 0 && e <= 32))
    throw new Error("Incorrect output length, should be in [1, 32]");
  const a = t ? t.length : 0;
  if (t && !(a > 0 && a <= 32))
    throw new Error("Incorrect key length, should be in [1, 32]");
  const n = {
    h: new Uint32Array(BLAKE2S_IV),
    // hash state
    b: new Uint8Array(64),
    // input block
    c: 0,
    // pointer within block
    t: 0,
    // input count
    outlen: e
    // output length in bytes
  };
  return n.h[0] ^= 16842752 ^ a << 8 ^ e, a > 0 && (blake2sUpdate(n, t), n.c = 64), n;
}
function blake2sUpdate(e, t) {
  for (let a = 0; a < t.length; a++)
    e.c === 64 && (e.t += e.c, blake2sCompress(e, !1), e.c = 0), e.b[e.c++] = t[a];
}
function blake2sFinal(e) {
  for (e.t += e.c; e.c < 64; )
    e.b[e.c++] = 0;
  blake2sCompress(e, !0);
  const t = new Uint8Array(e.outlen);
  for (let a = 0; a < e.outlen; a++)
    t[a] = e.h[a >> 2] >> 8 * (a & 3) & 255;
  return t;
}
function blake2s(e, t, a) {
  a = a || 32, e = util$2.normalizeInput(e);
  const n = blake2sInit(a, t);
  return blake2sUpdate(n, e), blake2sFinal(n);
}
function blake2sHex(e, t, a) {
  const n = blake2s(e, t, a);
  return util$2.toHex(n);
}
var blake2s_1 = {
  blake2s,
  blake2sHex,
  blake2sInit,
  blake2sUpdate,
  blake2sFinal
};
const b2b = blake2b_1, b2s = blake2s_1;
var blakejs = {
  blake2b: b2b.blake2b,
  blake2bHex: b2b.blake2bHex,
  blake2bInit: b2b.blake2bInit,
  blake2bUpdate: b2b.blake2bUpdate,
  blake2bFinal: b2b.blake2bFinal,
  blake2s: b2s.blake2s,
  blake2sHex: b2s.blake2sHex,
  blake2sInit: b2s.blake2sInit,
  blake2sUpdate: b2s.blake2sUpdate,
  blake2sFinal: b2s.blake2sFinal
};
const overheadLength = naclFastExports.box.overheadLength + naclFastExports.box.publicKeyLength, keyPair = naclFastExports.box.keyPair;
function open(e, t, a) {
  const n = e.subarray(0, naclFastExports.box.publicKeyLength), u = e.subarray(naclFastExports.box.publicKeyLength);
  return naclFastExports.box.open(u, nonce(n, t), n, a);
}
function seal(e, t) {
  const a = new Uint8Array(overheadLength + e.length), n = naclFastExports.box.keyPair(), u = naclFastExports.box(e, nonce(n.publicKey, t), t, n.secretKey);
  return a.set(n.publicKey), a.set(u, n.publicKey.length), a;
}
function nonce(e, t) {
  const a = new Uint8Array(e.length + t.length);
  return a.set(e), a.set(t, e.length), blakejs.blake2b(a, void 0, naclFastExports.box.nonceLength);
}
async function encodeBox(e, t) {
  const n = new TextEncoder().encode(JSON.stringify(e)), u = seal(n, t);
  return {
    key: await encodeBase64(t),
    data: await encodeBase64(u)
  };
}
async function decodeBox(e, t, a) {
  const n = new TextDecoder(), u = await decodeBase64(e), o = open(u, t, a);
  if (!o)
    throw new Error("Invalid data");
  return JSON.parse(n.decode(o));
}
function zeros(e) {
  let t = buffer$1.Buffer.alloc(e);
  return t.fill(0), t.toString();
}
class HKDF {
  constructor(t, a, n) {
    this.hashAlg = t;
    const u = crypto$1.createHash(this.hashAlg);
    this.hashLength = u.digest().length, this.salt = a || zeros(this.hashLength), this.ikm = n;
    const o = crypto$1.createHmac(this.hashAlg, this.salt);
    o.update(this.ikm), this.prk = o.digest();
  }
  derive(t, a, n) {
    let u = buffer$1.Buffer.alloc(0), o;
    const l = [], h = Math.ceil(a / this.hashLength);
    t = buffer$1.Buffer.from(t.toString());
    for (let y = 0; y < h; y++) {
      const _ = crypto$1.createHmac(this.hashAlg, this.prk);
      _.update(u), _.update(t), _.update(buffer$1.Buffer.from([y + 1])), u = _.digest(), l.push(u);
    }
    o = buffer$1.Buffer.concat(l, a), api$2.nextTick(function() {
      n(o);
    });
  }
}
var forge$D = {
  // default options
  options: {
    usePureJavaScript: !1
  }
}, api = {}, baseN$1 = api, _reverseAlphabets = {};
api.encode = function(e, t, a) {
  if (typeof t != "string")
    throw new TypeError('"alphabet" must be a string.');
  if (a !== void 0 && typeof a != "number")
    throw new TypeError('"maxline" must be a number.');
  var n = "";
  if (!(e instanceof Uint8Array))
    n = _encodeWithByteBuffer(e, t);
  else {
    var u = 0, o = t.length, l = t.charAt(0), h = [0];
    for (u = 0; u < e.length; ++u) {
      for (var y = 0, _ = e[u]; y < h.length; ++y)
        _ += h[y] << 8, h[y] = _ % o, _ = _ / o | 0;
      for (; _ > 0; )
        h.push(_ % o), _ = _ / o | 0;
    }
    for (u = 0; e[u] === 0 && u < e.length - 1; ++u)
      n += l;
    for (u = h.length - 1; u >= 0; --u)
      n += t[h[u]];
  }
  if (a) {
    var d = new RegExp(".{1," + a + "}", "g");
    n = n.match(d).join(`\r
`);
  }
  return n;
};
api.decode = function(e, t) {
  if (typeof e != "string")
    throw new TypeError('"input" must be a string.');
  if (typeof t != "string")
    throw new TypeError('"alphabet" must be a string.');
  var a = _reverseAlphabets[t];
  if (!a) {
    a = _reverseAlphabets[t] = [];
    for (var n = 0; n < t.length; ++n)
      a[t.charCodeAt(n)] = n;
  }
  e = e.replace(/\s/g, "");
  for (var u = t.length, o = t.charAt(0), l = [0], n = 0; n < e.length; n++) {
    var h = a[e.charCodeAt(n)];
    if (h === void 0)
      return;
    for (var y = 0, _ = h; y < l.length; ++y)
      _ += l[y] * u, l[y] = _ & 255, _ >>= 8;
    for (; _ > 0; )
      l.push(_ & 255), _ >>= 8;
  }
  for (var d = 0; e[d] === o && d < e.length - 1; ++d)
    l.push(0);
  return typeof buffer$1.Buffer < "u" ? buffer$1.Buffer.from(l.reverse()) : new Uint8Array(l.reverse());
};
function _encodeWithByteBuffer(e, t) {
  var a = 0, n = t.length, u = t.charAt(0), o = [0];
  for (a = 0; a < e.length(); ++a) {
    for (var l = 0, h = e.at(a); l < o.length; ++l)
      h += o[l] << 8, o[l] = h % n, h = h / n | 0;
    for (; h > 0; )
      o.push(h % n), h = h / n | 0;
  }
  var y = "";
  for (a = 0; e.at(a) === 0 && a < e.length() - 1; ++a)
    y += u;
  for (a = o.length - 1; a >= 0; --a)
    y += t[o[a]];
  return y;
}
var forge$C = forge$D, baseN = baseN$1, util$1 = forge$C.util = forge$C.util || {};
(function() {
  if (typeof api$2 < "u" && api$2.nextTick && !api$2.browser) {
    util$1.nextTick = api$2.nextTick, typeof setImmediate == "function" ? util$1.setImmediate = setImmediate : util$1.setImmediate = util$1.nextTick;
    return;
  }
  if (typeof setImmediate == "function") {
    util$1.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    }, util$1.nextTick = function(l) {
      return setImmediate(l);
    };
    return;
  }
  if (util$1.setImmediate = function(l) {
    setTimeout(l, 0);
  }, typeof window < "u" && typeof window.postMessage == "function") {
    let l = function(h) {
      if (h.source === window && h.data === e) {
        h.stopPropagation();
        var y = t.slice();
        t.length = 0, y.forEach(function(_) {
          _();
        });
      }
    };
    var e = "forge.setImmediate", t = [];
    util$1.setImmediate = function(h) {
      t.push(h), t.length === 1 && window.postMessage(e, "*");
    }, window.addEventListener("message", l, !0);
  }
  if (typeof MutationObserver < "u") {
    var a = Date.now(), n = !0, u = document.createElement("div"), t = [];
    new MutationObserver(function() {
      var h = t.slice();
      t.length = 0, h.forEach(function(y) {
        y();
      });
    }).observe(u, { attributes: !0 });
    var o = util$1.setImmediate;
    util$1.setImmediate = function(h) {
      Date.now() - a > 15 ? (a = Date.now(), o(h)) : (t.push(h), t.length === 1 && u.setAttribute("a", n = !n));
    };
  }
  util$1.nextTick = util$1.setImmediate;
})();
util$1.isNodejs = typeof api$2 < "u" && api$2.versions && api$2.versions.node;
util$1.globalScope = function() {
  return util$1.isNodejs ? commonjsGlobal : typeof self > "u" ? window : self;
}();
util$1.isArray = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
};
util$1.isArrayBuffer = function(e) {
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer;
};
util$1.isArrayBufferView = function(e) {
  return e && util$1.isArrayBuffer(e.buffer) && e.byteLength !== void 0;
};
function _checkBitsParam(e) {
  if (!(e === 8 || e === 16 || e === 24 || e === 32))
    throw new Error("Only 8, 16, 24, or 32 bits supported: " + e);
}
util$1.ByteBuffer = ByteStringBuffer;
function ByteStringBuffer(e) {
  if (this.data = "", this.read = 0, typeof e == "string")
    this.data = e;
  else if (util$1.isArrayBuffer(e) || util$1.isArrayBufferView(e))
    if (typeof buffer$1.Buffer < "u" && e instanceof buffer$1.Buffer)
      this.data = e.toString("binary");
    else {
      var t = new Uint8Array(e);
      try {
        this.data = String.fromCharCode.apply(null, t);
      } catch {
        for (var a = 0; a < t.length; ++a)
          this.putByte(t[a]);
      }
    }
  else
    (e instanceof ByteStringBuffer || typeof e == "object" && typeof e.data == "string" && typeof e.read == "number") && (this.data = e.data, this.read = e.read);
  this._constructedStringLength = 0;
}
util$1.ByteStringBuffer = ByteStringBuffer;
var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
util$1.ByteStringBuffer.prototype._optimizeConstructedString = function(e) {
  this._constructedStringLength += e, this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH && (this.data.substr(0, 1), this._constructedStringLength = 0);
};
util$1.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
util$1.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$1.ByteStringBuffer.prototype.putByte = function(e) {
  return this.putBytes(String.fromCharCode(e));
};
util$1.ByteStringBuffer.prototype.fillWithByte = function(e, t) {
  e = String.fromCharCode(e);
  for (var a = this.data; t > 0; )
    t & 1 && (a += e), t >>>= 1, t > 0 && (e += e);
  return this.data = a, this._optimizeConstructedString(t), this;
};
util$1.ByteStringBuffer.prototype.putBytes = function(e) {
  return this.data += e, this._optimizeConstructedString(e.length), this;
};
util$1.ByteStringBuffer.prototype.putString = function(e) {
  return this.putBytes(util$1.encodeUtf8(e));
};
util$1.ByteStringBuffer.prototype.putInt16 = function(e) {
  return this.putBytes(
    String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt24 = function(e) {
  return this.putBytes(
    String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt32 = function(e) {
  return this.putBytes(
    String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt16Le = function(e) {
  return this.putBytes(
    String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt24Le = function(e) {
  return this.putBytes(
    String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt32Le = function(e) {
  return this.putBytes(
    String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 24 & 255)
  );
};
util$1.ByteStringBuffer.prototype.putInt = function(e, t) {
  _checkBitsParam(t);
  var a = "";
  do
    t -= 8, a += String.fromCharCode(e >> t & 255);
  while (t > 0);
  return this.putBytes(a);
};
util$1.ByteStringBuffer.prototype.putSignedInt = function(e, t) {
  return e < 0 && (e += 2 << t - 1), this.putInt(e, t);
};
util$1.ByteStringBuffer.prototype.putBuffer = function(e) {
  return this.putBytes(e.getBytes());
};
util$1.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
util$1.ByteStringBuffer.prototype.getInt16 = function() {
  var e = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  return this.read += 2, e;
};
util$1.ByteStringBuffer.prototype.getInt24 = function() {
  var e = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  return this.read += 3, e;
};
util$1.ByteStringBuffer.prototype.getInt32 = function() {
  var e = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  return this.read += 4, e;
};
util$1.ByteStringBuffer.prototype.getInt16Le = function() {
  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  return this.read += 2, e;
};
util$1.ByteStringBuffer.prototype.getInt24Le = function() {
  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  return this.read += 3, e;
};
util$1.ByteStringBuffer.prototype.getInt32Le = function() {
  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  return this.read += 4, e;
};
util$1.ByteStringBuffer.prototype.getInt = function(e) {
  _checkBitsParam(e);
  var t = 0;
  do
    t = (t << 8) + this.data.charCodeAt(this.read++), e -= 8;
  while (e > 0);
  return t;
};
util$1.ByteStringBuffer.prototype.getSignedInt = function(e) {
  var t = this.getInt(e), a = 2 << e - 2;
  return t >= a && (t -= a << 1), t;
};
util$1.ByteStringBuffer.prototype.getBytes = function(e) {
  var t;
  return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : e === 0 ? t = "" : (t = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), t;
};
util$1.ByteStringBuffer.prototype.bytes = function(e) {
  return typeof e > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e);
};
util$1.ByteStringBuffer.prototype.at = function(e) {
  return this.data.charCodeAt(this.read + e);
};
util$1.ByteStringBuffer.prototype.setAt = function(e, t) {
  return this.data = this.data.substr(0, this.read + e) + String.fromCharCode(t) + this.data.substr(this.read + e + 1), this;
};
util$1.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
util$1.ByteStringBuffer.prototype.copy = function() {
  var e = util$1.createBuffer(this.data);
  return e.read = this.read, e;
};
util$1.ByteStringBuffer.prototype.compact = function() {
  return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
};
util$1.ByteStringBuffer.prototype.clear = function() {
  return this.data = "", this.read = 0, this;
};
util$1.ByteStringBuffer.prototype.truncate = function(e) {
  var t = Math.max(0, this.length() - e);
  return this.data = this.data.substr(this.read, t), this.read = 0, this;
};
util$1.ByteStringBuffer.prototype.toHex = function() {
  for (var e = "", t = this.read; t < this.data.length; ++t) {
    var a = this.data.charCodeAt(t);
    a < 16 && (e += "0"), e += a.toString(16);
  }
  return e;
};
util$1.ByteStringBuffer.prototype.toString = function() {
  return util$1.decodeUtf8(this.bytes());
};
function DataBuffer(e, t) {
  t = t || {}, this.read = t.readOffset || 0, this.growSize = t.growSize || 1024;
  var a = util$1.isArrayBuffer(e), n = util$1.isArrayBufferView(e);
  if (a || n) {
    a ? this.data = new DataView(e) : this.data = new DataView(e.buffer, e.byteOffset, e.byteLength), this.write = "writeOffset" in t ? t.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0)), this.write = 0, e != null && this.putBytes(e), "writeOffset" in t && (this.write = t.writeOffset);
}
util$1.DataBuffer = DataBuffer;
util$1.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
util$1.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$1.DataBuffer.prototype.accommodate = function(e, t) {
  if (this.length() >= e)
    return this;
  t = Math.max(t || this.growSize, e);
  var a = new Uint8Array(
    this.data.buffer,
    this.data.byteOffset,
    this.data.byteLength
  ), n = new Uint8Array(this.length() + t);
  return n.set(a), this.data = new DataView(n.buffer), this;
};
util$1.DataBuffer.prototype.putByte = function(e) {
  return this.accommodate(1), this.data.setUint8(this.write++, e), this;
};
util$1.DataBuffer.prototype.fillWithByte = function(e, t) {
  this.accommodate(t);
  for (var a = 0; a < t; ++a)
    this.data.setUint8(e);
  return this;
};
util$1.DataBuffer.prototype.putBytes = function(e, t) {
  if (util$1.isArrayBufferView(e)) {
    var a = new Uint8Array(e.buffer, e.byteOffset, e.byteLength), n = a.byteLength - a.byteOffset;
    this.accommodate(n);
    var u = new Uint8Array(this.data.buffer, this.write);
    return u.set(a), this.write += n, this;
  }
  if (util$1.isArrayBuffer(e)) {
    var a = new Uint8Array(e);
    this.accommodate(a.byteLength);
    var u = new Uint8Array(this.data.buffer);
    return u.set(a, this.write), this.write += a.byteLength, this;
  }
  if (e instanceof util$1.DataBuffer || typeof e == "object" && typeof e.read == "number" && typeof e.write == "number" && util$1.isArrayBufferView(e.data)) {
    var a = new Uint8Array(e.data.byteLength, e.read, e.length());
    this.accommodate(a.byteLength);
    var u = new Uint8Array(e.data.byteLength, this.write);
    return u.set(a), this.write += a.byteLength, this;
  }
  if (e instanceof util$1.ByteStringBuffer && (e = e.data, t = "binary"), t = t || "binary", typeof e == "string") {
    var o;
    if (t === "hex")
      return this.accommodate(Math.ceil(e.length / 2)), o = new Uint8Array(this.data.buffer, this.write), this.write += util$1.binary.hex.decode(e, o, this.write), this;
    if (t === "base64")
      return this.accommodate(Math.ceil(e.length / 4) * 3), o = new Uint8Array(this.data.buffer, this.write), this.write += util$1.binary.base64.decode(e, o, this.write), this;
    if (t === "utf8" && (e = util$1.encodeUtf8(e), t = "binary"), t === "binary" || t === "raw")
      return this.accommodate(e.length), o = new Uint8Array(this.data.buffer, this.write), this.write += util$1.binary.raw.decode(o), this;
    if (t === "utf16")
      return this.accommodate(e.length * 2), o = new Uint16Array(this.data.buffer, this.write), this.write += util$1.text.utf16.encode(o), this;
    throw new Error("Invalid encoding: " + t);
  }
  throw Error("Invalid parameter: " + e);
};
util$1.DataBuffer.prototype.putBuffer = function(e) {
  return this.putBytes(e), e.clear(), this;
};
util$1.DataBuffer.prototype.putString = function(e) {
  return this.putBytes(e, "utf16");
};
util$1.DataBuffer.prototype.putInt16 = function(e) {
  return this.accommodate(2), this.data.setInt16(this.write, e), this.write += 2, this;
};
util$1.DataBuffer.prototype.putInt24 = function(e) {
  return this.accommodate(3), this.data.setInt16(this.write, e >> 8 & 65535), this.data.setInt8(this.write, e >> 16 & 255), this.write += 3, this;
};
util$1.DataBuffer.prototype.putInt32 = function(e) {
  return this.accommodate(4), this.data.setInt32(this.write, e), this.write += 4, this;
};
util$1.DataBuffer.prototype.putInt16Le = function(e) {
  return this.accommodate(2), this.data.setInt16(this.write, e, !0), this.write += 2, this;
};
util$1.DataBuffer.prototype.putInt24Le = function(e) {
  return this.accommodate(3), this.data.setInt8(this.write, e >> 16 & 255), this.data.setInt16(this.write, e >> 8 & 65535, !0), this.write += 3, this;
};
util$1.DataBuffer.prototype.putInt32Le = function(e) {
  return this.accommodate(4), this.data.setInt32(this.write, e, !0), this.write += 4, this;
};
util$1.DataBuffer.prototype.putInt = function(e, t) {
  _checkBitsParam(t), this.accommodate(t / 8);
  do
    t -= 8, this.data.setInt8(this.write++, e >> t & 255);
  while (t > 0);
  return this;
};
util$1.DataBuffer.prototype.putSignedInt = function(e, t) {
  return _checkBitsParam(t), this.accommodate(t / 8), e < 0 && (e += 2 << t - 1), this.putInt(e, t);
};
util$1.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
util$1.DataBuffer.prototype.getInt16 = function() {
  var e = this.data.getInt16(this.read);
  return this.read += 2, e;
};
util$1.DataBuffer.prototype.getInt24 = function() {
  var e = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  return this.read += 3, e;
};
util$1.DataBuffer.prototype.getInt32 = function() {
  var e = this.data.getInt32(this.read);
  return this.read += 4, e;
};
util$1.DataBuffer.prototype.getInt16Le = function() {
  var e = this.data.getInt16(this.read, !0);
  return this.read += 2, e;
};
util$1.DataBuffer.prototype.getInt24Le = function() {
  var e = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8;
  return this.read += 3, e;
};
util$1.DataBuffer.prototype.getInt32Le = function() {
  var e = this.data.getInt32(this.read, !0);
  return this.read += 4, e;
};
util$1.DataBuffer.prototype.getInt = function(e) {
  _checkBitsParam(e);
  var t = 0;
  do
    t = (t << 8) + this.data.getInt8(this.read++), e -= 8;
  while (e > 0);
  return t;
};
util$1.DataBuffer.prototype.getSignedInt = function(e) {
  var t = this.getInt(e), a = 2 << e - 2;
  return t >= a && (t -= a << 1), t;
};
util$1.DataBuffer.prototype.getBytes = function(e) {
  var t;
  return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : e === 0 ? t = "" : (t = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), t;
};
util$1.DataBuffer.prototype.bytes = function(e) {
  return typeof e > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e);
};
util$1.DataBuffer.prototype.at = function(e) {
  return this.data.getUint8(this.read + e);
};
util$1.DataBuffer.prototype.setAt = function(e, t) {
  return this.data.setUint8(e, t), this;
};
util$1.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
util$1.DataBuffer.prototype.copy = function() {
  return new util$1.DataBuffer(this);
};
util$1.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var e = new Uint8Array(this.data.buffer, this.read), t = new Uint8Array(e.byteLength);
    t.set(e), this.data = new DataView(t), this.write -= this.read, this.read = 0;
  }
  return this;
};
util$1.DataBuffer.prototype.clear = function() {
  return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
};
util$1.DataBuffer.prototype.truncate = function(e) {
  return this.write = Math.max(0, this.length() - e), this.read = Math.min(this.read, this.write), this;
};
util$1.DataBuffer.prototype.toHex = function() {
  for (var e = "", t = this.read; t < this.data.byteLength; ++t) {
    var a = this.data.getUint8(t);
    a < 16 && (e += "0"), e += a.toString(16);
  }
  return e;
};
util$1.DataBuffer.prototype.toString = function(e) {
  var t = new Uint8Array(this.data, this.read, this.length());
  if (e = e || "utf8", e === "binary" || e === "raw")
    return util$1.binary.raw.encode(t);
  if (e === "hex")
    return util$1.binary.hex.encode(t);
  if (e === "base64")
    return util$1.binary.base64.encode(t);
  if (e === "utf8")
    return util$1.text.utf8.decode(t);
  if (e === "utf16")
    return util$1.text.utf16.decode(t);
  throw new Error("Invalid encoding: " + e);
};
util$1.createBuffer = function(e, t) {
  return t = t || "raw", e !== void 0 && t === "utf8" && (e = util$1.encodeUtf8(e)), new util$1.ByteBuffer(e);
};
util$1.fillString = function(e, t) {
  for (var a = ""; t > 0; )
    t & 1 && (a += e), t >>>= 1, t > 0 && (e += e);
  return a;
};
util$1.xorBytes = function(e, t, a) {
  for (var n = "", u = "", o = "", l = 0, h = 0; a > 0; --a, ++l)
    u = e.charCodeAt(l) ^ t.charCodeAt(l), h >= 10 && (n += o, o = "", h = 0), o += String.fromCharCode(u), ++h;
  return n += o, n;
};
util$1.hexToBytes = function(e) {
  var t = "", a = 0;
  for (e.length & !0 && (a = 1, t += String.fromCharCode(parseInt(e[0], 16))); a < e.length; a += 2)
    t += String.fromCharCode(parseInt(e.substr(a, 2), 16));
  return t;
};
util$1.bytesToHex = function(e) {
  return util$1.createBuffer(e).toHex();
};
util$1.int32ToBytes = function(e) {
  return String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255);
};
var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", _base64Idx = [
  /*43 -43 = 0*/
  /*'+',  1,  2,  3,'/' */
  62,
  -1,
  -1,
  -1,
  63,
  /*'0','1','2','3','4','5','6','7','8','9' */
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  /*15, 16, 17,'=', 19, 20, 21 */
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  /*65 - 43 = 22*/
  /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  /*91 - 43 = 48 */
  /*48, 49, 50, 51, 52, 53 */
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  /*97 - 43 = 54*/
  /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
], _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
util$1.encode64 = function(e, t) {
  for (var a = "", n = "", u, o, l, h = 0; h < e.length; )
    u = e.charCodeAt(h++), o = e.charCodeAt(h++), l = e.charCodeAt(h++), a += _base64.charAt(u >> 2), a += _base64.charAt((u & 3) << 4 | o >> 4), isNaN(o) ? a += "==" : (a += _base64.charAt((o & 15) << 2 | l >> 6), a += isNaN(l) ? "=" : _base64.charAt(l & 63)), t && a.length > t && (n += a.substr(0, t) + `\r
`, a = a.substr(t));
  return n += a, n;
};
util$1.decode64 = function(e) {
  e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  for (var t = "", a, n, u, o, l = 0; l < e.length; )
    a = _base64Idx[e.charCodeAt(l++) - 43], n = _base64Idx[e.charCodeAt(l++) - 43], u = _base64Idx[e.charCodeAt(l++) - 43], o = _base64Idx[e.charCodeAt(l++) - 43], t += String.fromCharCode(a << 2 | n >> 4), u !== 64 && (t += String.fromCharCode((n & 15) << 4 | u >> 2), o !== 64 && (t += String.fromCharCode((u & 3) << 6 | o)));
  return t;
};
util$1.encodeUtf8 = function(e) {
  return unescape(encodeURIComponent(e));
};
util$1.decodeUtf8 = function(e) {
  return decodeURIComponent(escape(e));
};
util$1.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: baseN.encode,
    decode: baseN.decode
  }
};
util$1.binary.raw.encode = function(e) {
  return String.fromCharCode.apply(null, e);
};
util$1.binary.raw.decode = function(e, t, a) {
  var n = t;
  n || (n = new Uint8Array(e.length)), a = a || 0;
  for (var u = a, o = 0; o < e.length; ++o)
    n[u++] = e.charCodeAt(o);
  return t ? u - a : n;
};
util$1.binary.hex.encode = util$1.bytesToHex;
util$1.binary.hex.decode = function(e, t, a) {
  var n = t;
  n || (n = new Uint8Array(Math.ceil(e.length / 2))), a = a || 0;
  var u = 0, o = a;
  for (e.length & 1 && (u = 1, n[o++] = parseInt(e[0], 16)); u < e.length; u += 2)
    n[o++] = parseInt(e.substr(u, 2), 16);
  return t ? o - a : n;
};
util$1.binary.base64.encode = function(e, t) {
  for (var a = "", n = "", u, o, l, h = 0; h < e.byteLength; )
    u = e[h++], o = e[h++], l = e[h++], a += _base64.charAt(u >> 2), a += _base64.charAt((u & 3) << 4 | o >> 4), isNaN(o) ? a += "==" : (a += _base64.charAt((o & 15) << 2 | l >> 6), a += isNaN(l) ? "=" : _base64.charAt(l & 63)), t && a.length > t && (n += a.substr(0, t) + `\r
`, a = a.substr(t));
  return n += a, n;
};
util$1.binary.base64.decode = function(e, t, a) {
  var n = t;
  n || (n = new Uint8Array(Math.ceil(e.length / 4) * 3)), e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""), a = a || 0;
  for (var u, o, l, h, y = 0, _ = a; y < e.length; )
    u = _base64Idx[e.charCodeAt(y++) - 43], o = _base64Idx[e.charCodeAt(y++) - 43], l = _base64Idx[e.charCodeAt(y++) - 43], h = _base64Idx[e.charCodeAt(y++) - 43], n[_++] = u << 2 | o >> 4, l !== 64 && (n[_++] = (o & 15) << 4 | l >> 2, h !== 64 && (n[_++] = (l & 3) << 6 | h));
  return t ? _ - a : n.subarray(0, _);
};
util$1.binary.base58.encode = function(e, t) {
  return util$1.binary.baseN.encode(e, _base58, t);
};
util$1.binary.base58.decode = function(e, t) {
  return util$1.binary.baseN.decode(e, _base58, t);
};
util$1.text = {
  utf8: {},
  utf16: {}
};
util$1.text.utf8.encode = function(e, t, a) {
  e = util$1.encodeUtf8(e);
  var n = t;
  n || (n = new Uint8Array(e.length)), a = a || 0;
  for (var u = a, o = 0; o < e.length; ++o)
    n[u++] = e.charCodeAt(o);
  return t ? u - a : n;
};
util$1.text.utf8.decode = function(e) {
  return util$1.decodeUtf8(String.fromCharCode.apply(null, e));
};
util$1.text.utf16.encode = function(e, t, a) {
  var n = t;
  n || (n = new Uint8Array(e.length * 2));
  var u = new Uint16Array(n.buffer);
  a = a || 0;
  for (var o = a, l = a, h = 0; h < e.length; ++h)
    u[l++] = e.charCodeAt(h), o += 2;
  return t ? o - a : n;
};
util$1.text.utf16.decode = function(e) {
  return String.fromCharCode.apply(null, new Uint16Array(e.buffer));
};
util$1.deflate = function(e, t, a) {
  if (t = util$1.decode64(e.deflate(util$1.encode64(t)).rval), a) {
    var n = 2, u = t.charCodeAt(1);
    u & 32 && (n = 6), t = t.substring(n, t.length - 4);
  }
  return t;
};
util$1.inflate = function(e, t, a) {
  var n = e.inflate(util$1.encode64(t)).rval;
  return n === null ? null : util$1.decode64(n);
};
var _setStorageObject = function(e, t, a) {
  if (!e)
    throw new Error("WebStorage not available.");
  var n;
  if (a === null ? n = e.removeItem(t) : (a = util$1.encode64(JSON.stringify(a)), n = e.setItem(t, a)), typeof n < "u" && n.rval !== !0) {
    var u = new Error(n.error.message);
    throw u.id = n.error.id, u.name = n.error.name, u;
  }
}, _getStorageObject = function(e, t) {
  if (!e)
    throw new Error("WebStorage not available.");
  var a = e.getItem(t);
  if (e.init)
    if (a.rval === null) {
      if (a.error) {
        var n = new Error(a.error.message);
        throw n.id = a.error.id, n.name = a.error.name, n;
      }
      a = null;
    } else
      a = a.rval;
  return a !== null && (a = JSON.parse(util$1.decode64(a))), a;
}, _setItem = function(e, t, a, n) {
  var u = _getStorageObject(e, t);
  u === null && (u = {}), u[a] = n, _setStorageObject(e, t, u);
}, _getItem = function(e, t, a) {
  var n = _getStorageObject(e, t);
  return n !== null && (n = a in n ? n[a] : null), n;
}, _removeItem = function(e, t, a) {
  var n = _getStorageObject(e, t);
  if (n !== null && a in n) {
    delete n[a];
    var u = !0;
    for (var o in n) {
      u = !1;
      break;
    }
    u && (n = null), _setStorageObject(e, t, n);
  }
}, _clearItems = function(e, t) {
  _setStorageObject(e, t, null);
}, _callStorageFunction = function(e, t, a) {
  var n = null;
  typeof a > "u" && (a = ["web", "flash"]);
  var u, o = !1, l = null;
  for (var h in a) {
    u = a[h];
    try {
      if (u === "flash" || u === "both") {
        if (t[0] === null)
          throw new Error("Flash local storage not available.");
        n = e.apply(this, t), o = u === "flash";
      }
      (u === "web" || u === "both") && (t[0] = localStorage, n = e.apply(this, t), o = !0);
    } catch (y) {
      l = y;
    }
    if (o)
      break;
  }
  if (!o)
    throw l;
  return n;
};
util$1.setItem = function(e, t, a, n, u) {
  _callStorageFunction(_setItem, arguments, u);
};
util$1.getItem = function(e, t, a, n) {
  return _callStorageFunction(_getItem, arguments, n);
};
util$1.removeItem = function(e, t, a, n) {
  _callStorageFunction(_removeItem, arguments, n);
};
util$1.clearItems = function(e, t, a) {
  _callStorageFunction(_clearItems, arguments, a);
};
util$1.isEmpty = function(e) {
  for (var t in e)
    if (e.hasOwnProperty(t))
      return !1;
  return !0;
};
util$1.format = function(e) {
  for (var t = /%./g, a, n, u = 0, o = [], l = 0; a = t.exec(e); ) {
    n = e.substring(l, t.lastIndex - 2), n.length > 0 && o.push(n), l = t.lastIndex;
    var h = a[0][1];
    switch (h) {
      case "s":
      case "o":
        u < arguments.length ? o.push(arguments[u++ + 1]) : o.push("<?>");
        break;
      case "%":
        o.push("%");
        break;
      default:
        o.push("<%" + h + "?>");
    }
  }
  return o.push(e.substring(l)), o.join("");
};
util$1.formatNumber = function(e, t, a, n) {
  var u = e, o = isNaN(t = Math.abs(t)) ? 2 : t, l = a === void 0 ? "," : a, h = n === void 0 ? "." : n, y = u < 0 ? "-" : "", _ = parseInt(u = Math.abs(+u || 0).toFixed(o), 10) + "", d = _.length > 3 ? _.length % 3 : 0;
  return y + (d ? _.substr(0, d) + h : "") + _.substr(d).replace(/(\d{3})(?=\d)/g, "$1" + h) + (o ? l + Math.abs(u - _).toFixed(o).slice(2) : "");
};
util$1.formatSize = function(e) {
  return e >= 1073741824 ? e = util$1.formatNumber(e / 1073741824, 2, ".", "") + " GiB" : e >= 1048576 ? e = util$1.formatNumber(e / 1048576, 2, ".", "") + " MiB" : e >= 1024 ? e = util$1.formatNumber(e / 1024, 0) + " KiB" : e = util$1.formatNumber(e, 0) + " bytes", e;
};
util$1.bytesFromIP = function(e) {
  return e.indexOf(".") !== -1 ? util$1.bytesFromIPv4(e) : e.indexOf(":") !== -1 ? util$1.bytesFromIPv6(e) : null;
};
util$1.bytesFromIPv4 = function(e) {
  if (e = e.split("."), e.length !== 4)
    return null;
  for (var t = util$1.createBuffer(), a = 0; a < e.length; ++a) {
    var n = parseInt(e[a], 10);
    if (isNaN(n))
      return null;
    t.putByte(n);
  }
  return t.getBytes();
};
util$1.bytesFromIPv6 = function(e) {
  var t = 0;
  e = e.split(":").filter(function(l) {
    return l.length === 0 && ++t, !0;
  });
  for (var a = (8 - e.length + t) * 2, n = util$1.createBuffer(), u = 0; u < 8; ++u) {
    if (!e[u] || e[u].length === 0) {
      n.fillWithByte(0, a), a = 0;
      continue;
    }
    var o = util$1.hexToBytes(e[u]);
    o.length < 2 && n.putByte(0), n.putBytes(o);
  }
  return n.getBytes();
};
util$1.bytesToIP = function(e) {
  return e.length === 4 ? util$1.bytesToIPv4(e) : e.length === 16 ? util$1.bytesToIPv6(e) : null;
};
util$1.bytesToIPv4 = function(e) {
  if (e.length !== 4)
    return null;
  for (var t = [], a = 0; a < e.length; ++a)
    t.push(e.charCodeAt(a));
  return t.join(".");
};
util$1.bytesToIPv6 = function(e) {
  if (e.length !== 16)
    return null;
  for (var t = [], a = [], n = 0, u = 0; u < e.length; u += 2) {
    for (var o = util$1.bytesToHex(e[u] + e[u + 1]); o[0] === "0" && o !== "0"; )
      o = o.substr(1);
    if (o === "0") {
      var l = a[a.length - 1], h = t.length;
      !l || h !== l.end + 1 ? a.push({ start: h, end: h }) : (l.end = h, l.end - l.start > a[n].end - a[n].start && (n = a.length - 1));
    }
    t.push(o);
  }
  if (a.length > 0) {
    var y = a[n];
    y.end - y.start > 0 && (t.splice(y.start, y.end - y.start + 1, ""), y.start === 0 && t.unshift(""), y.end === 7 && t.push(""));
  }
  return t.join(":");
};
util$1.estimateCores = function(e, t) {
  if (typeof e == "function" && (t = e, e = {}), e = e || {}, "cores" in util$1 && !e.update)
    return t(null, util$1.cores);
  if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
    return util$1.cores = navigator.hardwareConcurrency, t(null, util$1.cores);
  if (typeof Worker > "u")
    return util$1.cores = 1, t(null, util$1.cores);
  if (typeof Blob > "u")
    return util$1.cores = 2, t(null, util$1.cores);
  var a = URL.createObjectURL(new Blob([
    "(",
    (function() {
      self.addEventListener("message", function(l) {
        var h = Date.now(), y = h + 4;
        self.postMessage({ st: h, et: y });
      });
    }).toString(),
    ")()"
  ], { type: "application/javascript" }));
  n([], 5, 16);
  function n(l, h, y) {
    if (h === 0) {
      var _ = Math.floor(l.reduce(function(d, $) {
        return d + $;
      }, 0) / l.length);
      return util$1.cores = Math.max(1, _), URL.revokeObjectURL(a), t(null, util$1.cores);
    }
    u(y, function(d, $) {
      l.push(o(y, $)), n(l, h - 1, y);
    });
  }
  function u(l, h) {
    for (var y = [], _ = [], d = 0; d < l; ++d) {
      var $ = new Worker(a);
      $.addEventListener("message", function(N) {
        if (_.push(N.data), _.length === l) {
          for (var U = 0; U < l; ++U)
            y[U].terminate();
          h(null, _);
        }
      }), y.push($);
    }
    for (var d = 0; d < l; ++d)
      y[d].postMessage(d);
  }
  function o(l, h) {
    for (var y = [], _ = 0; _ < l; ++_)
      for (var d = h[_], $ = y[_] = [], N = 0; N < l; ++N)
        if (_ !== N) {
          var U = h[N];
          (d.st > U.st && d.st < U.et || U.st > d.st && U.st < d.et) && $.push(N);
        }
    return y.reduce(function(V, Q) {
      return Math.max(V, Q.length);
    }, 0);
  }
};
var forge$B = forge$D;
forge$B.cipher = forge$B.cipher || {};
forge$B.cipher.algorithms = forge$B.cipher.algorithms || {};
forge$B.cipher.createCipher = function(e, t) {
  var a = e;
  if (typeof a == "string" && (a = forge$B.cipher.getAlgorithm(a), a && (a = a())), !a)
    throw new Error("Unsupported algorithm: " + e);
  return new forge$B.cipher.BlockCipher({
    algorithm: a,
    key: t,
    decrypt: !1
  });
};
forge$B.cipher.createDecipher = function(e, t) {
  var a = e;
  if (typeof a == "string" && (a = forge$B.cipher.getAlgorithm(a), a && (a = a())), !a)
    throw new Error("Unsupported algorithm: " + e);
  return new forge$B.cipher.BlockCipher({
    algorithm: a,
    key: t,
    decrypt: !0
  });
};
forge$B.cipher.registerAlgorithm = function(e, t) {
  e = e.toUpperCase(), forge$B.cipher.algorithms[e] = t;
};
forge$B.cipher.getAlgorithm = function(e) {
  return e = e.toUpperCase(), e in forge$B.cipher.algorithms ? forge$B.cipher.algorithms[e] : null;
};
var BlockCipher = forge$B.cipher.BlockCipher = function(e) {
  this.algorithm = e.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = e.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = e.decrypt, this.algorithm.initialize(e);
};
BlockCipher.prototype.start = function(e) {
  e = e || {};
  var t = {};
  for (var a in e)
    t[a] = e[a];
  t.decrypt = this._decrypt, this._finish = !1, this._input = forge$B.util.createBuffer(), this.output = e.output || forge$B.util.createBuffer(), this.mode.start(t);
};
BlockCipher.prototype.update = function(e) {
  for (e && this._input.putBuffer(e); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; )
    ;
  this._input.compact();
};
BlockCipher.prototype.finish = function(e) {
  e && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function(a) {
    return e(this.blockSize, a, !1);
  }, this.mode.unpad = function(a) {
    return e(this.blockSize, a, !0);
  });
  var t = {};
  return t.decrypt = this._decrypt, t.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, t) || (this._finish = !0, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, t)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, t));
};
var forge$A = forge$D;
forge$A.cipher = forge$A.cipher || {};
var modes = forge$A.cipher.modes = forge$A.cipher.modes || {};
modes.ecb = function(e) {
  e = e || {}, this.name = "ECB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
modes.ecb.prototype.start = function(e) {
};
modes.ecb.prototype.encrypt = function(e, t, a) {
  if (e.length() < this.blockSize && !(a && e.length() > 0))
    return !0;
  for (var n = 0; n < this._ints; ++n)
    this._inBlock[n] = e.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var n = 0; n < this._ints; ++n)
    t.putInt32(this._outBlock[n]);
};
modes.ecb.prototype.decrypt = function(e, t, a) {
  if (e.length() < this.blockSize && !(a && e.length() > 0))
    return !0;
  for (var n = 0; n < this._ints; ++n)
    this._inBlock[n] = e.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var n = 0; n < this._ints; ++n)
    t.putInt32(this._outBlock[n]);
};
modes.ecb.prototype.pad = function(e, t) {
  var a = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length();
  return e.fillWithByte(a, a), !0;
};
modes.ecb.prototype.unpad = function(e, t) {
  if (t.overflow > 0)
    return !1;
  var a = e.length(), n = e.at(a - 1);
  return n > this.blockSize << 2 ? !1 : (e.truncate(n), !0);
};
modes.cbc = function(e) {
  e = e || {}, this.name = "CBC", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
modes.cbc.prototype.start = function(e) {
  if (e.iv === null) {
    if (!this._prev)
      throw new Error("Invalid IV parameter.");
    this._iv = this._prev.slice(0);
  } else if ("iv" in e)
    this._iv = transformIV(e.iv, this.blockSize), this._prev = this._iv.slice(0);
  else
    throw new Error("Invalid IV parameter.");
};
modes.cbc.prototype.encrypt = function(e, t, a) {
  if (e.length() < this.blockSize && !(a && e.length() > 0))
    return !0;
  for (var n = 0; n < this._ints; ++n)
    this._inBlock[n] = this._prev[n] ^ e.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var n = 0; n < this._ints; ++n)
    t.putInt32(this._outBlock[n]);
  this._prev = this._outBlock;
};
modes.cbc.prototype.decrypt = function(e, t, a) {
  if (e.length() < this.blockSize && !(a && e.length() > 0))
    return !0;
  for (var n = 0; n < this._ints; ++n)
    this._inBlock[n] = e.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var n = 0; n < this._ints; ++n)
    t.putInt32(this._prev[n] ^ this._outBlock[n]);
  this._prev = this._inBlock.slice(0);
};
modes.cbc.prototype.pad = function(e, t) {
  var a = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length();
  return e.fillWithByte(a, a), !0;
};
modes.cbc.prototype.unpad = function(e, t) {
  if (t.overflow > 0)
    return !1;
  var a = e.length(), n = e.at(a - 1);
  return n > this.blockSize << 2 ? !1 : (e.truncate(n), !0);
};
modes.cfb = function(e) {
  e = e || {}, this.name = "CFB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = forge$A.util.createBuffer(), this._partialBytes = 0;
};
modes.cfb.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  this._iv = transformIV(e.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
modes.cfb.prototype.encrypt = function(e, t, a) {
  var n = e.length();
  if (n === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
    for (var u = 0; u < this._ints; ++u)
      this._inBlock[u] = e.getInt32() ^ this._outBlock[u], t.putInt32(this._inBlock[u]);
    return;
  }
  var o = (this.blockSize - n) % this.blockSize;
  o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
  for (var u = 0; u < this._ints; ++u)
    this._partialBlock[u] = e.getInt32() ^ this._outBlock[u], this._partialOutput.putInt32(this._partialBlock[u]);
  if (o > 0)
    e.read -= this.blockSize;
  else
    for (var u = 0; u < this._ints; ++u)
      this._inBlock[u] = this._partialBlock[u];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !a)
    return t.putBytes(this._partialOutput.getBytes(
      o - this._partialBytes
    )), this._partialBytes = o, !0;
  t.putBytes(this._partialOutput.getBytes(
    n - this._partialBytes
  )), this._partialBytes = 0;
};
modes.cfb.prototype.decrypt = function(e, t, a) {
  var n = e.length();
  if (n === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
    for (var u = 0; u < this._ints; ++u)
      this._inBlock[u] = e.getInt32(), t.putInt32(this._inBlock[u] ^ this._outBlock[u]);
    return;
  }
  var o = (this.blockSize - n) % this.blockSize;
  o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
  for (var u = 0; u < this._ints; ++u)
    this._partialBlock[u] = e.getInt32(), this._partialOutput.putInt32(this._partialBlock[u] ^ this._outBlock[u]);
  if (o > 0)
    e.read -= this.blockSize;
  else
    for (var u = 0; u < this._ints; ++u)
      this._inBlock[u] = this._partialBlock[u];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !a)
    return t.putBytes(this._partialOutput.getBytes(
      o - this._partialBytes
    )), this._partialBytes = o, !0;
  t.putBytes(this._partialOutput.getBytes(
    n - this._partialBytes
  )), this._partialBytes = 0;
};
modes.ofb = function(e) {
  e = e || {}, this.name = "OFB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = forge$A.util.createBuffer(), this._partialBytes = 0;
};
modes.ofb.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  this._iv = transformIV(e.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
modes.ofb.prototype.encrypt = function(e, t, a) {
  var n = e.length();
  if (e.length() === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
    for (var u = 0; u < this._ints; ++u)
      t.putInt32(e.getInt32() ^ this._outBlock[u]), this._inBlock[u] = this._outBlock[u];
    return;
  }
  var o = (this.blockSize - n) % this.blockSize;
  o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
  for (var u = 0; u < this._ints; ++u)
    this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[u]);
  if (o > 0)
    e.read -= this.blockSize;
  else
    for (var u = 0; u < this._ints; ++u)
      this._inBlock[u] = this._outBlock[u];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !a)
    return t.putBytes(this._partialOutput.getBytes(
      o - this._partialBytes
    )), this._partialBytes = o, !0;
  t.putBytes(this._partialOutput.getBytes(
    n - this._partialBytes
  )), this._partialBytes = 0;
};
modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
modes.ctr = function(e) {
  e = e || {}, this.name = "CTR", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = forge$A.util.createBuffer(), this._partialBytes = 0;
};
modes.ctr.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  this._iv = transformIV(e.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
modes.ctr.prototype.encrypt = function(e, t, a) {
  var n = e.length();
  if (n === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)
    for (var u = 0; u < this._ints; ++u)
      t.putInt32(e.getInt32() ^ this._outBlock[u]);
  else {
    var o = (this.blockSize - n) % this.blockSize;
    o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
    for (var u = 0; u < this._ints; ++u)
      this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[u]);
    if (o > 0 && (e.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !a)
      return t.putBytes(this._partialOutput.getBytes(
        o - this._partialBytes
      )), this._partialBytes = o, !0;
    t.putBytes(this._partialOutput.getBytes(
      n - this._partialBytes
    )), this._partialBytes = 0;
  }
  inc32(this._inBlock);
};
modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
modes.gcm = function(e) {
  e = e || {}, this.name = "GCM", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = forge$A.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
};
modes.gcm.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  var t = forge$A.util.createBuffer(e.iv);
  this._cipherLength = 0;
  var a;
  if ("additionalData" in e ? a = forge$A.util.createBuffer(e.additionalData) : a = forge$A.util.createBuffer(), "tagLength" in e ? this._tagLength = e.tagLength : this._tagLength = 128, this._tag = null, e.decrypt && (this._tag = forge$A.util.createBuffer(e.tag).getBytes(), this._tag.length !== this._tagLength / 8))
    throw new Error("Authentication tag does not match tag length.");
  this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var n = t.length();
  if (n === 12)
    this._j0 = [t.getInt32(), t.getInt32(), t.getInt32(), 1];
  else {
    for (this._j0 = [0, 0, 0, 0]; t.length() > 0; )
      this._j0 = this.ghash(
        this._hashSubkey,
        this._j0,
        [t.getInt32(), t.getInt32(), t.getInt32(), t.getInt32()]
      );
    this._j0 = this.ghash(
      this._hashSubkey,
      this._j0,
      [0, 0].concat(from64To32(n * 8))
    );
  }
  this._inBlock = this._j0.slice(0), inc32(this._inBlock), this._partialBytes = 0, a = forge$A.util.createBuffer(a), this._aDataLength = from64To32(a.length() * 8);
  var u = a.length() % this.blockSize;
  for (u && a.fillWithByte(0, this.blockSize - u), this._s = [0, 0, 0, 0]; a.length() > 0; )
    this._s = this.ghash(this._hashSubkey, this._s, [
      a.getInt32(),
      a.getInt32(),
      a.getInt32(),
      a.getInt32()
    ]);
};
modes.gcm.prototype.encrypt = function(e, t, a) {
  var n = e.length();
  if (n === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
    for (var u = 0; u < this._ints; ++u)
      t.putInt32(this._outBlock[u] ^= e.getInt32());
    this._cipherLength += this.blockSize;
  } else {
    var o = (this.blockSize - n) % this.blockSize;
    o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
    for (var u = 0; u < this._ints; ++u)
      this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[u]);
    if (o <= 0 || a) {
      if (a) {
        var l = n % this.blockSize;
        this._cipherLength += l, this._partialOutput.truncate(this.blockSize - l);
      } else
        this._cipherLength += this.blockSize;
      for (var u = 0; u < this._ints; ++u)
        this._outBlock[u] = this._partialOutput.getInt32();
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !a)
      return e.read -= this.blockSize, t.putBytes(this._partialOutput.getBytes(
        o - this._partialBytes
      )), this._partialBytes = o, !0;
    t.putBytes(this._partialOutput.getBytes(
      n - this._partialBytes
    )), this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), inc32(this._inBlock);
};
modes.gcm.prototype.decrypt = function(e, t, a) {
  var n = e.length();
  if (n < this.blockSize && !(a && n > 0))
    return !0;
  this.cipher.encrypt(this._inBlock, this._outBlock), inc32(this._inBlock), this._hashBlock[0] = e.getInt32(), this._hashBlock[1] = e.getInt32(), this._hashBlock[2] = e.getInt32(), this._hashBlock[3] = e.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var u = 0; u < this._ints; ++u)
    t.putInt32(this._outBlock[u] ^ this._hashBlock[u]);
  n < this.blockSize ? this._cipherLength += n % this.blockSize : this._cipherLength += this.blockSize;
};
modes.gcm.prototype.afterFinish = function(e, t) {
  var a = !0;
  t.decrypt && t.overflow && e.truncate(this.blockSize - t.overflow), this.tag = forge$A.util.createBuffer();
  var n = this._aDataLength.concat(from64To32(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, n);
  var u = [];
  this.cipher.encrypt(this._j0, u);
  for (var o = 0; o < this._ints; ++o)
    this.tag.putInt32(this._s[o] ^ u[o]);
  return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), t.decrypt && this.tag.bytes() !== this._tag && (a = !1), a;
};
modes.gcm.prototype.multiply = function(e, t) {
  for (var a = [0, 0, 0, 0], n = t.slice(0), u = 0; u < 128; ++u) {
    var o = e[u / 32 | 0] & 1 << 31 - u % 32;
    o && (a[0] ^= n[0], a[1] ^= n[1], a[2] ^= n[2], a[3] ^= n[3]), this.pow(n, n);
  }
  return a;
};
modes.gcm.prototype.pow = function(e, t) {
  for (var a = e[3] & 1, n = 3; n > 0; --n)
    t[n] = e[n] >>> 1 | (e[n - 1] & 1) << 31;
  t[0] = e[0] >>> 1, a && (t[0] ^= this._R);
};
modes.gcm.prototype.tableMultiply = function(e) {
  for (var t = [0, 0, 0, 0], a = 0; a < 32; ++a) {
    var n = a / 8 | 0, u = e[n] >>> (7 - a % 8) * 4 & 15, o = this._m[a][u];
    t[0] ^= o[0], t[1] ^= o[1], t[2] ^= o[2], t[3] ^= o[3];
  }
  return t;
};
modes.gcm.prototype.ghash = function(e, t, a) {
  return t[0] ^= a[0], t[1] ^= a[1], t[2] ^= a[2], t[3] ^= a[3], this.tableMultiply(t);
};
modes.gcm.prototype.generateHashTable = function(e, t) {
  for (var a = 8 / t, n = 4 * a, u = 16 * a, o = new Array(u), l = 0; l < u; ++l) {
    var h = [0, 0, 0, 0], y = l / n | 0, _ = (n - 1 - l % n) * t;
    h[y] = 1 << t - 1 << _, o[l] = this.generateSubHashTable(this.multiply(h, e), t);
  }
  return o;
};
modes.gcm.prototype.generateSubHashTable = function(e, t) {
  var a = 1 << t, n = a >>> 1, u = new Array(a);
  u[n] = e.slice(0);
  for (var o = n >>> 1; o > 0; )
    this.pow(u[2 * o], u[o] = []), o >>= 1;
  for (o = 2; o < n; ) {
    for (var l = 1; l < o; ++l) {
      var h = u[o], y = u[l];
      u[o + l] = [
        h[0] ^ y[0],
        h[1] ^ y[1],
        h[2] ^ y[2],
        h[3] ^ y[3]
      ];
    }
    o *= 2;
  }
  for (u[0] = [0, 0, 0, 0], o = n + 1; o < a; ++o) {
    var _ = u[o ^ n];
    u[o] = [e[0] ^ _[0], e[1] ^ _[1], e[2] ^ _[2], e[3] ^ _[3]];
  }
  return u;
};
function transformIV(e, t) {
  if (typeof e == "string" && (e = forge$A.util.createBuffer(e)), forge$A.util.isArray(e) && e.length > 4) {
    var a = e;
    e = forge$A.util.createBuffer();
    for (var n = 0; n < a.length; ++n)
      e.putByte(a[n]);
  }
  if (e.length() < t)
    throw new Error(
      "Invalid IV length; got " + e.length() + " bytes and expected " + t + " bytes."
    );
  if (!forge$A.util.isArray(e)) {
    for (var u = [], o = t / 4, n = 0; n < o; ++n)
      u.push(e.getInt32());
    e = u;
  }
  return e;
}
function inc32(e) {
  e[e.length - 1] = e[e.length - 1] + 1 & 4294967295;
}
function from64To32(e) {
  return [e / 4294967296 | 0, e & 4294967295];
}
var forge$z = forge$D;
forge$z.aes = forge$z.aes || {};
forge$z.aes.startEncrypting = function(e, t, a, n) {
  var u = _createCipher$1({
    key: e,
    output: a,
    decrypt: !1,
    mode: n
  });
  return u.start(t), u;
};
forge$z.aes.createEncryptionCipher = function(e, t) {
  return _createCipher$1({
    key: e,
    output: null,
    decrypt: !1,
    mode: t
  });
};
forge$z.aes.startDecrypting = function(e, t, a, n) {
  var u = _createCipher$1({
    key: e,
    output: a,
    decrypt: !0,
    mode: n
  });
  return u.start(t), u;
};
forge$z.aes.createDecryptionCipher = function(e, t) {
  return _createCipher$1({
    key: e,
    output: null,
    decrypt: !0,
    mode: t
  });
};
forge$z.aes.Algorithm = function(e, t) {
  init || initialize();
  var a = this;
  a.name = e, a.mode = new t({
    blockSize: 16,
    cipher: {
      encrypt: function(n, u) {
        return _updateBlock$1(a._w, n, u, !1);
      },
      decrypt: function(n, u) {
        return _updateBlock$1(a._w, n, u, !0);
      }
    }
  }), a._init = !1;
};
forge$z.aes.Algorithm.prototype.initialize = function(e) {
  if (!this._init) {
    var t = e.key, a;
    if (typeof t == "string" && (t.length === 16 || t.length === 24 || t.length === 32))
      t = forge$z.util.createBuffer(t);
    else if (forge$z.util.isArray(t) && (t.length === 16 || t.length === 24 || t.length === 32)) {
      a = t, t = forge$z.util.createBuffer();
      for (var n = 0; n < a.length; ++n)
        t.putByte(a[n]);
    }
    if (!forge$z.util.isArray(t)) {
      a = t, t = [];
      var u = a.length();
      if (u === 16 || u === 24 || u === 32) {
        u = u >>> 2;
        for (var n = 0; n < u; ++n)
          t.push(a.getInt32());
      }
    }
    if (!forge$z.util.isArray(t) || !(t.length === 4 || t.length === 6 || t.length === 8))
      throw new Error("Invalid key parameter.");
    var o = this.mode.name, l = ["CFB", "OFB", "CTR", "GCM"].indexOf(o) !== -1;
    this._w = _expandKey(t, e.decrypt && !l), this._init = !0;
  }
};
forge$z.aes._expandKey = function(e, t) {
  return init || initialize(), _expandKey(e, t);
};
forge$z.aes._updateBlock = _updateBlock$1;
registerAlgorithm$1("AES-ECB", forge$z.cipher.modes.ecb);
registerAlgorithm$1("AES-CBC", forge$z.cipher.modes.cbc);
registerAlgorithm$1("AES-CFB", forge$z.cipher.modes.cfb);
registerAlgorithm$1("AES-OFB", forge$z.cipher.modes.ofb);
registerAlgorithm$1("AES-CTR", forge$z.cipher.modes.ctr);
registerAlgorithm$1("AES-GCM", forge$z.cipher.modes.gcm);
function registerAlgorithm$1(e, t) {
  var a = function() {
    return new forge$z.aes.Algorithm(e, t);
  };
  forge$z.cipher.registerAlgorithm(e, a);
}
var init = !1, Nb = 4, sbox, isbox, rcon, mix, imix;
function initialize() {
  init = !0, rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  for (var e = new Array(256), t = 0; t < 128; ++t)
    e[t] = t << 1, e[t + 128] = t + 128 << 1 ^ 283;
  sbox = new Array(256), isbox = new Array(256), mix = new Array(4), imix = new Array(4);
  for (var t = 0; t < 4; ++t)
    mix[t] = new Array(256), imix[t] = new Array(256);
  for (var a = 0, n = 0, u, o, l, h, y, _, d, t = 0; t < 256; ++t) {
    h = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4, h = h >> 8 ^ h & 255 ^ 99, sbox[a] = h, isbox[h] = a, y = e[h], u = e[a], o = e[u], l = e[o], _ = y << 24 ^ // 2
    h << 16 ^ // 1
    h << 8 ^ // 1
    (h ^ y), d = (u ^ o ^ l) << 24 ^ // E (14)
    (a ^ l) << 16 ^ // 9
    (a ^ o ^ l) << 8 ^ // D (13)
    (a ^ u ^ l);
    for (var $ = 0; $ < 4; ++$)
      mix[$][a] = _, imix[$][h] = d, _ = _ << 24 | _ >>> 8, d = d << 24 | d >>> 8;
    a === 0 ? a = n = 1 : (a = u ^ e[e[e[u ^ l]]], n ^= e[e[n]]);
  }
}
function _expandKey(e, t) {
  for (var a = e.slice(0), n, u = 1, o = a.length, l = o + 6 + 1, h = Nb * l, y = o; y < h; ++y)
    n = a[y - 1], y % o === 0 ? (n = sbox[n >>> 16 & 255] << 24 ^ sbox[n >>> 8 & 255] << 16 ^ sbox[n & 255] << 8 ^ sbox[n >>> 24] ^ rcon[u] << 24, u++) : o > 6 && y % o === 4 && (n = sbox[n >>> 24] << 24 ^ sbox[n >>> 16 & 255] << 16 ^ sbox[n >>> 8 & 255] << 8 ^ sbox[n & 255]), a[y] = a[y - o] ^ n;
  if (t) {
    var _, d = imix[0], $ = imix[1], N = imix[2], U = imix[3], V = a.slice(0);
    h = a.length;
    for (var y = 0, Q = h - Nb; y < h; y += Nb, Q -= Nb)
      if (y === 0 || y === h - Nb)
        V[y] = a[Q], V[y + 1] = a[Q + 3], V[y + 2] = a[Q + 2], V[y + 3] = a[Q + 1];
      else
        for (var ie = 0; ie < Nb; ++ie)
          _ = a[Q + ie], V[y + (3 & -ie)] = d[sbox[_ >>> 24]] ^ $[sbox[_ >>> 16 & 255]] ^ N[sbox[_ >>> 8 & 255]] ^ U[sbox[_ & 255]];
    a = V;
  }
  return a;
}
function _updateBlock$1(e, t, a, n) {
  var u = e.length / 4 - 1, o, l, h, y, _;
  n ? (o = imix[0], l = imix[1], h = imix[2], y = imix[3], _ = isbox) : (o = mix[0], l = mix[1], h = mix[2], y = mix[3], _ = sbox);
  var d, $, N, U, V, Q, ie;
  d = t[0] ^ e[0], $ = t[n ? 3 : 1] ^ e[1], N = t[2] ^ e[2], U = t[n ? 1 : 3] ^ e[3];
  for (var ee = 3, ne = 1; ne < u; ++ne)
    V = o[d >>> 24] ^ l[$ >>> 16 & 255] ^ h[N >>> 8 & 255] ^ y[U & 255] ^ e[++ee], Q = o[$ >>> 24] ^ l[N >>> 16 & 255] ^ h[U >>> 8 & 255] ^ y[d & 255] ^ e[++ee], ie = o[N >>> 24] ^ l[U >>> 16 & 255] ^ h[d >>> 8 & 255] ^ y[$ & 255] ^ e[++ee], U = o[U >>> 24] ^ l[d >>> 16 & 255] ^ h[$ >>> 8 & 255] ^ y[N & 255] ^ e[++ee], d = V, $ = Q, N = ie;
  a[0] = _[d >>> 24] << 24 ^ _[$ >>> 16 & 255] << 16 ^ _[N >>> 8 & 255] << 8 ^ _[U & 255] ^ e[++ee], a[n ? 3 : 1] = _[$ >>> 24] << 24 ^ _[N >>> 16 & 255] << 16 ^ _[U >>> 8 & 255] << 8 ^ _[d & 255] ^ e[++ee], a[2] = _[N >>> 24] << 24 ^ _[U >>> 16 & 255] << 16 ^ _[d >>> 8 & 255] << 8 ^ _[$ & 255] ^ e[++ee], a[n ? 1 : 3] = _[U >>> 24] << 24 ^ _[d >>> 16 & 255] << 16 ^ _[$ >>> 8 & 255] << 8 ^ _[N & 255] ^ e[++ee];
}
function _createCipher$1(e) {
  e = e || {};
  var t = (e.mode || "CBC").toUpperCase(), a = "AES-" + t, n;
  e.decrypt ? n = forge$z.cipher.createDecipher(a, e.key) : n = forge$z.cipher.createCipher(a, e.key);
  var u = n.start;
  return n.start = function(o, l) {
    var h = null;
    l instanceof forge$z.util.ByteBuffer && (h = l, l = {}), l = l || {}, l.output = h, l.iv = o, u.call(n, l);
  }, n;
}
var forge$y = forge$D;
forge$y.pki = forge$y.pki || {};
var oids$2 = forge$y.pki.oids = forge$y.oids = forge$y.oids || {};
function _IN(e, t) {
  oids$2[e] = t, oids$2[t] = e;
}
function _I_(e, t) {
  oids$2[e] = t;
}
_IN("1.2.840.113549.1.1.1", "rsaEncryption");
_IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
_IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
_IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
_IN("1.2.840.113549.1.1.8", "mgf1");
_IN("1.2.840.113549.1.1.9", "pSpecified");
_IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
_IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
_IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
_IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
_IN("1.3.101.112", "EdDSA25519");
_IN("1.2.840.10040.4.3", "dsa-with-sha1");
_IN("1.3.14.3.2.7", "desCBC");
_IN("1.3.14.3.2.26", "sha1");
_IN("1.3.14.3.2.29", "sha1WithRSASignature");
_IN("2.16.840.1.101.3.4.2.1", "sha256");
_IN("2.16.840.1.101.3.4.2.2", "sha384");
_IN("2.16.840.1.101.3.4.2.3", "sha512");
_IN("2.16.840.1.101.3.4.2.4", "sha224");
_IN("2.16.840.1.101.3.4.2.5", "sha512-224");
_IN("2.16.840.1.101.3.4.2.6", "sha512-256");
_IN("1.2.840.113549.2.2", "md2");
_IN("1.2.840.113549.2.5", "md5");
_IN("1.2.840.113549.1.7.1", "data");
_IN("1.2.840.113549.1.7.2", "signedData");
_IN("1.2.840.113549.1.7.3", "envelopedData");
_IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
_IN("1.2.840.113549.1.7.5", "digestedData");
_IN("1.2.840.113549.1.7.6", "encryptedData");
_IN("1.2.840.113549.1.9.1", "emailAddress");
_IN("1.2.840.113549.1.9.2", "unstructuredName");
_IN("1.2.840.113549.1.9.3", "contentType");
_IN("1.2.840.113549.1.9.4", "messageDigest");
_IN("1.2.840.113549.1.9.5", "signingTime");
_IN("1.2.840.113549.1.9.6", "counterSignature");
_IN("1.2.840.113549.1.9.7", "challengePassword");
_IN("1.2.840.113549.1.9.8", "unstructuredAddress");
_IN("1.2.840.113549.1.9.14", "extensionRequest");
_IN("1.2.840.113549.1.9.20", "friendlyName");
_IN("1.2.840.113549.1.9.21", "localKeyId");
_IN("1.2.840.113549.1.9.22.1", "x509Certificate");
_IN("1.2.840.113549.1.12.10.1.1", "keyBag");
_IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
_IN("1.2.840.113549.1.12.10.1.3", "certBag");
_IN("1.2.840.113549.1.12.10.1.4", "crlBag");
_IN("1.2.840.113549.1.12.10.1.5", "secretBag");
_IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
_IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
_IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
_IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
_IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
_IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
_IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
_IN("1.2.840.113549.2.7", "hmacWithSHA1");
_IN("1.2.840.113549.2.8", "hmacWithSHA224");
_IN("1.2.840.113549.2.9", "hmacWithSHA256");
_IN("1.2.840.113549.2.10", "hmacWithSHA384");
_IN("1.2.840.113549.2.11", "hmacWithSHA512");
_IN("1.2.840.113549.3.7", "des-EDE3-CBC");
_IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
_IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
_IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
_IN("2.5.4.3", "commonName");
_IN("2.5.4.4", "surname");
_IN("2.5.4.5", "serialNumber");
_IN("2.5.4.6", "countryName");
_IN("2.5.4.7", "localityName");
_IN("2.5.4.8", "stateOrProvinceName");
_IN("2.5.4.9", "streetAddress");
_IN("2.5.4.10", "organizationName");
_IN("2.5.4.11", "organizationalUnitName");
_IN("2.5.4.12", "title");
_IN("2.5.4.13", "description");
_IN("2.5.4.15", "businessCategory");
_IN("2.5.4.17", "postalCode");
_IN("2.5.4.42", "givenName");
_IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
_IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
_IN("2.16.840.1.113730.1.1", "nsCertType");
_IN("2.16.840.1.113730.1.13", "nsComment");
_I_("2.5.29.1", "authorityKeyIdentifier");
_I_("2.5.29.2", "keyAttributes");
_I_("2.5.29.3", "certificatePolicies");
_I_("2.5.29.4", "keyUsageRestriction");
_I_("2.5.29.5", "policyMapping");
_I_("2.5.29.6", "subtreesConstraint");
_I_("2.5.29.7", "subjectAltName");
_I_("2.5.29.8", "issuerAltName");
_I_("2.5.29.9", "subjectDirectoryAttributes");
_I_("2.5.29.10", "basicConstraints");
_I_("2.5.29.11", "nameConstraints");
_I_("2.5.29.12", "policyConstraints");
_I_("2.5.29.13", "basicConstraints");
_IN("2.5.29.14", "subjectKeyIdentifier");
_IN("2.5.29.15", "keyUsage");
_I_("2.5.29.16", "privateKeyUsagePeriod");
_IN("2.5.29.17", "subjectAltName");
_IN("2.5.29.18", "issuerAltName");
_IN("2.5.29.19", "basicConstraints");
_I_("2.5.29.20", "cRLNumber");
_I_("2.5.29.21", "cRLReason");
_I_("2.5.29.22", "expirationDate");
_I_("2.5.29.23", "instructionCode");
_I_("2.5.29.24", "invalidityDate");
_I_("2.5.29.25", "cRLDistributionPoints");
_I_("2.5.29.26", "issuingDistributionPoint");
_I_("2.5.29.27", "deltaCRLIndicator");
_I_("2.5.29.28", "issuingDistributionPoint");
_I_("2.5.29.29", "certificateIssuer");
_I_("2.5.29.30", "nameConstraints");
_IN("2.5.29.31", "cRLDistributionPoints");
_IN("2.5.29.32", "certificatePolicies");
_I_("2.5.29.33", "policyMappings");
_I_("2.5.29.34", "policyConstraints");
_IN("2.5.29.35", "authorityKeyIdentifier");
_I_("2.5.29.36", "policyConstraints");
_IN("2.5.29.37", "extKeyUsage");
_I_("2.5.29.46", "freshestCRL");
_I_("2.5.29.54", "inhibitAnyPolicy");
_IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
_IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
_IN("1.3.6.1.5.5.7.3.1", "serverAuth");
_IN("1.3.6.1.5.5.7.3.2", "clientAuth");
_IN("1.3.6.1.5.5.7.3.3", "codeSigning");
_IN("1.3.6.1.5.5.7.3.4", "emailProtection");
_IN("1.3.6.1.5.5.7.3.8", "timeStamping");
var forge$x = forge$D, asn1$8 = forge$x.asn1 = forge$x.asn1 || {};
asn1$8.Class = {
  UNIVERSAL: 0,
  APPLICATION: 64,
  CONTEXT_SPECIFIC: 128,
  PRIVATE: 192
};
asn1$8.Type = {
  NONE: 0,
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTETSTRING: 4,
  NULL: 5,
  OID: 6,
  ODESC: 7,
  EXTERNAL: 8,
  REAL: 9,
  ENUMERATED: 10,
  EMBEDDED: 11,
  UTF8: 12,
  ROID: 13,
  SEQUENCE: 16,
  SET: 17,
  PRINTABLESTRING: 19,
  IA5STRING: 22,
  UTCTIME: 23,
  GENERALIZEDTIME: 24,
  BMPSTRING: 30
};
asn1$8.maxDepth = 256;
asn1$8.create = function(e, t, a, n, u) {
  if (forge$x.util.isArray(n)) {
    for (var o = [], l = 0; l < n.length; ++l)
      n[l] !== void 0 && o.push(n[l]);
    n = o;
  }
  var h = {
    tagClass: e,
    type: t,
    constructed: a,
    composed: a || forge$x.util.isArray(n),
    value: n
  };
  return u && "bitStringContents" in u && (h.bitStringContents = u.bitStringContents, h.original = asn1$8.copy(h)), h;
};
asn1$8.copy = function(e, t) {
  var a;
  if (forge$x.util.isArray(e)) {
    a = [];
    for (var n = 0; n < e.length; ++n)
      a.push(asn1$8.copy(e[n], t));
    return a;
  }
  return typeof e == "string" ? e : (a = {
    tagClass: e.tagClass,
    type: e.type,
    constructed: e.constructed,
    composed: e.composed,
    value: asn1$8.copy(e.value, t)
  }, t && !t.excludeBitStringContents && (a.bitStringContents = e.bitStringContents), a);
};
asn1$8.equals = function(e, t, a) {
  if (forge$x.util.isArray(e)) {
    if (!forge$x.util.isArray(t) || e.length !== t.length)
      return !1;
    for (var n = 0; n < e.length; ++n)
      if (!asn1$8.equals(e[n], t[n]))
        return !1;
    return !0;
  }
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "string")
    return e === t;
  var u = e.tagClass === t.tagClass && e.type === t.type && e.constructed === t.constructed && e.composed === t.composed && asn1$8.equals(e.value, t.value);
  return a && a.includeBitStringContents && (u = u && e.bitStringContents === t.bitStringContents), u;
};
asn1$8.getBerValueLength = function(e) {
  var t = e.getByte();
  if (t !== 128) {
    var a, n = t & 128;
    return n ? a = e.getInt((t & 127) << 3) : a = t, a;
  }
};
function _checkBufferLength(e, t, a) {
  if (a > t) {
    var n = new Error("Too few bytes to parse DER.");
    throw n.available = e.length(), n.remaining = t, n.requested = a, n;
  }
}
var _getValueLength = function(e, t) {
  var a = e.getByte();
  if (t--, a !== 128) {
    var n, u = a & 128;
    if (!u)
      n = a;
    else {
      var o = a & 127;
      _checkBufferLength(e, t, o), n = e.getInt(o << 3);
    }
    if (n < 0)
      throw new Error("Negative length: " + n);
    return n;
  }
};
asn1$8.fromDer = function(e, t) {
  t === void 0 && (t = {
    strict: !0,
    parseAllBytes: !0,
    decodeBitStrings: !0
  }), typeof t == "boolean" && (t = {
    strict: t,
    parseAllBytes: !0,
    decodeBitStrings: !0
  }), "strict" in t || (t.strict = !0), "parseAllBytes" in t || (t.parseAllBytes = !0), "decodeBitStrings" in t || (t.decodeBitStrings = !0), "maxDepth" in t || (t.maxDepth = asn1$8.maxDepth), typeof e == "string" && (e = forge$x.util.createBuffer(e));
  var a = e.length(), n = _fromDer(e, e.length(), 0, t);
  if (t.parseAllBytes && e.length() !== 0) {
    var u = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
    throw u.byteCount = a, u.remaining = e.length(), u;
  }
  return n;
};
function _fromDer(e, t, a, n) {
  if (a >= n.maxDepth)
    throw new Error("ASN.1 parsing error: Max depth exceeded.");
  var u;
  _checkBufferLength(e, t, 2);
  var o = e.getByte();
  t--;
  var l = o & 192, h = o & 31;
  u = e.length();
  var y = _getValueLength(e, t);
  if (t -= u - e.length(), y !== void 0 && y > t) {
    if (n.strict) {
      var _ = new Error("Too few bytes to read ASN.1 value.");
      throw _.available = e.length(), _.remaining = t, _.requested = y, _;
    }
    y = t;
  }
  var d, $, N = (o & 32) === 32;
  if (N)
    if (d = [], y === void 0)
      for (; ; ) {
        if (_checkBufferLength(e, t, 2), e.bytes(2) === String.fromCharCode(0, 0)) {
          e.getBytes(2), t -= 2;
          break;
        }
        u = e.length(), d.push(_fromDer(e, t, a + 1, n)), t -= u - e.length();
      }
    else
      for (; y > 0; )
        u = e.length(), d.push(_fromDer(e, y, a + 1, n)), t -= u - e.length(), y -= u - e.length();
  if (d === void 0 && l === asn1$8.Class.UNIVERSAL && h === asn1$8.Type.BITSTRING && ($ = e.bytes(y)), d === void 0 && n.decodeBitStrings && l === asn1$8.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
  // .. other parts of forge expect to decode OCTET STRINGs manually
  h === asn1$8.Type.BITSTRING && y > 1) {
    var U = e.read, V = t, Q = 0;
    if (h === asn1$8.Type.BITSTRING && (_checkBufferLength(e, t, 1), Q = e.getByte(), t--), Q === 0)
      try {
        u = e.length();
        var ie = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          strict: !0,
          decodeBitStrings: !0
        }, ee = _fromDer(e, t, a + 1, ie), ne = u - e.length();
        t -= ne, h == asn1$8.Type.BITSTRING && ne++;
        var ge = ee.tagClass;
        ne === y && (ge === asn1$8.Class.UNIVERSAL || ge === asn1$8.Class.CONTEXT_SPECIFIC) && (d = [ee]);
      } catch {
      }
    d === void 0 && (e.read = U, t = V);
  }
  if (d === void 0) {
    if (y === void 0) {
      if (n.strict)
        throw new Error("Non-constructed ASN.1 object of indefinite length.");
      y = t;
    }
    if (h === asn1$8.Type.BMPSTRING)
      for (d = ""; y > 0; y -= 2)
        _checkBufferLength(e, t, 2), d += String.fromCharCode(e.getInt16()), t -= 2;
    else
      d = e.getBytes(y), t -= y;
  }
  var be = $ === void 0 ? null : {
    bitStringContents: $
  };
  return asn1$8.create(l, h, N, d, be);
}
asn1$8.toDer = function(e) {
  var t = forge$x.util.createBuffer(), a = e.tagClass | e.type, n = forge$x.util.createBuffer(), u = !1;
  if ("bitStringContents" in e && (u = !0, e.original && (u = asn1$8.equals(e, e.original))), u)
    n.putBytes(e.bitStringContents);
  else if (e.composed) {
    e.constructed ? a |= 32 : n.putByte(0);
    for (var o = 0; o < e.value.length; ++o)
      e.value[o] !== void 0 && n.putBuffer(asn1$8.toDer(e.value[o]));
  } else if (e.type === asn1$8.Type.BMPSTRING)
    for (var o = 0; o < e.value.length; ++o)
      n.putInt16(e.value.charCodeAt(o));
  else
    e.type === asn1$8.Type.INTEGER && e.value.length > 1 && // leading 0x00 for positive integer
    (e.value.charCodeAt(0) === 0 && !(e.value.charCodeAt(1) & 128) || // leading 0xFF for negative integer
    e.value.charCodeAt(0) === 255 && (e.value.charCodeAt(1) & 128) === 128) ? n.putBytes(e.value.substr(1)) : n.putBytes(e.value);
  if (t.putByte(a), n.length() <= 127)
    t.putByte(n.length() & 127);
  else {
    var l = n.length(), h = "";
    do
      h += String.fromCharCode(l & 255), l = l >>> 8;
    while (l > 0);
    t.putByte(h.length | 128);
    for (var o = h.length - 1; o >= 0; --o)
      t.putByte(h.charCodeAt(o));
  }
  return t.putBuffer(n), t;
};
asn1$8.oidToDer = function(e) {
  var t = e.split("."), a = forge$x.util.createBuffer();
  a.putByte(40 * parseInt(t[0], 10) + parseInt(t[1], 10));
  for (var n, u, o, l, h = 2; h < t.length; ++h) {
    if (n = !0, u = [], o = parseInt(t[h], 10), o > 4294967295)
      throw new Error("OID value too large; max is 32-bits.");
    do
      l = o & 127, o = o >>> 7, n || (l |= 128), u.push(l), n = !1;
    while (o > 0);
    for (var y = u.length - 1; y >= 0; --y)
      a.putByte(u[y]);
  }
  return a;
};
asn1$8.derToOid = function(e) {
  var t;
  typeof e == "string" && (e = forge$x.util.createBuffer(e));
  var a = e.getByte();
  t = Math.floor(a / 40) + "." + a % 40;
  for (var n = 0; e.length() > 0; ) {
    if (n > 70368744177663)
      throw new Error("OID value too large; max is 53-bits.");
    a = e.getByte(), n = n * 128, a & 128 ? n += a & 127 : (t += "." + (n + a), n = 0);
  }
  return t;
};
asn1$8.utcTimeToDate = function(e) {
  var t = /* @__PURE__ */ new Date(), a = parseInt(e.substr(0, 2), 10);
  a = a >= 50 ? 1900 + a : 2e3 + a;
  var n = parseInt(e.substr(2, 2), 10) - 1, u = parseInt(e.substr(4, 2), 10), o = parseInt(e.substr(6, 2), 10), l = parseInt(e.substr(8, 2), 10), h = 0;
  if (e.length > 11) {
    var y = e.charAt(10), _ = 10;
    y !== "+" && y !== "-" && (h = parseInt(e.substr(10, 2), 10), _ += 2);
  }
  if (t.setUTCFullYear(a, n, u), t.setUTCHours(o, l, h, 0), _ && (y = e.charAt(_), y === "+" || y === "-")) {
    var d = parseInt(e.substr(_ + 1, 2), 10), $ = parseInt(e.substr(_ + 4, 2), 10), N = d * 60 + $;
    N *= 6e4, y === "+" ? t.setTime(+t - N) : t.setTime(+t + N);
  }
  return t;
};
asn1$8.generalizedTimeToDate = function(e) {
  var t = /* @__PURE__ */ new Date(), a = parseInt(e.substr(0, 4), 10), n = parseInt(e.substr(4, 2), 10) - 1, u = parseInt(e.substr(6, 2), 10), o = parseInt(e.substr(8, 2), 10), l = parseInt(e.substr(10, 2), 10), h = parseInt(e.substr(12, 2), 10), y = 0, _ = 0, d = !1;
  e.charAt(e.length - 1) === "Z" && (d = !0);
  var $ = e.length - 5, N = e.charAt($);
  if (N === "+" || N === "-") {
    var U = parseInt(e.substr($ + 1, 2), 10), V = parseInt(e.substr($ + 4, 2), 10);
    _ = U * 60 + V, _ *= 6e4, N === "+" && (_ *= -1), d = !0;
  }
  return e.charAt(14) === "." && (y = parseFloat(e.substr(14), 10) * 1e3), d ? (t.setUTCFullYear(a, n, u), t.setUTCHours(o, l, h, y), t.setTime(+t + _)) : (t.setFullYear(a, n, u), t.setHours(o, l, h, y)), t;
};
asn1$8.dateToUtcTime = function(e) {
  if (typeof e == "string")
    return e;
  var t = "", a = [];
  a.push(("" + e.getUTCFullYear()).substr(2)), a.push("" + (e.getUTCMonth() + 1)), a.push("" + e.getUTCDate()), a.push("" + e.getUTCHours()), a.push("" + e.getUTCMinutes()), a.push("" + e.getUTCSeconds());
  for (var n = 0; n < a.length; ++n)
    a[n].length < 2 && (t += "0"), t += a[n];
  return t += "Z", t;
};
asn1$8.dateToGeneralizedTime = function(e) {
  if (typeof e == "string")
    return e;
  var t = "", a = [];
  a.push("" + e.getUTCFullYear()), a.push("" + (e.getUTCMonth() + 1)), a.push("" + e.getUTCDate()), a.push("" + e.getUTCHours()), a.push("" + e.getUTCMinutes()), a.push("" + e.getUTCSeconds());
  for (var n = 0; n < a.length; ++n)
    a[n].length < 2 && (t += "0"), t += a[n];
  return t += "Z", t;
};
asn1$8.integerToDer = function(e) {
  var t = forge$x.util.createBuffer();
  if (e >= -128 && e < 128)
    return t.putSignedInt(e, 8);
  if (e >= -32768 && e < 32768)
    return t.putSignedInt(e, 16);
  if (e >= -8388608 && e < 8388608)
    return t.putSignedInt(e, 24);
  if (e >= -2147483648 && e < 2147483648)
    return t.putSignedInt(e, 32);
  var a = new Error("Integer too large; max is 32-bits.");
  throw a.integer = e, a;
};
asn1$8.derToInteger = function(e) {
  typeof e == "string" && (e = forge$x.util.createBuffer(e));
  var t = e.length() * 8;
  if (t > 32)
    throw new Error("Integer too large; max is 32-bits.");
  return e.getSignedInt(t);
};
asn1$8.validate = function(e, t, a, n) {
  var u = !1;
  if ((e.tagClass === t.tagClass || typeof t.tagClass > "u") && (e.type === t.type || typeof t.type > "u"))
    if (e.constructed === t.constructed || typeof t.constructed > "u") {
      if (u = !0, t.value && forge$x.util.isArray(t.value))
        for (var o = 0, l = 0; u && l < t.value.length; ++l) {
          var h = t.value[l];
          u = !!h.optional;
          var y = e.value[o];
          if (!y) {
            h.optional || (u = !1, n && n.push("[" + t.name + '] Missing required element. Expected tag class "' + h.tagClass + '", type "' + h.type + '"'));
            continue;
          }
          var _ = typeof h.tagClass < "u" && typeof h.type < "u";
          if (_ && (y.tagClass !== h.tagClass || y.type !== h.type))
            if (h.optional) {
              u = !0;
              continue;
            } else {
              u = !1, n && n.push("[" + t.name + "] Tag mismatch. Expected (" + h.tagClass + "," + h.type + "), got (" + y.tagClass + "," + y.type + ")");
              break;
            }
          var d = asn1$8.validate(y, h, a, n);
          if (d)
            ++o, u = !0;
          else if (h.optional)
            u = !0;
          else {
            u = !1;
            break;
          }
        }
      if (u && a && (t.capture && (a[t.capture] = e.value), t.captureAsn1 && (a[t.captureAsn1] = e), t.captureBitStringContents && "bitStringContents" in e && (a[t.captureBitStringContents] = e.bitStringContents), t.captureBitStringValue && "bitStringContents" in e))
        if (e.bitStringContents.length < 2)
          a[t.captureBitStringValue] = "";
        else {
          var $ = e.bitStringContents.charCodeAt(0);
          if ($ !== 0)
            throw new Error(
              "captureBitStringValue only supported for zero unused bits"
            );
          a[t.captureBitStringValue] = e.bitStringContents.slice(1);
        }
    } else
      n && n.push(
        "[" + t.name + '] Expected constructed "' + t.constructed + '", got "' + e.constructed + '"'
      );
  else
    n && (e.tagClass !== t.tagClass && n.push(
      "[" + t.name + '] Expected tag class "' + t.tagClass + '", got "' + e.tagClass + '"'
    ), e.type !== t.type && n.push(
      "[" + t.name + '] Expected type "' + t.type + '", got "' + e.type + '"'
    ));
  return u;
};
var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
asn1$8.prettyPrint = function(e, t, a) {
  var n = "";
  t = t || 0, a = a || 2, t > 0 && (n += `
`);
  for (var u = "", o = 0; o < t * a; ++o)
    u += " ";
  switch (n += u + "Tag: ", e.tagClass) {
    case asn1$8.Class.UNIVERSAL:
      n += "Universal:";
      break;
    case asn1$8.Class.APPLICATION:
      n += "Application:";
      break;
    case asn1$8.Class.CONTEXT_SPECIFIC:
      n += "Context-Specific:";
      break;
    case asn1$8.Class.PRIVATE:
      n += "Private:";
      break;
  }
  if (e.tagClass === asn1$8.Class.UNIVERSAL)
    switch (n += e.type, e.type) {
      case asn1$8.Type.NONE:
        n += " (None)";
        break;
      case asn1$8.Type.BOOLEAN:
        n += " (Boolean)";
        break;
      case asn1$8.Type.INTEGER:
        n += " (Integer)";
        break;
      case asn1$8.Type.BITSTRING:
        n += " (Bit string)";
        break;
      case asn1$8.Type.OCTETSTRING:
        n += " (Octet string)";
        break;
      case asn1$8.Type.NULL:
        n += " (Null)";
        break;
      case asn1$8.Type.OID:
        n += " (Object Identifier)";
        break;
      case asn1$8.Type.ODESC:
        n += " (Object Descriptor)";
        break;
      case asn1$8.Type.EXTERNAL:
        n += " (External or Instance of)";
        break;
      case asn1$8.Type.REAL:
        n += " (Real)";
        break;
      case asn1$8.Type.ENUMERATED:
        n += " (Enumerated)";
        break;
      case asn1$8.Type.EMBEDDED:
        n += " (Embedded PDV)";
        break;
      case asn1$8.Type.UTF8:
        n += " (UTF8)";
        break;
      case asn1$8.Type.ROID:
        n += " (Relative Object Identifier)";
        break;
      case asn1$8.Type.SEQUENCE:
        n += " (Sequence)";
        break;
      case asn1$8.Type.SET:
        n += " (Set)";
        break;
      case asn1$8.Type.PRINTABLESTRING:
        n += " (Printable String)";
        break;
      case asn1$8.Type.IA5String:
        n += " (IA5String (ASCII))";
        break;
      case asn1$8.Type.UTCTIME:
        n += " (UTC time)";
        break;
      case asn1$8.Type.GENERALIZEDTIME:
        n += " (Generalized time)";
        break;
      case asn1$8.Type.BMPSTRING:
        n += " (BMP String)";
        break;
    }
  else
    n += e.type;
  if (n += `
`, n += u + "Constructed: " + e.constructed + `
`, e.composed) {
    for (var l = 0, h = "", o = 0; o < e.value.length; ++o)
      e.value[o] !== void 0 && (l += 1, h += asn1$8.prettyPrint(e.value[o], t + 1, a), o + 1 < e.value.length && (h += ","));
    n += u + "Sub values: " + l + h;
  } else {
    if (n += u + "Value: ", e.type === asn1$8.Type.OID) {
      var y = asn1$8.derToOid(e.value);
      n += y, forge$x.pki && forge$x.pki.oids && y in forge$x.pki.oids && (n += " (" + forge$x.pki.oids[y] + ") ");
    }
    if (e.type === asn1$8.Type.INTEGER)
      try {
        n += asn1$8.derToInteger(e.value);
      } catch {
        n += "0x" + forge$x.util.bytesToHex(e.value);
      }
    else if (e.type === asn1$8.Type.BITSTRING) {
      if (e.value.length > 1 ? n += "0x" + forge$x.util.bytesToHex(e.value.slice(1)) : n += "(none)", e.value.length > 0) {
        var _ = e.value.charCodeAt(0);
        _ == 1 ? n += " (1 unused bit shown)" : _ > 1 && (n += " (" + _ + " unused bits shown)");
      }
    } else if (e.type === asn1$8.Type.OCTETSTRING)
      _nonLatinRegex.test(e.value) || (n += "(" + e.value + ") "), n += "0x" + forge$x.util.bytesToHex(e.value);
    else if (e.type === asn1$8.Type.UTF8)
      try {
        n += forge$x.util.decodeUtf8(e.value);
      } catch (d) {
        if (d.message === "URI malformed")
          n += "0x" + forge$x.util.bytesToHex(e.value) + " (malformed UTF8)";
        else
          throw d;
      }
    else
      e.type === asn1$8.Type.PRINTABLESTRING || e.type === asn1$8.Type.IA5String ? n += e.value : _nonLatinRegex.test(e.value) ? n += "0x" + forge$x.util.bytesToHex(e.value) : e.value.length === 0 ? n += "[null]" : n += e.value;
  }
  return n;
};
var forge$w = forge$D;
forge$w.md = forge$w.md || {};
forge$w.md.algorithms = forge$w.md.algorithms || {};
var forge$v = forge$D, hmac = forge$v.hmac = forge$v.hmac || {};
hmac.create = function() {
  var e = null, t = null, a = null, n = null, u = {};
  return u.start = function(o, l) {
    if (o !== null)
      if (typeof o == "string")
        if (o = o.toLowerCase(), o in forge$v.md.algorithms)
          t = forge$v.md.algorithms[o].create();
        else
          throw new Error('Unknown hash algorithm "' + o + '"');
      else
        t = o;
    if (l === null)
      l = e;
    else {
      if (typeof l == "string")
        l = forge$v.util.createBuffer(l);
      else if (forge$v.util.isArray(l)) {
        var h = l;
        l = forge$v.util.createBuffer();
        for (var y = 0; y < h.length; ++y)
          l.putByte(h[y]);
      }
      var _ = l.length();
      _ > t.blockLength && (t.start(), t.update(l.bytes()), l = t.digest()), a = forge$v.util.createBuffer(), n = forge$v.util.createBuffer(), _ = l.length();
      for (var y = 0; y < _; ++y) {
        var h = l.at(y);
        a.putByte(54 ^ h), n.putByte(92 ^ h);
      }
      if (_ < t.blockLength)
        for (var h = t.blockLength - _, y = 0; y < h; ++y)
          a.putByte(54), n.putByte(92);
      e = l, a = a.bytes(), n = n.bytes();
    }
    t.start(), t.update(a);
  }, u.update = function(o) {
    t.update(o);
  }, u.getMac = function() {
    var o = t.digest().bytes();
    return t.start(), t.update(n), t.update(o), t.digest();
  }, u.digest = u.getMac, u;
};
var forge$u = forge$D, md5 = forge$u.md5 = forge$u.md5 || {};
forge$u.md.md5 = forge$u.md.algorithms.md5 = md5;
md5.create = function() {
  _initialized$3 || _init$3();
  var e = null, t = forge$u.util.createBuffer(), a = new Array(16), n = {
    algorithm: "md5",
    blockLength: 64,
    digestLength: 16,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return n.start = function() {
    n.messageLength = 0, n.fullMessageLength = n.messageLength64 = [];
    for (var u = n.messageLengthSize / 4, o = 0; o < u; ++o)
      n.fullMessageLength.push(0);
    return t = forge$u.util.createBuffer(), e = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878
    }, n;
  }, n.start(), n.update = function(u, o) {
    o === "utf8" && (u = forge$u.util.encodeUtf8(u));
    var l = u.length;
    n.messageLength += l, l = [l / 4294967296 >>> 0, l >>> 0];
    for (var h = n.fullMessageLength.length - 1; h >= 0; --h)
      n.fullMessageLength[h] += l[1], l[1] = l[0] + (n.fullMessageLength[h] / 4294967296 >>> 0), n.fullMessageLength[h] = n.fullMessageLength[h] >>> 0, l[0] = l[1] / 4294967296 >>> 0;
    return t.putBytes(u), _update$3(e, a, t), (t.read > 2048 || t.length() === 0) && t.compact(), n;
  }, n.digest = function() {
    var u = forge$u.util.createBuffer();
    u.putBytes(t.bytes());
    var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize, l = o & n.blockLength - 1;
    u.putBytes(_padding$3.substr(0, n.blockLength - l));
    for (var h, y = 0, _ = n.fullMessageLength.length - 1; _ >= 0; --_)
      h = n.fullMessageLength[_] * 8 + y, y = h / 4294967296 >>> 0, u.putInt32Le(h >>> 0);
    var d = {
      h0: e.h0,
      h1: e.h1,
      h2: e.h2,
      h3: e.h3
    };
    _update$3(d, a, u);
    var $ = forge$u.util.createBuffer();
    return $.putInt32Le(d.h0), $.putInt32Le(d.h1), $.putInt32Le(d.h2), $.putInt32Le(d.h3), $;
  }, n;
};
var _padding$3 = null, _g = null, _r = null, _k$2 = null, _initialized$3 = !1;
function _init$3() {
  _padding$3 = String.fromCharCode(128), _padding$3 += forge$u.util.fillString(String.fromCharCode(0), 64), _g = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    1,
    6,
    11,
    0,
    5,
    10,
    15,
    4,
    9,
    14,
    3,
    8,
    13,
    2,
    7,
    12,
    5,
    8,
    11,
    14,
    1,
    4,
    7,
    10,
    13,
    0,
    3,
    6,
    9,
    12,
    15,
    2,
    0,
    7,
    14,
    5,
    12,
    3,
    10,
    1,
    8,
    15,
    6,
    13,
    4,
    11,
    2,
    9
  ], _r = [
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21
  ], _k$2 = new Array(64);
  for (var e = 0; e < 64; ++e)
    _k$2[e] = Math.floor(Math.abs(Math.sin(e + 1)) * 4294967296);
  _initialized$3 = !0;
}
function _update$3(e, t, a) {
  for (var n, u, o, l, h, y, _, d, $ = a.length(); $ >= 64; ) {
    for (u = e.h0, o = e.h1, l = e.h2, h = e.h3, d = 0; d < 16; ++d)
      t[d] = a.getInt32Le(), y = h ^ o & (l ^ h), n = u + y + _k$2[d] + t[d], _ = _r[d], u = h, h = l, l = o, o += n << _ | n >>> 32 - _;
    for (; d < 32; ++d)
      y = l ^ h & (o ^ l), n = u + y + _k$2[d] + t[_g[d]], _ = _r[d], u = h, h = l, l = o, o += n << _ | n >>> 32 - _;
    for (; d < 48; ++d)
      y = o ^ l ^ h, n = u + y + _k$2[d] + t[_g[d]], _ = _r[d], u = h, h = l, l = o, o += n << _ | n >>> 32 - _;
    for (; d < 64; ++d)
      y = l ^ (o | ~h), n = u + y + _k$2[d] + t[_g[d]], _ = _r[d], u = h, h = l, l = o, o += n << _ | n >>> 32 - _;
    e.h0 = e.h0 + u | 0, e.h1 = e.h1 + o | 0, e.h2 = e.h2 + l | 0, e.h3 = e.h3 + h | 0, $ -= 64;
  }
}
var forge$t = forge$D, pem = forge$t.pem = forge$t.pem || {};
pem.encode = function(e, t) {
  t = t || {};
  var a = "-----BEGIN " + e.type + `-----\r
`, n;
  if (e.procType && (n = {
    name: "Proc-Type",
    values: [String(e.procType.version), e.procType.type]
  }, a += foldHeader(n)), e.contentDomain && (n = { name: "Content-Domain", values: [e.contentDomain] }, a += foldHeader(n)), e.dekInfo && (n = { name: "DEK-Info", values: [e.dekInfo.algorithm] }, e.dekInfo.parameters && n.values.push(e.dekInfo.parameters), a += foldHeader(n)), e.headers)
    for (var u = 0; u < e.headers.length; ++u)
      a += foldHeader(e.headers[u]);
  return e.procType && (a += `\r
`), a += forge$t.util.encode64(e.body, t.maxline || 64) + `\r
`, a += "-----END " + e.type + `-----\r
`, a;
};
pem.decode = function(e) {
  for (var t = [], a = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, n = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, u = /\r?\n/, o; o = a.exec(e), !!o; ) {
    var l = o[1];
    l === "NEW CERTIFICATE REQUEST" && (l = "CERTIFICATE REQUEST");
    var h = {
      type: l,
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge$t.util.decode64(o[3])
    };
    if (t.push(h), !!o[2]) {
      for (var y = o[2].split(u), _ = 0; o && _ < y.length; ) {
        for (var d = y[_].replace(/\s+$/, ""), $ = _ + 1; $ < y.length; ++$) {
          var N = y[$];
          if (!/\s/.test(N[0]))
            break;
          d += N, _ = $;
        }
        if (o = d.match(n), o) {
          for (var U = { name: o[1], values: [] }, V = o[2].split(","), Q = 0; Q < V.length; ++Q)
            U.values.push(ltrim(V[Q]));
          if (h.procType)
            if (!h.contentDomain && U.name === "Content-Domain")
              h.contentDomain = V[0] || "";
            else if (!h.dekInfo && U.name === "DEK-Info") {
              if (U.values.length === 0)
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              h.dekInfo = { algorithm: V[0], parameters: V[1] || null };
            } else
              h.headers.push(U);
          else {
            if (U.name !== "Proc-Type")
              throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
            if (U.values.length !== 2)
              throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
            h.procType = { version: V[0], type: V[1] };
          }
        }
        ++_;
      }
      if (h.procType === "ENCRYPTED" && !h.dekInfo)
        throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (t.length === 0)
    throw new Error("Invalid PEM formatted message.");
  return t;
};
function foldHeader(e) {
  for (var t = e.name + ": ", a = [], n = function(y, _) {
    return " " + _;
  }, u = 0; u < e.values.length; ++u)
    a.push(e.values[u].replace(/^(\S+\r\n)/, n));
  t += a.join(",") + `\r
`;
  for (var o = 0, l = -1, u = 0; u < t.length; ++u, ++o)
    if (o > 65 && l !== -1) {
      var h = t[l];
      h === "," ? (++l, t = t.substr(0, l) + `\r
 ` + t.substr(l)) : t = t.substr(0, l) + `\r
` + h + t.substr(l + 1), o = u - l - 1, l = -1, ++u;
    } else
      (t[u] === " " || t[u] === "	" || t[u] === ",") && (l = u);
  return t;
}
function ltrim(e) {
  return e.replace(/^\s+/, "");
}
var forge$s = forge$D;
forge$s.des = forge$s.des || {};
forge$s.des.startEncrypting = function(e, t, a, n) {
  var u = _createCipher({
    key: e,
    output: a,
    decrypt: !1,
    mode: n || (t === null ? "ECB" : "CBC")
  });
  return u.start(t), u;
};
forge$s.des.createEncryptionCipher = function(e, t) {
  return _createCipher({
    key: e,
    output: null,
    decrypt: !1,
    mode: t
  });
};
forge$s.des.startDecrypting = function(e, t, a, n) {
  var u = _createCipher({
    key: e,
    output: a,
    decrypt: !0,
    mode: n || (t === null ? "ECB" : "CBC")
  });
  return u.start(t), u;
};
forge$s.des.createDecryptionCipher = function(e, t) {
  return _createCipher({
    key: e,
    output: null,
    decrypt: !0,
    mode: t
  });
};
forge$s.des.Algorithm = function(e, t) {
  var a = this;
  a.name = e, a.mode = new t({
    blockSize: 8,
    cipher: {
      encrypt: function(n, u) {
        return _updateBlock(a._keys, n, u, !1);
      },
      decrypt: function(n, u) {
        return _updateBlock(a._keys, n, u, !0);
      }
    }
  }), a._init = !1;
};
forge$s.des.Algorithm.prototype.initialize = function(e) {
  if (!this._init) {
    var t = forge$s.util.createBuffer(e.key);
    if (this.name.indexOf("3DES") === 0 && t.length() !== 24)
      throw new Error("Invalid Triple-DES key size: " + t.length() * 8);
    this._keys = _createKeys(t), this._init = !0;
  }
};
registerAlgorithm("DES-ECB", forge$s.cipher.modes.ecb);
registerAlgorithm("DES-CBC", forge$s.cipher.modes.cbc);
registerAlgorithm("DES-CFB", forge$s.cipher.modes.cfb);
registerAlgorithm("DES-OFB", forge$s.cipher.modes.ofb);
registerAlgorithm("DES-CTR", forge$s.cipher.modes.ctr);
registerAlgorithm("3DES-ECB", forge$s.cipher.modes.ecb);
registerAlgorithm("3DES-CBC", forge$s.cipher.modes.cbc);
registerAlgorithm("3DES-CFB", forge$s.cipher.modes.cfb);
registerAlgorithm("3DES-OFB", forge$s.cipher.modes.ofb);
registerAlgorithm("3DES-CTR", forge$s.cipher.modes.ctr);
function registerAlgorithm(e, t) {
  var a = function() {
    return new forge$s.des.Algorithm(e, t);
  };
  forge$s.cipher.registerAlgorithm(e, a);
}
var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function _createKeys(e) {
  for (var t = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], a = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], n = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], u = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], o = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], l = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], h = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], y = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], _ = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], d = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], $ = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], N = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], U = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], V = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], Q = e.length() > 8 ? 3 : 1, ie = [], ee = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], ne = 0, ge, be = 0; be < Q; be++) {
    var Ee = e.getInt32(), xe = e.getInt32();
    ge = (Ee >>> 4 ^ xe) & 252645135, xe ^= ge, Ee ^= ge << 4, ge = (xe >>> -16 ^ Ee) & 65535, Ee ^= ge, xe ^= ge << -16, ge = (Ee >>> 2 ^ xe) & 858993459, xe ^= ge, Ee ^= ge << 2, ge = (xe >>> -16 ^ Ee) & 65535, Ee ^= ge, xe ^= ge << -16, ge = (Ee >>> 1 ^ xe) & 1431655765, xe ^= ge, Ee ^= ge << 1, ge = (xe >>> 8 ^ Ee) & 16711935, Ee ^= ge, xe ^= ge << 8, ge = (Ee >>> 1 ^ xe) & 1431655765, xe ^= ge, Ee ^= ge << 1, ge = Ee << 8 | xe >>> 20 & 240, Ee = xe << 24 | xe << 8 & 16711680 | xe >>> 8 & 65280 | xe >>> 24 & 240, xe = ge;
    for (var Le = 0; Le < ee.length; ++Le) {
      ee[Le] ? (Ee = Ee << 2 | Ee >>> 26, xe = xe << 2 | xe >>> 26) : (Ee = Ee << 1 | Ee >>> 27, xe = xe << 1 | xe >>> 27), Ee &= -15, xe &= -15;
      var Ne = t[Ee >>> 28] | a[Ee >>> 24 & 15] | n[Ee >>> 20 & 15] | u[Ee >>> 16 & 15] | o[Ee >>> 12 & 15] | l[Ee >>> 8 & 15] | h[Ee >>> 4 & 15], Re = y[xe >>> 28] | _[xe >>> 24 & 15] | d[xe >>> 20 & 15] | $[xe >>> 16 & 15] | N[xe >>> 12 & 15] | U[xe >>> 8 & 15] | V[xe >>> 4 & 15];
      ge = (Re >>> 16 ^ Ne) & 65535, ie[ne++] = Ne ^ ge, ie[ne++] = Re ^ ge << 16;
    }
  }
  return ie;
}
function _updateBlock(e, t, a, n) {
  var u = e.length === 32 ? 3 : 9, o;
  u === 3 ? o = n ? [30, -2, -2] : [0, 32, 2] : o = n ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  var l, h = t[0], y = t[1];
  l = (h >>> 4 ^ y) & 252645135, y ^= l, h ^= l << 4, l = (h >>> 16 ^ y) & 65535, y ^= l, h ^= l << 16, l = (y >>> 2 ^ h) & 858993459, h ^= l, y ^= l << 2, l = (y >>> 8 ^ h) & 16711935, h ^= l, y ^= l << 8, l = (h >>> 1 ^ y) & 1431655765, y ^= l, h ^= l << 1, h = h << 1 | h >>> 31, y = y << 1 | y >>> 31;
  for (var _ = 0; _ < u; _ += 3) {
    for (var d = o[_ + 1], $ = o[_ + 2], N = o[_]; N != d; N += $) {
      var U = y ^ e[N], V = (y >>> 4 | y << 28) ^ e[N + 1];
      l = h, h = y, y = l ^ (spfunction2[U >>> 24 & 63] | spfunction4[U >>> 16 & 63] | spfunction6[U >>> 8 & 63] | spfunction8[U & 63] | spfunction1[V >>> 24 & 63] | spfunction3[V >>> 16 & 63] | spfunction5[V >>> 8 & 63] | spfunction7[V & 63]);
    }
    l = h, h = y, y = l;
  }
  h = h >>> 1 | h << 31, y = y >>> 1 | y << 31, l = (h >>> 1 ^ y) & 1431655765, y ^= l, h ^= l << 1, l = (y >>> 8 ^ h) & 16711935, h ^= l, y ^= l << 8, l = (y >>> 2 ^ h) & 858993459, h ^= l, y ^= l << 2, l = (h >>> 16 ^ y) & 65535, y ^= l, h ^= l << 16, l = (h >>> 4 ^ y) & 252645135, y ^= l, h ^= l << 4, a[0] = h, a[1] = y;
}
function _createCipher(e) {
  e = e || {};
  var t = (e.mode || "CBC").toUpperCase(), a = "DES-" + t, n;
  e.decrypt ? n = forge$s.cipher.createDecipher(a, e.key) : n = forge$s.cipher.createCipher(a, e.key);
  var u = n.start;
  return n.start = function(o, l) {
    var h = null;
    l instanceof forge$s.util.ByteBuffer && (h = l, l = {}), l = l || {}, l.output = h, l.iv = o, u.call(n, l);
  }, n;
}
var forge$r = forge$D, pkcs5 = forge$r.pkcs5 = forge$r.pkcs5 || {}, crypto;
forge$r.util.isNodejs && !forge$r.options.usePureJavaScript && (crypto = requireCryptoBrowserify());
forge$r.pbkdf2 = pkcs5.pbkdf2 = function(e, t, a, n, u, o) {
  if (typeof u == "function" && (o = u, u = null), forge$r.util.isNodejs && !forge$r.options.usePureJavaScript && crypto.pbkdf2 && (u === null || typeof u != "object") && (crypto.pbkdf2Sync.length > 4 || !u || u === "sha1"))
    return typeof u != "string" && (u = "sha1"), e = buffer$1.Buffer.from(e, "binary"), t = buffer$1.Buffer.from(t, "binary"), o ? crypto.pbkdf2Sync.length === 4 ? crypto.pbkdf2(e, t, a, n, function(ge, be) {
      if (ge)
        return o(ge);
      o(null, be.toString("binary"));
    }) : crypto.pbkdf2(e, t, a, n, u, function(ge, be) {
      if (ge)
        return o(ge);
      o(null, be.toString("binary"));
    }) : crypto.pbkdf2Sync.length === 4 ? crypto.pbkdf2Sync(e, t, a, n).toString("binary") : crypto.pbkdf2Sync(e, t, a, n, u).toString("binary");
  if ((typeof u > "u" || u === null) && (u = "sha1"), typeof u == "string") {
    if (!(u in forge$r.md.algorithms))
      throw new Error("Unknown hash algorithm: " + u);
    u = forge$r.md[u].create();
  }
  var l = u.digestLength;
  if (n > 4294967295 * l) {
    var h = new Error("Derived key is too long.");
    if (o)
      return o(h);
    throw h;
  }
  var y = Math.ceil(n / l), _ = n - (y - 1) * l, d = forge$r.hmac.create();
  d.start(u, e);
  var $ = "", N, U, V;
  if (!o) {
    for (var Q = 1; Q <= y; ++Q) {
      d.start(null, null), d.update(t), d.update(forge$r.util.int32ToBytes(Q)), N = V = d.digest().getBytes();
      for (var ie = 2; ie <= a; ++ie)
        d.start(null, null), d.update(V), U = d.digest().getBytes(), N = forge$r.util.xorBytes(N, U, l), V = U;
      $ += Q < y ? N : N.substr(0, _);
    }
    return $;
  }
  var Q = 1, ie;
  function ee() {
    if (Q > y)
      return o(null, $);
    d.start(null, null), d.update(t), d.update(forge$r.util.int32ToBytes(Q)), N = V = d.digest().getBytes(), ie = 2, ne();
  }
  function ne() {
    if (ie <= a)
      return d.start(null, null), d.update(V), U = d.digest().getBytes(), N = forge$r.util.xorBytes(N, U, l), V = U, ++ie, forge$r.util.setImmediate(ne);
    $ += Q < y ? N : N.substr(0, _), ++Q, ee();
  }
  ee();
};
var forge$q = forge$D, sha256 = forge$q.sha256 = forge$q.sha256 || {};
forge$q.md.sha256 = forge$q.md.algorithms.sha256 = sha256;
sha256.create = function() {
  _initialized$2 || _init$2();
  var e = null, t = forge$q.util.createBuffer(), a = new Array(64), n = {
    algorithm: "sha256",
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return n.start = function() {
    n.messageLength = 0, n.fullMessageLength = n.messageLength64 = [];
    for (var u = n.messageLengthSize / 4, o = 0; o < u; ++o)
      n.fullMessageLength.push(0);
    return t = forge$q.util.createBuffer(), e = {
      h0: 1779033703,
      h1: 3144134277,
      h2: 1013904242,
      h3: 2773480762,
      h4: 1359893119,
      h5: 2600822924,
      h6: 528734635,
      h7: 1541459225
    }, n;
  }, n.start(), n.update = function(u, o) {
    o === "utf8" && (u = forge$q.util.encodeUtf8(u));
    var l = u.length;
    n.messageLength += l, l = [l / 4294967296 >>> 0, l >>> 0];
    for (var h = n.fullMessageLength.length - 1; h >= 0; --h)
      n.fullMessageLength[h] += l[1], l[1] = l[0] + (n.fullMessageLength[h] / 4294967296 >>> 0), n.fullMessageLength[h] = n.fullMessageLength[h] >>> 0, l[0] = l[1] / 4294967296 >>> 0;
    return t.putBytes(u), _update$2(e, a, t), (t.read > 2048 || t.length() === 0) && t.compact(), n;
  }, n.digest = function() {
    var u = forge$q.util.createBuffer();
    u.putBytes(t.bytes());
    var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize, l = o & n.blockLength - 1;
    u.putBytes(_padding$2.substr(0, n.blockLength - l));
    for (var h, y, _ = n.fullMessageLength[0] * 8, d = 0; d < n.fullMessageLength.length - 1; ++d)
      h = n.fullMessageLength[d + 1] * 8, y = h / 4294967296 >>> 0, _ += y, u.putInt32(_ >>> 0), _ = h >>> 0;
    u.putInt32(_);
    var $ = {
      h0: e.h0,
      h1: e.h1,
      h2: e.h2,
      h3: e.h3,
      h4: e.h4,
      h5: e.h5,
      h6: e.h6,
      h7: e.h7
    };
    _update$2($, a, u);
    var N = forge$q.util.createBuffer();
    return N.putInt32($.h0), N.putInt32($.h1), N.putInt32($.h2), N.putInt32($.h3), N.putInt32($.h4), N.putInt32($.h5), N.putInt32($.h6), N.putInt32($.h7), N;
  }, n;
};
var _padding$2 = null, _initialized$2 = !1, _k$1 = null;
function _init$2() {
  _padding$2 = String.fromCharCode(128), _padding$2 += forge$q.util.fillString(String.fromCharCode(0), 64), _k$1 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], _initialized$2 = !0;
}
function _update$2(e, t, a) {
  for (var n, u, o, l, h, y, _, d, $, N, U, V, Q, ie, ee, ne = a.length(); ne >= 64; ) {
    for (_ = 0; _ < 16; ++_)
      t[_] = a.getInt32();
    for (; _ < 64; ++_)
      n = t[_ - 2], n = (n >>> 17 | n << 15) ^ (n >>> 19 | n << 13) ^ n >>> 10, u = t[_ - 15], u = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3, t[_] = n + t[_ - 7] + u + t[_ - 16] | 0;
    for (d = e.h0, $ = e.h1, N = e.h2, U = e.h3, V = e.h4, Q = e.h5, ie = e.h6, ee = e.h7, _ = 0; _ < 64; ++_)
      l = (V >>> 6 | V << 26) ^ (V >>> 11 | V << 21) ^ (V >>> 25 | V << 7), h = ie ^ V & (Q ^ ie), o = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10), y = d & $ | N & (d ^ $), n = ee + l + h + _k$1[_] + t[_], u = o + y, ee = ie, ie = Q, Q = V, V = U + n >>> 0, U = N, N = $, $ = d, d = n + u >>> 0;
    e.h0 = e.h0 + d | 0, e.h1 = e.h1 + $ | 0, e.h2 = e.h2 + N | 0, e.h3 = e.h3 + U | 0, e.h4 = e.h4 + V | 0, e.h5 = e.h5 + Q | 0, e.h6 = e.h6 + ie | 0, e.h7 = e.h7 + ee | 0, ne -= 64;
  }
}
var forge$p = forge$D, _crypto$1 = null;
forge$p.util.isNodejs && !forge$p.options.usePureJavaScript && !api$2.versions["node-webkit"] && (_crypto$1 = requireCryptoBrowserify());
var prng = forge$p.prng = forge$p.prng || {};
prng.create = function(e) {
  for (var t = {
    plugin: e,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ""
  }, a = e.md, n = new Array(32), u = 0; u < 32; ++u)
    n[u] = a.create();
  t.pools = n, t.pool = 0, t.generate = function(_, d) {
    if (!d)
      return t.generateSync(_);
    var $ = t.plugin.cipher, N = t.plugin.increment, U = t.plugin.formatKey, V = t.plugin.formatSeed, Q = forge$p.util.createBuffer();
    t.key = null, ie();
    function ie(ee) {
      if (ee)
        return d(ee);
      if (Q.length() >= _)
        return d(null, Q.getBytes(_));
      if (t.generated > 1048575 && (t.key = null), t.key === null)
        return forge$p.util.nextTick(function() {
          o(ie);
        });
      var ne = $(t.key, t.seed);
      t.generated += ne.length, Q.putBytes(ne), t.key = U($(t.key, N(t.seed))), t.seed = V($(t.key, t.seed)), forge$p.util.setImmediate(ie);
    }
  }, t.generateSync = function(_) {
    var d = t.plugin.cipher, $ = t.plugin.increment, N = t.plugin.formatKey, U = t.plugin.formatSeed;
    t.key = null;
    for (var V = forge$p.util.createBuffer(); V.length() < _; ) {
      t.generated > 1048575 && (t.key = null), t.key === null && l();
      var Q = d(t.key, t.seed);
      t.generated += Q.length, V.putBytes(Q), t.key = N(d(t.key, $(t.seed))), t.seed = U(d(t.key, t.seed));
    }
    return V.getBytes(_);
  };
  function o(_) {
    if (t.pools[0].messageLength >= 32)
      return h(), _();
    var d = 32 - t.pools[0].messageLength << 5;
    t.seedFile(d, function($, N) {
      if ($)
        return _($);
      t.collect(N), h(), _();
    });
  }
  function l() {
    if (t.pools[0].messageLength >= 32)
      return h();
    var _ = 32 - t.pools[0].messageLength << 5;
    t.collect(t.seedFileSync(_)), h();
  }
  function h() {
    t.reseeds = t.reseeds === 4294967295 ? 0 : t.reseeds + 1;
    var _ = t.plugin.md.create();
    _.update(t.keyBytes);
    for (var d = 1, $ = 0; $ < 32; ++$)
      t.reseeds % d === 0 && (_.update(t.pools[$].digest().getBytes()), t.pools[$].start()), d = d << 1;
    t.keyBytes = _.digest().getBytes(), _.start(), _.update(t.keyBytes);
    var N = _.digest().getBytes();
    t.key = t.plugin.formatKey(t.keyBytes), t.seed = t.plugin.formatSeed(N), t.generated = 0;
  }
  function y(_) {
    var d = null, $ = forge$p.util.globalScope, N = $.crypto || $.msCrypto;
    N && N.getRandomValues && (d = function(Ee) {
      return N.getRandomValues(Ee);
    });
    var U = forge$p.util.createBuffer();
    if (d)
      for (; U.length() < _; ) {
        var V = Math.max(1, Math.min(_ - U.length(), 65536) / 4), Q = new Uint32Array(Math.floor(V));
        try {
          d(Q);
          for (var ie = 0; ie < Q.length; ++ie)
            U.putInt32(Q[ie]);
        } catch (Ee) {
          if (!(typeof QuotaExceededError < "u" && Ee instanceof QuotaExceededError))
            throw Ee;
        }
      }
    if (U.length() < _)
      for (var ee, ne, ge, be = Math.floor(Math.random() * 65536); U.length() < _; ) {
        ne = 16807 * (be & 65535), ee = 16807 * (be >> 16), ne += (ee & 32767) << 16, ne += ee >> 15, ne = (ne & 2147483647) + (ne >> 31), be = ne & 4294967295;
        for (var ie = 0; ie < 3; ++ie)
          ge = be >>> (ie << 3), ge ^= Math.floor(Math.random() * 256), U.putByte(ge & 255);
      }
    return U.getBytes(_);
  }
  return _crypto$1 ? (t.seedFile = function(_, d) {
    _crypto$1.randomBytes(_, function($, N) {
      if ($)
        return d($);
      d(null, N.toString());
    });
  }, t.seedFileSync = function(_) {
    return _crypto$1.randomBytes(_).toString();
  }) : (t.seedFile = function(_, d) {
    try {
      d(null, y(_));
    } catch ($) {
      d($);
    }
  }, t.seedFileSync = y), t.collect = function(_) {
    for (var d = _.length, $ = 0; $ < d; ++$)
      t.pools[t.pool].update(_.substr($, 1)), t.pool = t.pool === 31 ? 0 : t.pool + 1;
  }, t.collectInt = function(_, d) {
    for (var $ = "", N = 0; N < d; N += 8)
      $ += String.fromCharCode(_ >> N & 255);
    t.collect($);
  }, t.registerWorker = function(_) {
    if (_ === self)
      t.seedFile = function($, N) {
        function U(V) {
          var Q = V.data;
          Q.forge && Q.forge.prng && (self.removeEventListener("message", U), N(Q.forge.prng.err, Q.forge.prng.bytes));
        }
        self.addEventListener("message", U), self.postMessage({ forge: { prng: { needed: $ } } });
      };
    else {
      var d = function($) {
        var N = $.data;
        N.forge && N.forge.prng && t.seedFile(N.forge.prng.needed, function(U, V) {
          _.postMessage({ forge: { prng: { err: U, bytes: V } } });
        });
      };
      _.addEventListener("message", d);
    }
  }, t;
};
var forge$o = forge$D;
(function() {
  if (forge$o.random && forge$o.random.getBytes) {
    forge$o.random;
    return;
  }
  (function(e) {
    var t = {}, a = new Array(4), n = forge$o.util.createBuffer();
    t.formatKey = function($) {
      var N = forge$o.util.createBuffer($);
      return $ = new Array(4), $[0] = N.getInt32(), $[1] = N.getInt32(), $[2] = N.getInt32(), $[3] = N.getInt32(), forge$o.aes._expandKey($, !1);
    }, t.formatSeed = function($) {
      var N = forge$o.util.createBuffer($);
      return $ = new Array(4), $[0] = N.getInt32(), $[1] = N.getInt32(), $[2] = N.getInt32(), $[3] = N.getInt32(), $;
    }, t.cipher = function($, N) {
      return forge$o.aes._updateBlock($, N, a, !1), n.putInt32(a[0]), n.putInt32(a[1]), n.putInt32(a[2]), n.putInt32(a[3]), n.getBytes();
    }, t.increment = function($) {
      return ++$[3], $;
    }, t.md = forge$o.md.sha256;
    function u() {
      var $ = forge$o.prng.create(t);
      return $.getBytes = function(N, U) {
        return $.generate(N, U);
      }, $.getBytesSync = function(N) {
        return $.generate(N);
      }, $;
    }
    var o = u(), l = null, h = forge$o.util.globalScope, y = h.crypto || h.msCrypto;
    if (y && y.getRandomValues && (l = function($) {
      return y.getRandomValues($);
    }), forge$o.options.usePureJavaScript || !forge$o.util.isNodejs && !l) {
      if (o.collectInt(+/* @__PURE__ */ new Date(), 32), typeof navigator < "u") {
        var _ = "";
        for (var d in navigator)
          try {
            typeof navigator[d] == "string" && (_ += navigator[d]);
          } catch {
          }
        o.collect(_), _ = null;
      }
      e && (e().mousemove(function($) {
        o.collectInt($.clientX, 16), o.collectInt($.clientY, 16);
      }), e().keypress(function($) {
        o.collectInt($.charCode, 8);
      }));
    }
    if (!forge$o.random)
      forge$o.random = o;
    else
      for (var d in o)
        forge$o.random[d] = o[d];
    forge$o.random.createInstance = u, forge$o.random;
  })(typeof jQuery < "u" ? jQuery : null);
})();
var forge$n = forge$D, piTable = [
  217,
  120,
  249,
  196,
  25,
  221,
  181,
  237,
  40,
  233,
  253,
  121,
  74,
  160,
  216,
  157,
  198,
  126,
  55,
  131,
  43,
  118,
  83,
  142,
  98,
  76,
  100,
  136,
  68,
  139,
  251,
  162,
  23,
  154,
  89,
  245,
  135,
  179,
  79,
  19,
  97,
  69,
  109,
  141,
  9,
  129,
  125,
  50,
  189,
  143,
  64,
  235,
  134,
  183,
  123,
  11,
  240,
  149,
  33,
  34,
  92,
  107,
  78,
  130,
  84,
  214,
  101,
  147,
  206,
  96,
  178,
  28,
  115,
  86,
  192,
  20,
  167,
  140,
  241,
  220,
  18,
  117,
  202,
  31,
  59,
  190,
  228,
  209,
  66,
  61,
  212,
  48,
  163,
  60,
  182,
  38,
  111,
  191,
  14,
  218,
  70,
  105,
  7,
  87,
  39,
  242,
  29,
  155,
  188,
  148,
  67,
  3,
  248,
  17,
  199,
  246,
  144,
  239,
  62,
  231,
  6,
  195,
  213,
  47,
  200,
  102,
  30,
  215,
  8,
  232,
  234,
  222,
  128,
  82,
  238,
  247,
  132,
  170,
  114,
  172,
  53,
  77,
  106,
  42,
  150,
  26,
  210,
  113,
  90,
  21,
  73,
  116,
  75,
  159,
  208,
  94,
  4,
  24,
  164,
  236,
  194,
  224,
  65,
  110,
  15,
  81,
  203,
  204,
  36,
  145,
  175,
  80,
  161,
  244,
  112,
  57,
  153,
  124,
  58,
  133,
  35,
  184,
  180,
  122,
  252,
  2,
  54,
  91,
  37,
  85,
  151,
  49,
  45,
  93,
  250,
  152,
  227,
  138,
  146,
  174,
  5,
  223,
  41,
  16,
  103,
  108,
  186,
  201,
  211,
  0,
  230,
  207,
  225,
  158,
  168,
  44,
  99,
  22,
  1,
  63,
  88,
  226,
  137,
  169,
  13,
  56,
  52,
  27,
  171,
  51,
  255,
  176,
  187,
  72,
  12,
  95,
  185,
  177,
  205,
  46,
  197,
  243,
  219,
  71,
  229,
  165,
  156,
  119,
  10,
  166,
  32,
  104,
  254,
  127,
  193,
  173
], s = [1, 2, 3, 5], rol = function(e, t) {
  return e << t & 65535 | (e & 65535) >> 16 - t;
}, ror = function(e, t) {
  return (e & 65535) >> t | e << 16 - t & 65535;
};
forge$n.rc2 = forge$n.rc2 || {};
forge$n.rc2.expandKey = function(e, t) {
  typeof e == "string" && (e = forge$n.util.createBuffer(e)), t = t || 128;
  var a = e, n = e.length(), u = t, o = Math.ceil(u / 8), l = 255 >> (u & 7), h;
  for (h = n; h < 128; h++)
    a.putByte(piTable[a.at(h - 1) + a.at(h - n) & 255]);
  for (a.setAt(128 - o, piTable[a.at(128 - o) & l]), h = 127 - o; h >= 0; h--)
    a.setAt(h, piTable[a.at(h + 1) ^ a.at(h + o)]);
  return a;
};
var createCipher = function(e, t, a) {
  var n = !1, u = null, o = null, l = null, h, y, _, d, $ = [];
  for (e = forge$n.rc2.expandKey(e, t), _ = 0; _ < 64; _++)
    $.push(e.getInt16Le());
  a ? (h = function(V) {
    for (_ = 0; _ < 4; _++)
      V[_] += $[d] + (V[(_ + 3) % 4] & V[(_ + 2) % 4]) + (~V[(_ + 3) % 4] & V[(_ + 1) % 4]), V[_] = rol(V[_], s[_]), d++;
  }, y = function(V) {
    for (_ = 0; _ < 4; _++)
      V[_] += $[V[(_ + 3) % 4] & 63];
  }) : (h = function(V) {
    for (_ = 3; _ >= 0; _--)
      V[_] = ror(V[_], s[_]), V[_] -= $[d] + (V[(_ + 3) % 4] & V[(_ + 2) % 4]) + (~V[(_ + 3) % 4] & V[(_ + 1) % 4]), d--;
  }, y = function(V) {
    for (_ = 3; _ >= 0; _--)
      V[_] -= $[V[(_ + 3) % 4] & 63];
  });
  var N = function(V) {
    var Q = [];
    for (_ = 0; _ < 4; _++) {
      var ie = u.getInt16Le();
      l !== null && (a ? ie ^= l.getInt16Le() : l.putInt16Le(ie)), Q.push(ie & 65535);
    }
    d = a ? 0 : 63;
    for (var ee = 0; ee < V.length; ee++)
      for (var ne = 0; ne < V[ee][0]; ne++)
        V[ee][1](Q);
    for (_ = 0; _ < 4; _++)
      l !== null && (a ? l.putInt16Le(Q[_]) : Q[_] ^= l.getInt16Le()), o.putInt16Le(Q[_]);
  }, U = null;
  return U = {
    /**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */
    start: function(V, Q) {
      V && typeof V == "string" && (V = forge$n.util.createBuffer(V)), n = !1, u = forge$n.util.createBuffer(), o = Q || new forge$n.util.createBuffer(), l = V, U.output = o;
    },
    /**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */
    update: function(V) {
      for (n || u.putBuffer(V); u.length() >= 8; )
        N([
          [5, h],
          [1, y],
          [6, h],
          [1, y],
          [5, h]
        ]);
    },
    /**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */
    finish: function(V) {
      var Q = !0;
      if (a)
        if (V)
          Q = V(8, u, !a);
        else {
          var ie = u.length() === 8 ? 8 : 8 - u.length();
          u.fillWithByte(ie, ie);
        }
      if (Q && (n = !0, U.update()), !a && (Q = u.length() === 0, Q))
        if (V)
          Q = V(8, o, !a);
        else {
          var ee = o.length(), ne = o.at(ee - 1);
          ne > ee ? Q = !1 : o.truncate(ne);
        }
      return Q;
    }
  }, U;
};
forge$n.rc2.startEncrypting = function(e, t, a) {
  var n = forge$n.rc2.createEncryptionCipher(e, 128);
  return n.start(t, a), n;
};
forge$n.rc2.createEncryptionCipher = function(e, t) {
  return createCipher(e, t, !0);
};
forge$n.rc2.startDecrypting = function(e, t, a) {
  var n = forge$n.rc2.createDecryptionCipher(e, 128);
  return n.start(t, a), n;
};
forge$n.rc2.createDecryptionCipher = function(e, t) {
  return createCipher(e, t, !1);
};
var forge$m = forge$D;
forge$m.jsbn = forge$m.jsbn || {};
var dbits;
function BigInteger$4(e, t, a) {
  this.data = [], e != null && (typeof e == "number" ? this.fromNumber(e, t, a) : t == null && typeof e != "string" ? this.fromString(e, 256) : this.fromString(e, t));
}
forge$m.jsbn.BigInteger = BigInteger$4;
function nbi() {
  return new BigInteger$4(null);
}
function am1(e, t, a, n, u, o) {
  for (; --o >= 0; ) {
    var l = t * this.data[e++] + a.data[n] + u;
    u = Math.floor(l / 67108864), a.data[n++] = l & 67108863;
  }
  return u;
}
function am2(e, t, a, n, u, o) {
  for (var l = t & 32767, h = t >> 15; --o >= 0; ) {
    var y = this.data[e] & 32767, _ = this.data[e++] >> 15, d = h * y + _ * l;
    y = l * y + ((d & 32767) << 15) + a.data[n] + (u & 1073741823), u = (y >>> 30) + (d >>> 15) + h * _ + (u >>> 30), a.data[n++] = y & 1073741823;
  }
  return u;
}
function am3(e, t, a, n, u, o) {
  for (var l = t & 16383, h = t >> 14; --o >= 0; ) {
    var y = this.data[e] & 16383, _ = this.data[e++] >> 14, d = h * y + _ * l;
    y = l * y + ((d & 16383) << 14) + a.data[n] + u, u = (y >> 28) + (d >> 14) + h * _, a.data[n++] = y & 268435455;
  }
  return u;
}
typeof navigator > "u" ? (BigInteger$4.prototype.am = am3, dbits = 28) : navigator.appName == "Microsoft Internet Explorer" ? (BigInteger$4.prototype.am = am2, dbits = 30) : navigator.appName != "Netscape" ? (BigInteger$4.prototype.am = am1, dbits = 26) : (BigInteger$4.prototype.am = am3, dbits = 28);
BigInteger$4.prototype.DB = dbits;
BigInteger$4.prototype.DM = (1 << dbits) - 1;
BigInteger$4.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger$4.prototype.FV = Math.pow(2, BI_FP);
BigInteger$4.prototype.F1 = BI_FP - dbits;
BigInteger$4.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz", BI_RC = new Array(), rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv)
  BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
function int2char(e) {
  return BI_RM.charAt(e);
}
function intAt(e, t) {
  var a = BI_RC[e.charCodeAt(t)];
  return a ?? -1;
}
function bnpCopyTo(e) {
  for (var t = this.t - 1; t >= 0; --t)
    e.data[t] = this.data[t];
  e.t = this.t, e.s = this.s;
}
function bnpFromInt(e) {
  this.t = 1, this.s = e < 0 ? -1 : 0, e > 0 ? this.data[0] = e : e < -1 ? this.data[0] = e + this.DV : this.t = 0;
}
function nbv(e) {
  var t = nbi();
  return t.fromInt(e), t;
}
function bnpFromString(e, t) {
  var a;
  if (t == 16)
    a = 4;
  else if (t == 8)
    a = 3;
  else if (t == 256)
    a = 8;
  else if (t == 2)
    a = 1;
  else if (t == 32)
    a = 5;
  else if (t == 4)
    a = 2;
  else {
    this.fromRadix(e, t);
    return;
  }
  this.t = 0, this.s = 0;
  for (var n = e.length, u = !1, o = 0; --n >= 0; ) {
    var l = a == 8 ? e[n] & 255 : intAt(e, n);
    if (l < 0) {
      e.charAt(n) == "-" && (u = !0);
      continue;
    }
    u = !1, o == 0 ? this.data[this.t++] = l : o + a > this.DB ? (this.data[this.t - 1] |= (l & (1 << this.DB - o) - 1) << o, this.data[this.t++] = l >> this.DB - o) : this.data[this.t - 1] |= l << o, o += a, o >= this.DB && (o -= this.DB);
  }
  a == 8 && e[0] & 128 && (this.s = -1, o > 0 && (this.data[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), u && BigInteger$4.ZERO.subTo(this, this);
}
function bnpClamp() {
  for (var e = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == e; )
    --this.t;
}
function bnToString(e) {
  if (this.s < 0)
    return "-" + this.negate().toString(e);
  var t;
  if (e == 16)
    t = 4;
  else if (e == 8)
    t = 3;
  else if (e == 2)
    t = 1;
  else if (e == 32)
    t = 5;
  else if (e == 4)
    t = 2;
  else
    return this.toRadix(e);
  var a = (1 << t) - 1, n, u = !1, o = "", l = this.t, h = this.DB - l * this.DB % t;
  if (l-- > 0)
    for (h < this.DB && (n = this.data[l] >> h) > 0 && (u = !0, o = int2char(n)); l >= 0; )
      h < t ? (n = (this.data[l] & (1 << h) - 1) << t - h, n |= this.data[--l] >> (h += this.DB - t)) : (n = this.data[l] >> (h -= t) & a, h <= 0 && (h += this.DB, --l)), n > 0 && (u = !0), u && (o += int2char(n));
  return u ? o : "0";
}
function bnNegate() {
  var e = nbi();
  return BigInteger$4.ZERO.subTo(this, e), e;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(e) {
  var t = this.s - e.s;
  if (t != 0)
    return t;
  var a = this.t;
  if (t = a - e.t, t != 0)
    return this.s < 0 ? -t : t;
  for (; --a >= 0; )
    if ((t = this.data[a] - e.data[a]) != 0)
      return t;
  return 0;
}
function nbits(e) {
  var t = 1, a;
  return (a = e >>> 16) != 0 && (e = a, t += 16), (a = e >> 8) != 0 && (e = a, t += 8), (a = e >> 4) != 0 && (e = a, t += 4), (a = e >> 2) != 0 && (e = a, t += 2), (a = e >> 1) != 0 && (e = a, t += 1), t;
}
function bnBitLength() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(e, t) {
  var a;
  for (a = this.t - 1; a >= 0; --a)
    t.data[a + e] = this.data[a];
  for (a = e - 1; a >= 0; --a)
    t.data[a] = 0;
  t.t = this.t + e, t.s = this.s;
}
function bnpDRShiftTo(e, t) {
  for (var a = e; a < this.t; ++a)
    t.data[a - e] = this.data[a];
  t.t = Math.max(this.t - e, 0), t.s = this.s;
}
function bnpLShiftTo(e, t) {
  var a = e % this.DB, n = this.DB - a, u = (1 << n) - 1, o = Math.floor(e / this.DB), l = this.s << a & this.DM, h;
  for (h = this.t - 1; h >= 0; --h)
    t.data[h + o + 1] = this.data[h] >> n | l, l = (this.data[h] & u) << a;
  for (h = o - 1; h >= 0; --h)
    t.data[h] = 0;
  t.data[o] = l, t.t = this.t + o + 1, t.s = this.s, t.clamp();
}
function bnpRShiftTo(e, t) {
  t.s = this.s;
  var a = Math.floor(e / this.DB);
  if (a >= this.t) {
    t.t = 0;
    return;
  }
  var n = e % this.DB, u = this.DB - n, o = (1 << n) - 1;
  t.data[0] = this.data[a] >> n;
  for (var l = a + 1; l < this.t; ++l)
    t.data[l - a - 1] |= (this.data[l] & o) << u, t.data[l - a] = this.data[l] >> n;
  n > 0 && (t.data[this.t - a - 1] |= (this.s & o) << u), t.t = this.t - a, t.clamp();
}
function bnpSubTo(e, t) {
  for (var a = 0, n = 0, u = Math.min(e.t, this.t); a < u; )
    n += this.data[a] - e.data[a], t.data[a++] = n & this.DM, n >>= this.DB;
  if (e.t < this.t) {
    for (n -= e.s; a < this.t; )
      n += this.data[a], t.data[a++] = n & this.DM, n >>= this.DB;
    n += this.s;
  } else {
    for (n += this.s; a < e.t; )
      n -= e.data[a], t.data[a++] = n & this.DM, n >>= this.DB;
    n -= e.s;
  }
  t.s = n < 0 ? -1 : 0, n < -1 ? t.data[a++] = this.DV + n : n > 0 && (t.data[a++] = n), t.t = a, t.clamp();
}
function bnpMultiplyTo(e, t) {
  var a = this.abs(), n = e.abs(), u = a.t;
  for (t.t = u + n.t; --u >= 0; )
    t.data[u] = 0;
  for (u = 0; u < n.t; ++u)
    t.data[u + a.t] = a.am(0, n.data[u], t, u, 0, a.t);
  t.s = 0, t.clamp(), this.s != e.s && BigInteger$4.ZERO.subTo(t, t);
}
function bnpSquareTo(e) {
  for (var t = this.abs(), a = e.t = 2 * t.t; --a >= 0; )
    e.data[a] = 0;
  for (a = 0; a < t.t - 1; ++a) {
    var n = t.am(a, t.data[a], e, 2 * a, 0, 1);
    (e.data[a + t.t] += t.am(a + 1, 2 * t.data[a], e, 2 * a + 1, n, t.t - a - 1)) >= t.DV && (e.data[a + t.t] -= t.DV, e.data[a + t.t + 1] = 1);
  }
  e.t > 0 && (e.data[e.t - 1] += t.am(a, t.data[a], e, 2 * a, 0, 1)), e.s = 0, e.clamp();
}
function bnpDivRemTo(e, t, a) {
  var n = e.abs();
  if (!(n.t <= 0)) {
    var u = this.abs();
    if (u.t < n.t) {
      t != null && t.fromInt(0), a != null && this.copyTo(a);
      return;
    }
    a == null && (a = nbi());
    var o = nbi(), l = this.s, h = e.s, y = this.DB - nbits(n.data[n.t - 1]);
    y > 0 ? (n.lShiftTo(y, o), u.lShiftTo(y, a)) : (n.copyTo(o), u.copyTo(a));
    var _ = o.t, d = o.data[_ - 1];
    if (d != 0) {
      var $ = d * (1 << this.F1) + (_ > 1 ? o.data[_ - 2] >> this.F2 : 0), N = this.FV / $, U = (1 << this.F1) / $, V = 1 << this.F2, Q = a.t, ie = Q - _, ee = t ?? nbi();
      for (o.dlShiftTo(ie, ee), a.compareTo(ee) >= 0 && (a.data[a.t++] = 1, a.subTo(ee, a)), BigInteger$4.ONE.dlShiftTo(_, ee), ee.subTo(o, o); o.t < _; )
        o.data[o.t++] = 0;
      for (; --ie >= 0; ) {
        var ne = a.data[--Q] == d ? this.DM : Math.floor(a.data[Q] * N + (a.data[Q - 1] + V) * U);
        if ((a.data[Q] += o.am(0, ne, a, ie, 0, _)) < ne)
          for (o.dlShiftTo(ie, ee), a.subTo(ee, a); a.data[Q] < --ne; )
            a.subTo(ee, a);
      }
      t != null && (a.drShiftTo(_, t), l != h && BigInteger$4.ZERO.subTo(t, t)), a.t = _, a.clamp(), y > 0 && a.rShiftTo(y, a), l < 0 && BigInteger$4.ZERO.subTo(a, a);
    }
  }
}
function bnMod(e) {
  var t = nbi();
  return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(BigInteger$4.ZERO) > 0 && e.subTo(t, t), t;
}
function Classic(e) {
  this.m = e;
}
function cConvert(e) {
  return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e;
}
function cRevert(e) {
  return e;
}
function cReduce(e) {
  e.divRemTo(this.m, null, e);
}
function cMulTo(e, t, a) {
  e.multiplyTo(t, a), this.reduce(a);
}
function cSqrTo(e, t) {
  e.squareTo(t), this.reduce(t);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
  if (this.t < 1)
    return 0;
  var e = this.data[0];
  if (!(e & 1))
    return 0;
  var t = e & 3;
  return t = t * (2 - (e & 15) * t) & 15, t = t * (2 - (e & 255) * t) & 255, t = t * (2 - ((e & 65535) * t & 65535)) & 65535, t = t * (2 - e * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
}
function Montgomery(e) {
  this.m = e, this.mp = e.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << e.DB - 15) - 1, this.mt2 = 2 * e.t;
}
function montConvert(e) {
  var t = nbi();
  return e.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), e.s < 0 && t.compareTo(BigInteger$4.ZERO) > 0 && this.m.subTo(t, t), t;
}
function montRevert(e) {
  var t = nbi();
  return e.copyTo(t), this.reduce(t), t;
}
function montReduce(e) {
  for (; e.t <= this.mt2; )
    e.data[e.t++] = 0;
  for (var t = 0; t < this.m.t; ++t) {
    var a = e.data[t] & 32767, n = a * this.mpl + ((a * this.mph + (e.data[t] >> 15) * this.mpl & this.um) << 15) & e.DM;
    for (a = t + this.m.t, e.data[a] += this.m.am(0, n, e, t, 0, this.m.t); e.data[a] >= e.DV; )
      e.data[a] -= e.DV, e.data[++a]++;
  }
  e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e);
}
function montSqrTo(e, t) {
  e.squareTo(t), this.reduce(t);
}
function montMulTo(e, t, a) {
  e.multiplyTo(t, a), this.reduce(a);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function bnpExp(e, t) {
  if (e > 4294967295 || e < 1)
    return BigInteger$4.ONE;
  var a = nbi(), n = nbi(), u = t.convert(this), o = nbits(e) - 1;
  for (u.copyTo(a); --o >= 0; )
    if (t.sqrTo(a, n), (e & 1 << o) > 0)
      t.mulTo(n, u, a);
    else {
      var l = a;
      a = n, n = l;
    }
  return t.revert(a);
}
function bnModPowInt(e, t) {
  var a;
  return e < 256 || t.isEven() ? a = new Classic(t) : a = new Montgomery(t), this.exp(e, a);
}
BigInteger$4.prototype.copyTo = bnpCopyTo;
BigInteger$4.prototype.fromInt = bnpFromInt;
BigInteger$4.prototype.fromString = bnpFromString;
BigInteger$4.prototype.clamp = bnpClamp;
BigInteger$4.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger$4.prototype.drShiftTo = bnpDRShiftTo;
BigInteger$4.prototype.lShiftTo = bnpLShiftTo;
BigInteger$4.prototype.rShiftTo = bnpRShiftTo;
BigInteger$4.prototype.subTo = bnpSubTo;
BigInteger$4.prototype.multiplyTo = bnpMultiplyTo;
BigInteger$4.prototype.squareTo = bnpSquareTo;
BigInteger$4.prototype.divRemTo = bnpDivRemTo;
BigInteger$4.prototype.invDigit = bnpInvDigit;
BigInteger$4.prototype.isEven = bnpIsEven;
BigInteger$4.prototype.exp = bnpExp;
BigInteger$4.prototype.toString = bnToString;
BigInteger$4.prototype.negate = bnNegate;
BigInteger$4.prototype.abs = bnAbs;
BigInteger$4.prototype.compareTo = bnCompareTo;
BigInteger$4.prototype.bitLength = bnBitLength;
BigInteger$4.prototype.mod = bnMod;
BigInteger$4.prototype.modPowInt = bnModPowInt;
BigInteger$4.ZERO = nbv(0);
BigInteger$4.ONE = nbv(1);
function bnClone() {
  var e = nbi();
  return this.copyTo(e), e;
}
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1)
      return this.data[0] - this.DV;
    if (this.t == 0)
      return -1;
  } else {
    if (this.t == 1)
      return this.data[0];
    if (this.t == 0)
      return 0;
  }
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function bnByteValue() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function bnShortValue() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function bnpChunkSize(e) {
  return Math.floor(Math.LN2 * this.DB / Math.log(e));
}
function bnSigNum() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
}
function bnpToRadix(e) {
  if (e == null && (e = 10), this.signum() == 0 || e < 2 || e > 36)
    return "0";
  var t = this.chunkSize(e), a = Math.pow(e, t), n = nbv(a), u = nbi(), o = nbi(), l = "";
  for (this.divRemTo(n, u, o); u.signum() > 0; )
    l = (a + o.intValue()).toString(e).substr(1) + l, u.divRemTo(n, u, o);
  return o.intValue().toString(e) + l;
}
function bnpFromRadix(e, t) {
  this.fromInt(0), t == null && (t = 10);
  for (var a = this.chunkSize(t), n = Math.pow(t, a), u = !1, o = 0, l = 0, h = 0; h < e.length; ++h) {
    var y = intAt(e, h);
    if (y < 0) {
      e.charAt(h) == "-" && this.signum() == 0 && (u = !0);
      continue;
    }
    l = t * l + y, ++o >= a && (this.dMultiply(n), this.dAddOffset(l, 0), o = 0, l = 0);
  }
  o > 0 && (this.dMultiply(Math.pow(t, o)), this.dAddOffset(l, 0)), u && BigInteger$4.ZERO.subTo(this, this);
}
function bnpFromNumber(e, t, a) {
  if (typeof t == "number")
    if (e < 2)
      this.fromInt(1);
    else
      for (this.fromNumber(e, a), this.testBit(e - 1) || this.bitwiseTo(BigInteger$4.ONE.shiftLeft(e - 1), op_or, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(t); )
        this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(BigInteger$4.ONE.shiftLeft(e - 1), this);
  else {
    var n = new Array(), u = e & 7;
    n.length = (e >> 3) + 1, t.nextBytes(n), u > 0 ? n[0] &= (1 << u) - 1 : n[0] = 0, this.fromString(n, 256);
  }
}
function bnToByteArray() {
  var e = this.t, t = new Array();
  t[0] = this.s;
  var a = this.DB - e * this.DB % 8, n, u = 0;
  if (e-- > 0)
    for (a < this.DB && (n = this.data[e] >> a) != (this.s & this.DM) >> a && (t[u++] = n | this.s << this.DB - a); e >= 0; )
      a < 8 ? (n = (this.data[e] & (1 << a) - 1) << 8 - a, n |= this.data[--e] >> (a += this.DB - 8)) : (n = this.data[e] >> (a -= 8) & 255, a <= 0 && (a += this.DB, --e)), n & 128 && (n |= -256), u == 0 && (this.s & 128) != (n & 128) && ++u, (u > 0 || n != this.s) && (t[u++] = n);
  return t;
}
function bnEquals(e) {
  return this.compareTo(e) == 0;
}
function bnMin(e) {
  return this.compareTo(e) < 0 ? this : e;
}
function bnMax(e) {
  return this.compareTo(e) > 0 ? this : e;
}
function bnpBitwiseTo(e, t, a) {
  var n, u, o = Math.min(e.t, this.t);
  for (n = 0; n < o; ++n)
    a.data[n] = t(this.data[n], e.data[n]);
  if (e.t < this.t) {
    for (u = e.s & this.DM, n = o; n < this.t; ++n)
      a.data[n] = t(this.data[n], u);
    a.t = this.t;
  } else {
    for (u = this.s & this.DM, n = o; n < e.t; ++n)
      a.data[n] = t(u, e.data[n]);
    a.t = e.t;
  }
  a.s = t(this.s, e.s), a.clamp();
}
function op_and(e, t) {
  return e & t;
}
function bnAnd(e) {
  var t = nbi();
  return this.bitwiseTo(e, op_and, t), t;
}
function op_or(e, t) {
  return e | t;
}
function bnOr(e) {
  var t = nbi();
  return this.bitwiseTo(e, op_or, t), t;
}
function op_xor(e, t) {
  return e ^ t;
}
function bnXor(e) {
  var t = nbi();
  return this.bitwiseTo(e, op_xor, t), t;
}
function op_andnot(e, t) {
  return e & ~t;
}
function bnAndNot(e) {
  var t = nbi();
  return this.bitwiseTo(e, op_andnot, t), t;
}
function bnNot() {
  for (var e = nbi(), t = 0; t < this.t; ++t)
    e.data[t] = this.DM & ~this.data[t];
  return e.t = this.t, e.s = ~this.s, e;
}
function bnShiftLeft(e) {
  var t = nbi();
  return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t;
}
function bnShiftRight(e) {
  var t = nbi();
  return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t;
}
function lbit(e) {
  if (e == 0)
    return -1;
  var t = 0;
  return e & 65535 || (e >>= 16, t += 16), e & 255 || (e >>= 8, t += 8), e & 15 || (e >>= 4, t += 4), e & 3 || (e >>= 2, t += 2), e & 1 || ++t, t;
}
function bnGetLowestSetBit() {
  for (var e = 0; e < this.t; ++e)
    if (this.data[e] != 0)
      return e * this.DB + lbit(this.data[e]);
  return this.s < 0 ? this.t * this.DB : -1;
}
function cbit(e) {
  for (var t = 0; e != 0; )
    e &= e - 1, ++t;
  return t;
}
function bnBitCount() {
  for (var e = 0, t = this.s & this.DM, a = 0; a < this.t; ++a)
    e += cbit(this.data[a] ^ t);
  return e;
}
function bnTestBit(e) {
  var t = Math.floor(e / this.DB);
  return t >= this.t ? this.s != 0 : (this.data[t] & 1 << e % this.DB) != 0;
}
function bnpChangeBit(e, t) {
  var a = BigInteger$4.ONE.shiftLeft(e);
  return this.bitwiseTo(a, t, a), a;
}
function bnSetBit(e) {
  return this.changeBit(e, op_or);
}
function bnClearBit(e) {
  return this.changeBit(e, op_andnot);
}
function bnFlipBit(e) {
  return this.changeBit(e, op_xor);
}
function bnpAddTo(e, t) {
  for (var a = 0, n = 0, u = Math.min(e.t, this.t); a < u; )
    n += this.data[a] + e.data[a], t.data[a++] = n & this.DM, n >>= this.DB;
  if (e.t < this.t) {
    for (n += e.s; a < this.t; )
      n += this.data[a], t.data[a++] = n & this.DM, n >>= this.DB;
    n += this.s;
  } else {
    for (n += this.s; a < e.t; )
      n += e.data[a], t.data[a++] = n & this.DM, n >>= this.DB;
    n += e.s;
  }
  t.s = n < 0 ? -1 : 0, n > 0 ? t.data[a++] = n : n < -1 && (t.data[a++] = this.DV + n), t.t = a, t.clamp();
}
function bnAdd(e) {
  var t = nbi();
  return this.addTo(e, t), t;
}
function bnSubtract(e) {
  var t = nbi();
  return this.subTo(e, t), t;
}
function bnMultiply(e) {
  var t = nbi();
  return this.multiplyTo(e, t), t;
}
function bnDivide(e) {
  var t = nbi();
  return this.divRemTo(e, t, null), t;
}
function bnRemainder(e) {
  var t = nbi();
  return this.divRemTo(e, null, t), t;
}
function bnDivideAndRemainder(e) {
  var t = nbi(), a = nbi();
  return this.divRemTo(e, t, a), new Array(t, a);
}
function bnpDMultiply(e) {
  this.data[this.t] = this.am(0, e - 1, this, 0, 0, this.t), ++this.t, this.clamp();
}
function bnpDAddOffset(e, t) {
  if (e != 0) {
    for (; this.t <= t; )
      this.data[this.t++] = 0;
    for (this.data[t] += e; this.data[t] >= this.DV; )
      this.data[t] -= this.DV, ++t >= this.t && (this.data[this.t++] = 0), ++this.data[t];
  }
}
function NullExp() {
}
function nNop(e) {
  return e;
}
function nMulTo(e, t, a) {
  e.multiplyTo(t, a);
}
function nSqrTo(e, t) {
  e.squareTo(t);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(e) {
  return this.exp(e, new NullExp());
}
function bnpMultiplyLowerTo(e, t, a) {
  var n = Math.min(this.t + e.t, t);
  for (a.s = 0, a.t = n; n > 0; )
    a.data[--n] = 0;
  var u;
  for (u = a.t - this.t; n < u; ++n)
    a.data[n + this.t] = this.am(0, e.data[n], a, n, 0, this.t);
  for (u = Math.min(e.t, t); n < u; ++n)
    this.am(0, e.data[n], a, n, 0, t - n);
  a.clamp();
}
function bnpMultiplyUpperTo(e, t, a) {
  --t;
  var n = a.t = this.t + e.t - t;
  for (a.s = 0; --n >= 0; )
    a.data[n] = 0;
  for (n = Math.max(t - this.t, 0); n < e.t; ++n)
    a.data[this.t + n - t] = this.am(t - n, e.data[n], a, 0, 0, this.t + n - t);
  a.clamp(), a.drShiftTo(1, a);
}
function Barrett(e) {
  this.r2 = nbi(), this.q3 = nbi(), BigInteger$4.ONE.dlShiftTo(2 * e.t, this.r2), this.mu = this.r2.divide(e), this.m = e;
}
function barrettConvert(e) {
  if (e.s < 0 || e.t > 2 * this.m.t)
    return e.mod(this.m);
  if (e.compareTo(this.m) < 0)
    return e;
  var t = nbi();
  return e.copyTo(t), this.reduce(t), t;
}
function barrettRevert(e) {
  return e;
}
function barrettReduce(e) {
  for (e.drShiftTo(this.m.t - 1, this.r2), e.t > this.m.t + 1 && (e.t = this.m.t + 1, e.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); e.compareTo(this.r2) < 0; )
    e.dAddOffset(1, this.m.t + 1);
  for (e.subTo(this.r2, e); e.compareTo(this.m) >= 0; )
    e.subTo(this.m, e);
}
function barrettSqrTo(e, t) {
  e.squareTo(t), this.reduce(t);
}
function barrettMulTo(e, t, a) {
  e.multiplyTo(t, a), this.reduce(a);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(e, t) {
  var a = e.bitLength(), n, u = nbv(1), o;
  if (a <= 0)
    return u;
  a < 18 ? n = 1 : a < 48 ? n = 3 : a < 144 ? n = 4 : a < 768 ? n = 5 : n = 6, a < 8 ? o = new Classic(t) : t.isEven() ? o = new Barrett(t) : o = new Montgomery(t);
  var l = new Array(), h = 3, y = n - 1, _ = (1 << n) - 1;
  if (l[1] = o.convert(this), n > 1) {
    var d = nbi();
    for (o.sqrTo(l[1], d); h <= _; )
      l[h] = nbi(), o.mulTo(d, l[h - 2], l[h]), h += 2;
  }
  var $ = e.t - 1, N, U = !0, V = nbi(), Q;
  for (a = nbits(e.data[$]) - 1; $ >= 0; ) {
    for (a >= y ? N = e.data[$] >> a - y & _ : (N = (e.data[$] & (1 << a + 1) - 1) << y - a, $ > 0 && (N |= e.data[$ - 1] >> this.DB + a - y)), h = n; !(N & 1); )
      N >>= 1, --h;
    if ((a -= h) < 0 && (a += this.DB, --$), U)
      l[N].copyTo(u), U = !1;
    else {
      for (; h > 1; )
        o.sqrTo(u, V), o.sqrTo(V, u), h -= 2;
      h > 0 ? o.sqrTo(u, V) : (Q = u, u = V, V = Q), o.mulTo(V, l[N], u);
    }
    for (; $ >= 0 && !(e.data[$] & 1 << a); )
      o.sqrTo(u, V), Q = u, u = V, V = Q, --a < 0 && (a = this.DB - 1, --$);
  }
  return o.revert(u);
}
function bnGCD(e) {
  var t = this.s < 0 ? this.negate() : this.clone(), a = e.s < 0 ? e.negate() : e.clone();
  if (t.compareTo(a) < 0) {
    var n = t;
    t = a, a = n;
  }
  var u = t.getLowestSetBit(), o = a.getLowestSetBit();
  if (o < 0)
    return t;
  for (u < o && (o = u), o > 0 && (t.rShiftTo(o, t), a.rShiftTo(o, a)); t.signum() > 0; )
    (u = t.getLowestSetBit()) > 0 && t.rShiftTo(u, t), (u = a.getLowestSetBit()) > 0 && a.rShiftTo(u, a), t.compareTo(a) >= 0 ? (t.subTo(a, t), t.rShiftTo(1, t)) : (a.subTo(t, a), a.rShiftTo(1, a));
  return o > 0 && a.lShiftTo(o, a), a;
}
function bnpModInt(e) {
  if (e <= 0)
    return 0;
  var t = this.DV % e, a = this.s < 0 ? e - 1 : 0;
  if (this.t > 0)
    if (t == 0)
      a = this.data[0] % e;
    else
      for (var n = this.t - 1; n >= 0; --n)
        a = (t * a + this.data[n]) % e;
  return a;
}
function bnModInverse(e) {
  var t = e.isEven();
  if (this.isEven() && t || e.signum() == 0)
    return BigInteger$4.ZERO;
  for (var a = e.clone(), n = this.clone(), u = nbv(1), o = nbv(0), l = nbv(0), h = nbv(1); a.signum() != 0; ) {
    for (; a.isEven(); )
      a.rShiftTo(1, a), t ? ((!u.isEven() || !o.isEven()) && (u.addTo(this, u), o.subTo(e, o)), u.rShiftTo(1, u)) : o.isEven() || o.subTo(e, o), o.rShiftTo(1, o);
    for (; n.isEven(); )
      n.rShiftTo(1, n), t ? ((!l.isEven() || !h.isEven()) && (l.addTo(this, l), h.subTo(e, h)), l.rShiftTo(1, l)) : h.isEven() || h.subTo(e, h), h.rShiftTo(1, h);
    a.compareTo(n) >= 0 ? (a.subTo(n, a), t && u.subTo(l, u), o.subTo(h, o)) : (n.subTo(a, n), t && l.subTo(u, l), h.subTo(o, h));
  }
  if (n.compareTo(BigInteger$4.ONE) != 0)
    return BigInteger$4.ZERO;
  if (h.compareTo(e) >= 0)
    return h.subtract(e);
  if (h.signum() < 0)
    h.addTo(e, h);
  else
    return h;
  return h.signum() < 0 ? h.add(e) : h;
}
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509], lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(e) {
  var t, a = this.abs();
  if (a.t == 1 && a.data[0] <= lowprimes[lowprimes.length - 1]) {
    for (t = 0; t < lowprimes.length; ++t)
      if (a.data[0] == lowprimes[t])
        return !0;
    return !1;
  }
  if (a.isEven())
    return !1;
  for (t = 1; t < lowprimes.length; ) {
    for (var n = lowprimes[t], u = t + 1; u < lowprimes.length && n < lplim; )
      n *= lowprimes[u++];
    for (n = a.modInt(n); t < u; )
      if (n % lowprimes[t++] == 0)
        return !1;
  }
  return a.millerRabin(e);
}
function bnpMillerRabin(e) {
  var t = this.subtract(BigInteger$4.ONE), a = t.getLowestSetBit();
  if (a <= 0)
    return !1;
  for (var n = t.shiftRight(a), u = bnGetPrng(), o, l = 0; l < e; ++l) {
    do
      o = new BigInteger$4(this.bitLength(), u);
    while (o.compareTo(BigInteger$4.ONE) <= 0 || o.compareTo(t) >= 0);
    var h = o.modPow(n, this);
    if (h.compareTo(BigInteger$4.ONE) != 0 && h.compareTo(t) != 0) {
      for (var y = 1; y++ < a && h.compareTo(t) != 0; )
        if (h = h.modPowInt(2, this), h.compareTo(BigInteger$4.ONE) == 0)
          return !1;
      if (h.compareTo(t) != 0)
        return !1;
    }
  }
  return !0;
}
function bnGetPrng() {
  return {
    // x is an array to fill with bytes
    nextBytes: function(e) {
      for (var t = 0; t < e.length; ++t)
        e[t] = Math.floor(Math.random() * 256);
    }
  };
}
BigInteger$4.prototype.chunkSize = bnpChunkSize;
BigInteger$4.prototype.toRadix = bnpToRadix;
BigInteger$4.prototype.fromRadix = bnpFromRadix;
BigInteger$4.prototype.fromNumber = bnpFromNumber;
BigInteger$4.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger$4.prototype.changeBit = bnpChangeBit;
BigInteger$4.prototype.addTo = bnpAddTo;
BigInteger$4.prototype.dMultiply = bnpDMultiply;
BigInteger$4.prototype.dAddOffset = bnpDAddOffset;
BigInteger$4.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger$4.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger$4.prototype.modInt = bnpModInt;
BigInteger$4.prototype.millerRabin = bnpMillerRabin;
BigInteger$4.prototype.clone = bnClone;
BigInteger$4.prototype.intValue = bnIntValue;
BigInteger$4.prototype.byteValue = bnByteValue;
BigInteger$4.prototype.shortValue = bnShortValue;
BigInteger$4.prototype.signum = bnSigNum;
BigInteger$4.prototype.toByteArray = bnToByteArray;
BigInteger$4.prototype.equals = bnEquals;
BigInteger$4.prototype.min = bnMin;
BigInteger$4.prototype.max = bnMax;
BigInteger$4.prototype.and = bnAnd;
BigInteger$4.prototype.or = bnOr;
BigInteger$4.prototype.xor = bnXor;
BigInteger$4.prototype.andNot = bnAndNot;
BigInteger$4.prototype.not = bnNot;
BigInteger$4.prototype.shiftLeft = bnShiftLeft;
BigInteger$4.prototype.shiftRight = bnShiftRight;
BigInteger$4.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger$4.prototype.bitCount = bnBitCount;
BigInteger$4.prototype.testBit = bnTestBit;
BigInteger$4.prototype.setBit = bnSetBit;
BigInteger$4.prototype.clearBit = bnClearBit;
BigInteger$4.prototype.flipBit = bnFlipBit;
BigInteger$4.prototype.add = bnAdd;
BigInteger$4.prototype.subtract = bnSubtract;
BigInteger$4.prototype.multiply = bnMultiply;
BigInteger$4.prototype.divide = bnDivide;
BigInteger$4.prototype.remainder = bnRemainder;
BigInteger$4.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger$4.prototype.modPow = bnModPow;
BigInteger$4.prototype.modInverse = bnModInverse;
BigInteger$4.prototype.pow = bnPow;
BigInteger$4.prototype.gcd = bnGCD;
BigInteger$4.prototype.isProbablePrime = bnIsProbablePrime;
var forge$l = forge$D, sha1 = forge$l.sha1 = forge$l.sha1 || {};
forge$l.md.sha1 = forge$l.md.algorithms.sha1 = sha1;
sha1.create = function() {
  _initialized$1 || _init$1();
  var e = null, t = forge$l.util.createBuffer(), a = new Array(80), n = {
    algorithm: "sha1",
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return n.start = function() {
    n.messageLength = 0, n.fullMessageLength = n.messageLength64 = [];
    for (var u = n.messageLengthSize / 4, o = 0; o < u; ++o)
      n.fullMessageLength.push(0);
    return t = forge$l.util.createBuffer(), e = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878,
      h4: 3285377520
    }, n;
  }, n.start(), n.update = function(u, o) {
    o === "utf8" && (u = forge$l.util.encodeUtf8(u));
    var l = u.length;
    n.messageLength += l, l = [l / 4294967296 >>> 0, l >>> 0];
    for (var h = n.fullMessageLength.length - 1; h >= 0; --h)
      n.fullMessageLength[h] += l[1], l[1] = l[0] + (n.fullMessageLength[h] / 4294967296 >>> 0), n.fullMessageLength[h] = n.fullMessageLength[h] >>> 0, l[0] = l[1] / 4294967296 >>> 0;
    return t.putBytes(u), _update$1(e, a, t), (t.read > 2048 || t.length() === 0) && t.compact(), n;
  }, n.digest = function() {
    var u = forge$l.util.createBuffer();
    u.putBytes(t.bytes());
    var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize, l = o & n.blockLength - 1;
    u.putBytes(_padding$1.substr(0, n.blockLength - l));
    for (var h, y, _ = n.fullMessageLength[0] * 8, d = 0; d < n.fullMessageLength.length - 1; ++d)
      h = n.fullMessageLength[d + 1] * 8, y = h / 4294967296 >>> 0, _ += y, u.putInt32(_ >>> 0), _ = h >>> 0;
    u.putInt32(_);
    var $ = {
      h0: e.h0,
      h1: e.h1,
      h2: e.h2,
      h3: e.h3,
      h4: e.h4
    };
    _update$1($, a, u);
    var N = forge$l.util.createBuffer();
    return N.putInt32($.h0), N.putInt32($.h1), N.putInt32($.h2), N.putInt32($.h3), N.putInt32($.h4), N;
  }, n;
};
var _padding$1 = null, _initialized$1 = !1;
function _init$1() {
  _padding$1 = String.fromCharCode(128), _padding$1 += forge$l.util.fillString(String.fromCharCode(0), 64), _initialized$1 = !0;
}
function _update$1(e, t, a) {
  for (var n, u, o, l, h, y, _, d, $ = a.length(); $ >= 64; ) {
    for (u = e.h0, o = e.h1, l = e.h2, h = e.h3, y = e.h4, d = 0; d < 16; ++d)
      n = a.getInt32(), t[d] = n, _ = h ^ o & (l ^ h), n = (u << 5 | u >>> 27) + _ + y + 1518500249 + n, y = h, h = l, l = (o << 30 | o >>> 2) >>> 0, o = u, u = n;
    for (; d < 20; ++d)
      n = t[d - 3] ^ t[d - 8] ^ t[d - 14] ^ t[d - 16], n = n << 1 | n >>> 31, t[d] = n, _ = h ^ o & (l ^ h), n = (u << 5 | u >>> 27) + _ + y + 1518500249 + n, y = h, h = l, l = (o << 30 | o >>> 2) >>> 0, o = u, u = n;
    for (; d < 32; ++d)
      n = t[d - 3] ^ t[d - 8] ^ t[d - 14] ^ t[d - 16], n = n << 1 | n >>> 31, t[d] = n, _ = o ^ l ^ h, n = (u << 5 | u >>> 27) + _ + y + 1859775393 + n, y = h, h = l, l = (o << 30 | o >>> 2) >>> 0, o = u, u = n;
    for (; d < 40; ++d)
      n = t[d - 6] ^ t[d - 16] ^ t[d - 28] ^ t[d - 32], n = n << 2 | n >>> 30, t[d] = n, _ = o ^ l ^ h, n = (u << 5 | u >>> 27) + _ + y + 1859775393 + n, y = h, h = l, l = (o << 30 | o >>> 2) >>> 0, o = u, u = n;
    for (; d < 60; ++d)
      n = t[d - 6] ^ t[d - 16] ^ t[d - 28] ^ t[d - 32], n = n << 2 | n >>> 30, t[d] = n, _ = o & l | h & (o ^ l), n = (u << 5 | u >>> 27) + _ + y + 2400959708 + n, y = h, h = l, l = (o << 30 | o >>> 2) >>> 0, o = u, u = n;
    for (; d < 80; ++d)
      n = t[d - 6] ^ t[d - 16] ^ t[d - 28] ^ t[d - 32], n = n << 2 | n >>> 30, t[d] = n, _ = o ^ l ^ h, n = (u << 5 | u >>> 27) + _ + y + 3395469782 + n, y = h, h = l, l = (o << 30 | o >>> 2) >>> 0, o = u, u = n;
    e.h0 = e.h0 + u | 0, e.h1 = e.h1 + o | 0, e.h2 = e.h2 + l | 0, e.h3 = e.h3 + h | 0, e.h4 = e.h4 + y | 0, $ -= 64;
  }
}
var forge$k = forge$D, pkcs1 = forge$k.pkcs1 = forge$k.pkcs1 || {};
pkcs1.encode_rsa_oaep = function(e, t, a) {
  var n, u, o, l;
  typeof a == "string" ? (n = a, u = arguments[3] || void 0, o = arguments[4] || void 0) : a && (n = a.label || void 0, u = a.seed || void 0, o = a.md || void 0, a.mgf1 && a.mgf1.md && (l = a.mgf1.md)), o ? o.start() : o = forge$k.md.sha1.create(), l || (l = o);
  var h = Math.ceil(e.n.bitLength() / 8), y = h - 2 * o.digestLength - 2;
  if (t.length > y) {
    var _ = new Error("RSAES-OAEP input message length is too long.");
    throw _.length = t.length, _.maxLength = y, _;
  }
  n || (n = ""), o.update(n, "raw");
  for (var d = o.digest(), $ = "", N = y - t.length, U = 0; U < N; U++)
    $ += "\0";
  var V = d.getBytes() + $ + "" + t;
  if (!u)
    u = forge$k.random.getBytes(o.digestLength);
  else if (u.length !== o.digestLength) {
    var _ = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    throw _.seedLength = u.length, _.digestLength = o.digestLength, _;
  }
  var Q = rsa_mgf1(u, h - o.digestLength - 1, l), ie = forge$k.util.xorBytes(V, Q, V.length), ee = rsa_mgf1(ie, o.digestLength, l), ne = forge$k.util.xorBytes(u, ee, u.length);
  return "\0" + ne + ie;
};
pkcs1.decode_rsa_oaep = function(e, t, a) {
  var n, u, o;
  typeof a == "string" ? (n = a, u = arguments[3] || void 0) : a && (n = a.label || void 0, u = a.md || void 0, a.mgf1 && a.mgf1.md && (o = a.mgf1.md));
  var l = Math.ceil(e.n.bitLength() / 8);
  if (t.length !== l) {
    var ie = new Error("RSAES-OAEP encoded message length is invalid.");
    throw ie.length = t.length, ie.expectedLength = l, ie;
  }
  if (u === void 0 ? u = forge$k.md.sha1.create() : u.start(), o || (o = u), l < 2 * u.digestLength + 2)
    throw new Error("RSAES-OAEP key is too short for the hash function.");
  n || (n = ""), u.update(n, "raw");
  for (var h = u.digest().getBytes(), y = t.charAt(0), _ = t.substring(1, u.digestLength + 1), d = t.substring(1 + u.digestLength), $ = rsa_mgf1(d, u.digestLength, o), N = forge$k.util.xorBytes(_, $, _.length), U = rsa_mgf1(N, l - u.digestLength - 1, o), V = forge$k.util.xorBytes(d, U, d.length), Q = V.substring(0, u.digestLength), ie = y !== "\0", ee = 0; ee < u.digestLength; ++ee)
    ie |= h.charAt(ee) !== Q.charAt(ee);
  for (var ne = 1, ge = u.digestLength, be = u.digestLength; be < V.length; be++) {
    var Ee = V.charCodeAt(be), xe = Ee & 1 ^ 1, Le = ne ? 65534 : 0;
    ie |= Ee & Le, ne = ne & xe, ge += ne;
  }
  if (ie || V.charCodeAt(ge) !== 1)
    throw new Error("Invalid RSAES-OAEP padding.");
  return V.substring(ge + 1);
};
function rsa_mgf1(e, t, a) {
  a || (a = forge$k.md.sha1.create());
  for (var n = "", u = Math.ceil(t / a.digestLength), o = 0; o < u; ++o) {
    var l = String.fromCharCode(
      o >> 24 & 255,
      o >> 16 & 255,
      o >> 8 & 255,
      o & 255
    );
    a.start(), a.update(e + l), n += a.digest().getBytes();
  }
  return n.substring(0, t);
}
var forge$j = forge$D;
(function() {
  if (forge$j.prime) {
    forge$j.prime;
    return;
  }
  var e = forge$j.prime = forge$j.prime || {}, t = forge$j.jsbn.BigInteger, a = [6, 4, 2, 4, 2, 4, 6, 2], n = new t(null);
  n.fromInt(30);
  var u = function($, N) {
    return $ | N;
  };
  e.generateProbablePrime = function($, N, U) {
    typeof N == "function" && (U = N, N = {}), N = N || {};
    var V = N.algorithm || "PRIMEINC";
    typeof V == "string" && (V = { name: V }), V.options = V.options || {};
    var Q = N.prng || forge$j.random, ie = {
      // x is an array to fill with bytes
      nextBytes: function(ee) {
        for (var ne = Q.getBytesSync(ee.length), ge = 0; ge < ee.length; ++ge)
          ee[ge] = ne.charCodeAt(ge);
      }
    };
    if (V.name === "PRIMEINC")
      return o($, ie, V.options, U);
    throw new Error("Invalid prime generation algorithm: " + V.name);
  };
  function o($, N, U, V) {
    return "workers" in U ? y($, N, U, V) : l($, N, U, V);
  }
  function l($, N, U, V) {
    var Q = _($, N), ie = 0, ee = d(Q.bitLength());
    "millerRabinTests" in U && (ee = U.millerRabinTests);
    var ne = 10;
    "maxBlockTime" in U && (ne = U.maxBlockTime), h(Q, $, N, ie, ee, ne, V);
  }
  function h($, N, U, V, Q, ie, ee) {
    var ne = +/* @__PURE__ */ new Date();
    do {
      if ($.bitLength() > N && ($ = _(N, U)), $.isProbablePrime(Q))
        return ee(null, $);
      $.dAddOffset(a[V++ % 8], 0);
    } while (ie < 0 || +/* @__PURE__ */ new Date() - ne < ie);
    forge$j.util.setImmediate(function() {
      h($, N, U, V, Q, ie, ee);
    });
  }
  function y($, N, U, V) {
    if (typeof Worker > "u")
      return l($, N, U, V);
    var Q = _($, N), ie = U.workers, ee = U.workLoad || 100, ne = ee * 30 / 8, ge = U.workerScript || "forge/prime.worker.js";
    if (ie === -1)
      return forge$j.util.estimateCores(function(Ee, xe) {
        Ee && (xe = 2), ie = xe - 1, be();
      });
    be();
    function be() {
      ie = Math.max(1, ie);
      for (var Ee = [], xe = 0; xe < ie; ++xe)
        Ee[xe] = new Worker(ge);
      for (var xe = 0; xe < ie; ++xe)
        Ee[xe].addEventListener("message", Ne);
      var Le = !1;
      function Ne(Re) {
        if (!Le) {
          var Xe = Re.data;
          if (Xe.found) {
            for (var pe = 0; pe < Ee.length; ++pe)
              Ee[pe].terminate();
            return Le = !0, V(null, new t(Xe.prime, 16));
          }
          Q.bitLength() > $ && (Q = _($, N));
          var O = Q.toString(16);
          Re.target.postMessage({
            hex: O,
            workLoad: ee
          }), Q.dAddOffset(ne, 0);
        }
      }
    }
  }
  function _($, N) {
    var U = new t($, N), V = $ - 1;
    return U.testBit(V) || U.bitwiseTo(t.ONE.shiftLeft(V), u, U), U.dAddOffset(31 - U.mod(n).byteValue(), 0), U;
  }
  function d($) {
    return $ <= 100 ? 27 : $ <= 150 ? 18 : $ <= 200 ? 15 : $ <= 250 ? 12 : $ <= 300 ? 9 : $ <= 350 ? 8 : $ <= 400 ? 7 : $ <= 500 ? 6 : $ <= 600 ? 5 : $ <= 800 ? 4 : $ <= 1250 ? 3 : 2;
  }
})();
var forge$i = forge$D;
if (typeof BigInteger$3 > "u")
  var BigInteger$3 = forge$i.jsbn.BigInteger;
var _crypto = forge$i.util.isNodejs ? requireCryptoBrowserify() : null, asn1$7 = forge$i.asn1, util = forge$i.util;
forge$i.pki = forge$i.pki || {};
forge$i.pki.rsa = forge$i.rsa = forge$i.rsa || {};
var pki$4 = forge$i.pki, GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2], privateKeyValidator$1 = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.OID,
      constructed: !1,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.OCTETSTRING,
    constructed: !1,
    capture: "privateKey"
  }]
}, rsaPrivateKeyValidator = {
  // RSAPrivateKey
  name: "RSAPrivateKey",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "RSAPrivateKey.version",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // modulus (n)
    name: "RSAPrivateKey.modulus",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPrivateKey.publicExponent",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPublicExponent"
  }, {
    // privateExponent (d)
    name: "RSAPrivateKey.privateExponent",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrivateExponent"
  }, {
    // prime1 (p)
    name: "RSAPrivateKey.prime1",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrime1"
  }, {
    // prime2 (q)
    name: "RSAPrivateKey.prime2",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrime2"
  }, {
    // exponent1 (d mod (p-1))
    name: "RSAPrivateKey.exponent1",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyExponent1"
  }, {
    // exponent2 (d mod (q-1))
    name: "RSAPrivateKey.exponent2",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyExponent2"
  }, {
    // coefficient ((inverse of q) mod p)
    name: "RSAPrivateKey.coefficient",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyCoefficient"
  }]
}, rsaPublicKeyValidator = {
  // RSAPublicKey
  name: "RSAPublicKey",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // modulus (n)
    name: "RSAPublicKey.modulus",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "publicKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPublicKey.exponent",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: !1,
    capture: "publicKeyExponent"
  }]
}, publicKeyValidator$2 = forge$i.pki.rsa.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "subjectPublicKeyInfo",
  value: [{
    name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.OID,
      constructed: !1,
      capture: "publicKeyOid"
    }]
  }, {
    // subjectPublicKey
    name: "SubjectPublicKeyInfo.subjectPublicKey",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.BITSTRING,
    constructed: !1,
    value: [{
      // RSAPublicKey
      name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.SEQUENCE,
      constructed: !0,
      optional: !0,
      captureAsn1: "rsaPublicKey"
    }]
  }]
}, digestInfoValidator = {
  name: "DigestInfo",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "DigestInfo.DigestAlgorithm",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.OID,
      constructed: !1,
      capture: "algorithmIdentifier"
    }, {
      // NULL parameters
      name: "DigestInfo.DigestAlgorithm.parameters",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.NULL,
      // captured only to check existence for md2 and md5
      capture: "parameters",
      optional: !0,
      constructed: !1
    }]
  }, {
    // digest
    name: "DigestInfo.digest",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.OCTETSTRING,
    constructed: !1,
    capture: "digest"
  }]
}, emsaPkcs1v15encode = function(e) {
  var t;
  if (e.algorithm in pki$4.oids)
    t = pki$4.oids[e.algorithm];
  else {
    var a = new Error("Unknown message digest algorithm.");
    throw a.algorithm = e.algorithm, a;
  }
  var n = asn1$7.oidToDer(t).getBytes(), u = asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.SEQUENCE,
    !0,
    []
  ), o = asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.SEQUENCE,
    !0,
    []
  );
  o.value.push(asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.OID,
    !1,
    n
  )), o.value.push(asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.NULL,
    !1,
    ""
  ));
  var l = asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.OCTETSTRING,
    !1,
    e.digest().getBytes()
  );
  return u.value.push(o), u.value.push(l), asn1$7.toDer(u).getBytes();
}, _modPow = function(e, t, a) {
  if (a)
    return e.modPow(t.e, t.n);
  if (!t.p || !t.q)
    return e.modPow(t.d, t.n);
  t.dP || (t.dP = t.d.mod(t.p.subtract(BigInteger$3.ONE))), t.dQ || (t.dQ = t.d.mod(t.q.subtract(BigInteger$3.ONE))), t.qInv || (t.qInv = t.q.modInverse(t.p));
  var n;
  do
    n = new BigInteger$3(
      forge$i.util.bytesToHex(forge$i.random.getBytes(t.n.bitLength() / 8)),
      16
    );
  while (n.compareTo(t.n) >= 0 || !n.gcd(t.n).equals(BigInteger$3.ONE));
  e = e.multiply(n.modPow(t.e, t.n)).mod(t.n);
  for (var u = e.mod(t.p).modPow(t.dP, t.p), o = e.mod(t.q).modPow(t.dQ, t.q); u.compareTo(o) < 0; )
    u = u.add(t.p);
  var l = u.subtract(o).multiply(t.qInv).mod(t.p).multiply(t.q).add(o);
  return l = l.multiply(n.modInverse(t.n)).mod(t.n), l;
};
pki$4.rsa.encrypt = function(e, t, a) {
  var n = a, u, o = Math.ceil(t.n.bitLength() / 8);
  a !== !1 && a !== !0 ? (n = a === 2, u = _encodePkcs1_v1_5(e, t, a)) : (u = forge$i.util.createBuffer(), u.putBytes(e));
  for (var l = new BigInteger$3(u.toHex(), 16), h = _modPow(l, t, n), y = h.toString(16), _ = forge$i.util.createBuffer(), d = o - Math.ceil(y.length / 2); d > 0; )
    _.putByte(0), --d;
  return _.putBytes(forge$i.util.hexToBytes(y)), _.getBytes();
};
pki$4.rsa.decrypt = function(e, t, a, n) {
  var u = Math.ceil(t.n.bitLength() / 8);
  if (e.length !== u) {
    var o = new Error("Encrypted message length is invalid.");
    throw o.length = e.length, o.expected = u, o;
  }
  var l = new BigInteger$3(forge$i.util.createBuffer(e).toHex(), 16);
  if (l.compareTo(t.n) >= 0)
    throw new Error("Encrypted message is invalid.");
  for (var h = _modPow(l, t, a), y = h.toString(16), _ = forge$i.util.createBuffer(), d = u - Math.ceil(y.length / 2); d > 0; )
    _.putByte(0), --d;
  return _.putBytes(forge$i.util.hexToBytes(y)), n !== !1 ? _decodePkcs1_v1_5(_.getBytes(), t, a) : _.getBytes();
};
pki$4.rsa.createKeyPairGenerationState = function(e, t, a) {
  typeof e == "string" && (e = parseInt(e, 10)), e = e || 2048, a = a || {};
  var n = a.prng || forge$i.random, u = {
    // x is an array to fill with bytes
    nextBytes: function(h) {
      for (var y = n.getBytesSync(h.length), _ = 0; _ < h.length; ++_)
        h[_] = y.charCodeAt(_);
    }
  }, o = a.algorithm || "PRIMEINC", l;
  if (o === "PRIMEINC")
    l = {
      algorithm: o,
      state: 0,
      bits: e,
      rng: u,
      eInt: t || 65537,
      e: new BigInteger$3(null),
      p: null,
      q: null,
      qBits: e >> 1,
      pBits: e - (e >> 1),
      pqState: 0,
      num: null,
      keys: null
    }, l.e.fromInt(l.eInt);
  else
    throw new Error("Invalid key generation algorithm: " + o);
  return l;
};
pki$4.rsa.stepKeyPairGenerationState = function(e, t) {
  "algorithm" in e || (e.algorithm = "PRIMEINC");
  var a = new BigInteger$3(null);
  a.fromInt(30);
  for (var n = 0, u = function($, N) {
    return $ | N;
  }, o = +/* @__PURE__ */ new Date(), l, h = 0; e.keys === null && (t <= 0 || h < t); ) {
    if (e.state === 0) {
      var y = e.p === null ? e.pBits : e.qBits, _ = y - 1;
      e.pqState === 0 ? (e.num = new BigInteger$3(y, e.rng), e.num.testBit(_) || e.num.bitwiseTo(
        BigInteger$3.ONE.shiftLeft(_),
        u,
        e.num
      ), e.num.dAddOffset(31 - e.num.mod(a).byteValue(), 0), n = 0, ++e.pqState) : e.pqState === 1 ? e.num.bitLength() > y ? e.pqState = 0 : e.num.isProbablePrime(
        _getMillerRabinTests(e.num.bitLength())
      ) ? ++e.pqState : e.num.dAddOffset(GCD_30_DELTA[n++ % 8], 0) : e.pqState === 2 ? e.pqState = e.num.subtract(BigInteger$3.ONE).gcd(e.e).compareTo(BigInteger$3.ONE) === 0 ? 3 : 0 : e.pqState === 3 && (e.pqState = 0, e.p === null ? e.p = e.num : e.q = e.num, e.p !== null && e.q !== null && ++e.state, e.num = null);
    } else if (e.state === 1)
      e.p.compareTo(e.q) < 0 && (e.num = e.p, e.p = e.q, e.q = e.num), ++e.state;
    else if (e.state === 2)
      e.p1 = e.p.subtract(BigInteger$3.ONE), e.q1 = e.q.subtract(BigInteger$3.ONE), e.phi = e.p1.multiply(e.q1), ++e.state;
    else if (e.state === 3)
      e.phi.gcd(e.e).compareTo(BigInteger$3.ONE) === 0 ? ++e.state : (e.p = null, e.q = null, e.state = 0);
    else if (e.state === 4)
      e.n = e.p.multiply(e.q), e.n.bitLength() === e.bits ? ++e.state : (e.q = null, e.state = 0);
    else if (e.state === 5) {
      var d = e.e.modInverse(e.phi);
      e.keys = {
        privateKey: pki$4.rsa.setPrivateKey(
          e.n,
          e.e,
          d,
          e.p,
          e.q,
          d.mod(e.p1),
          d.mod(e.q1),
          e.q.modInverse(e.p)
        ),
        publicKey: pki$4.rsa.setPublicKey(e.n, e.e)
      };
    }
    l = +/* @__PURE__ */ new Date(), h += l - o, o = l;
  }
  return e.keys !== null;
};
pki$4.rsa.generateKeyPair = function(e, t, a, n) {
  if (arguments.length === 1 ? typeof e == "object" ? (a = e, e = void 0) : typeof e == "function" && (n = e, e = void 0) : arguments.length === 2 ? typeof e == "number" ? typeof t == "function" ? (n = t, t = void 0) : typeof t != "number" && (a = t, t = void 0) : (a = e, n = t, e = void 0, t = void 0) : arguments.length === 3 && (typeof t == "number" ? typeof a == "function" && (n = a, a = void 0) : (n = a, a = t, t = void 0)), a = a || {}, e === void 0 && (e = a.bits || 2048), t === void 0 && (t = a.e || 65537), !forge$i.options.usePureJavaScript && !a.prng && e >= 256 && e <= 16384 && (t === 65537 || t === 3)) {
    if (n) {
      if (_detectNodeCrypto("generateKeyPair"))
        return _crypto.generateKeyPair("rsa", {
          modulusLength: e,
          publicExponent: t,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        }, function(h, y, _) {
          if (h)
            return n(h);
          n(null, {
            privateKey: pki$4.privateKeyFromPem(_),
            publicKey: pki$4.publicKeyFromPem(y)
          });
        });
      if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey"))
        return util.globalScope.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: e,
          publicExponent: _intToUint8Array(t),
          hash: { name: "SHA-256" }
        }, !0, ["sign", "verify"]).then(function(h) {
          return util.globalScope.crypto.subtle.exportKey(
            "pkcs8",
            h.privateKey
          );
        }).then(void 0, function(h) {
          n(h);
        }).then(function(h) {
          if (h) {
            var y = pki$4.privateKeyFromAsn1(
              asn1$7.fromDer(forge$i.util.createBuffer(h))
            );
            n(null, {
              privateKey: y,
              publicKey: pki$4.setRsaPublicKey(y.n, y.e)
            });
          }
        });
      if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
        var u = util.globalScope.msCrypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: e,
          publicExponent: _intToUint8Array(t),
          hash: { name: "SHA-256" }
        }, !0, ["sign", "verify"]);
        u.oncomplete = function(h) {
          var y = h.target.result, _ = util.globalScope.msCrypto.subtle.exportKey(
            "pkcs8",
            y.privateKey
          );
          _.oncomplete = function(d) {
            var $ = d.target.result, N = pki$4.privateKeyFromAsn1(
              asn1$7.fromDer(forge$i.util.createBuffer($))
            );
            n(null, {
              privateKey: N,
              publicKey: pki$4.setRsaPublicKey(N.n, N.e)
            });
          }, _.onerror = function(d) {
            n(d);
          };
        }, u.onerror = function(h) {
          n(h);
        };
        return;
      }
    } else if (_detectNodeCrypto("generateKeyPairSync")) {
      var o = _crypto.generateKeyPairSync("rsa", {
        modulusLength: e,
        publicExponent: t,
        publicKeyEncoding: {
          type: "spki",
          format: "pem"
        },
        privateKeyEncoding: {
          type: "pkcs8",
          format: "pem"
        }
      });
      return {
        privateKey: pki$4.privateKeyFromPem(o.privateKey),
        publicKey: pki$4.publicKeyFromPem(o.publicKey)
      };
    }
  }
  var l = pki$4.rsa.createKeyPairGenerationState(e, t, a);
  if (!n)
    return pki$4.rsa.stepKeyPairGenerationState(l, 0), l.keys;
  _generateKeyPair(l, a, n);
};
pki$4.setRsaPublicKey = pki$4.rsa.setPublicKey = function(e, t) {
  var a = {
    n: e,
    e: t
  };
  return a.encrypt = function(n, u, o) {
    if (typeof u == "string" ? u = u.toUpperCase() : u === void 0 && (u = "RSAES-PKCS1-V1_5"), u === "RSAES-PKCS1-V1_5")
      u = {
        encode: function(h, y, _) {
          return _encodePkcs1_v1_5(h, y, 2).getBytes();
        }
      };
    else if (u === "RSA-OAEP" || u === "RSAES-OAEP")
      u = {
        encode: function(h, y) {
          return forge$i.pkcs1.encode_rsa_oaep(y, h, o);
        }
      };
    else if (["RAW", "NONE", "NULL", null].indexOf(u) !== -1)
      u = { encode: function(h) {
        return h;
      } };
    else if (typeof u == "string")
      throw new Error('Unsupported encryption scheme: "' + u + '".');
    var l = u.encode(n, a, !0);
    return pki$4.rsa.encrypt(l, a, !0);
  }, a.verify = function(n, u, o, l) {
    typeof o == "string" ? o = o.toUpperCase() : o === void 0 && (o = "RSASSA-PKCS1-V1_5"), l === void 0 && (l = {
      _parseAllDigestBytes: !0
    }), "_parseAllDigestBytes" in l || (l._parseAllDigestBytes = !0), o === "RSASSA-PKCS1-V1_5" ? o = {
      verify: function(y, _) {
        _ = _decodePkcs1_v1_5(_, a, !0);
        var d = asn1$7.fromDer(_, {
          parseAllBytes: l._parseAllDigestBytes
        }), $ = {}, N = [];
        if (!asn1$7.validate(d, digestInfoValidator, $, N)) {
          var U = new Error(
            "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
          );
          throw U.errors = N, U;
        }
        var V = asn1$7.derToOid($.algorithmIdentifier);
        if (!(V === forge$i.oids.md2 || V === forge$i.oids.md5 || V === forge$i.oids.sha1 || V === forge$i.oids.sha224 || V === forge$i.oids.sha256 || V === forge$i.oids.sha384 || V === forge$i.oids.sha512 || V === forge$i.oids["sha512-224"] || V === forge$i.oids["sha512-256"])) {
          var U = new Error(
            "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
          );
          throw U.oid = V, U;
        }
        if ((V === forge$i.oids.md2 || V === forge$i.oids.md5) && !("parameters" in $))
          throw new Error(
            "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifier NULL parameters."
          );
        return y === $.digest;
      }
    } : (o === "NONE" || o === "NULL" || o === null) && (o = {
      verify: function(y, _) {
        return _ = _decodePkcs1_v1_5(_, a, !0), y === _;
      }
    });
    var h = pki$4.rsa.decrypt(u, a, !0, !1);
    return o.verify(n, h, a.n.bitLength());
  }, a;
};
pki$4.setRsaPrivateKey = pki$4.rsa.setPrivateKey = function(e, t, a, n, u, o, l, h) {
  var y = {
    n: e,
    e: t,
    d: a,
    p: n,
    q: u,
    dP: o,
    dQ: l,
    qInv: h
  };
  return y.decrypt = function(_, d, $) {
    typeof d == "string" ? d = d.toUpperCase() : d === void 0 && (d = "RSAES-PKCS1-V1_5");
    var N = pki$4.rsa.decrypt(_, y, !1, !1);
    if (d === "RSAES-PKCS1-V1_5")
      d = { decode: _decodePkcs1_v1_5 };
    else if (d === "RSA-OAEP" || d === "RSAES-OAEP")
      d = {
        decode: function(U, V) {
          return forge$i.pkcs1.decode_rsa_oaep(V, U, $);
        }
      };
    else if (["RAW", "NONE", "NULL", null].indexOf(d) !== -1)
      d = { decode: function(U) {
        return U;
      } };
    else
      throw new Error('Unsupported encryption scheme: "' + d + '".');
    return d.decode(N, y, !1);
  }, y.sign = function(_, d) {
    var $ = !1;
    typeof d == "string" && (d = d.toUpperCase()), d === void 0 || d === "RSASSA-PKCS1-V1_5" ? (d = { encode: emsaPkcs1v15encode }, $ = 1) : (d === "NONE" || d === "NULL" || d === null) && (d = { encode: function() {
      return _;
    } }, $ = 1);
    var N = d.encode(_, y.n.bitLength());
    return pki$4.rsa.encrypt(N, y, $);
  }, y;
};
pki$4.wrapRsaPrivateKey = function(e) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, !0, [
    // version (0)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      asn1$7.integerToDer(0).getBytes()
    ),
    // privateKeyAlgorithm
    asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, !0, [
      asn1$7.create(
        asn1$7.Class.UNIVERSAL,
        asn1$7.Type.OID,
        !1,
        asn1$7.oidToDer(pki$4.oids.rsaEncryption).getBytes()
      ),
      asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.NULL, !1, "")
    ]),
    // PrivateKey
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.OCTETSTRING,
      !1,
      asn1$7.toDer(e).getBytes()
    )
  ]);
};
pki$4.privateKeyFromAsn1 = function(e) {
  var t = {}, a = [];
  if (asn1$7.validate(e, privateKeyValidator$1, t, a) && (e = asn1$7.fromDer(forge$i.util.createBuffer(t.privateKey))), t = {}, a = [], !asn1$7.validate(e, rsaPrivateKeyValidator, t, a)) {
    var n = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    throw n.errors = a, n;
  }
  var u, o, l, h, y, _, d, $;
  return u = forge$i.util.createBuffer(t.privateKeyModulus).toHex(), o = forge$i.util.createBuffer(t.privateKeyPublicExponent).toHex(), l = forge$i.util.createBuffer(t.privateKeyPrivateExponent).toHex(), h = forge$i.util.createBuffer(t.privateKeyPrime1).toHex(), y = forge$i.util.createBuffer(t.privateKeyPrime2).toHex(), _ = forge$i.util.createBuffer(t.privateKeyExponent1).toHex(), d = forge$i.util.createBuffer(t.privateKeyExponent2).toHex(), $ = forge$i.util.createBuffer(t.privateKeyCoefficient).toHex(), pki$4.setRsaPrivateKey(
    new BigInteger$3(u, 16),
    new BigInteger$3(o, 16),
    new BigInteger$3(l, 16),
    new BigInteger$3(h, 16),
    new BigInteger$3(y, 16),
    new BigInteger$3(_, 16),
    new BigInteger$3(d, 16),
    new BigInteger$3($, 16)
  );
};
pki$4.privateKeyToAsn1 = pki$4.privateKeyToRSAPrivateKey = function(e) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, !0, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      asn1$7.integerToDer(0).getBytes()
    ),
    // modulus (n)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.n)
    ),
    // publicExponent (e)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.e)
    ),
    // privateExponent (d)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.d)
    ),
    // privateKeyPrime1 (p)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.p)
    ),
    // privateKeyPrime2 (q)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.q)
    ),
    // privateKeyExponent1 (dP)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.dP)
    ),
    // privateKeyExponent2 (dQ)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.dQ)
    ),
    // coefficient (qInv)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.qInv)
    )
  ]);
};
pki$4.publicKeyFromAsn1 = function(e) {
  var t = {}, a = [];
  if (asn1$7.validate(e, publicKeyValidator$2, t, a)) {
    var n = asn1$7.derToOid(t.publicKeyOid);
    if (n !== pki$4.oids.rsaEncryption) {
      var u = new Error("Cannot read public key. Unknown OID.");
      throw u.oid = n, u;
    }
    e = t.rsaPublicKey;
  }
  if (a = [], !asn1$7.validate(e, rsaPublicKeyValidator, t, a)) {
    var u = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    throw u.errors = a, u;
  }
  var o = forge$i.util.createBuffer(t.publicKeyModulus).toHex(), l = forge$i.util.createBuffer(t.publicKeyExponent).toHex();
  return pki$4.setRsaPublicKey(
    new BigInteger$3(o, 16),
    new BigInteger$3(l, 16)
  );
};
pki$4.publicKeyToAsn1 = pki$4.publicKeyToSubjectPublicKeyInfo = function(e) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, !0, [
    // AlgorithmIdentifier
    asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, !0, [
      // algorithm
      asn1$7.create(
        asn1$7.Class.UNIVERSAL,
        asn1$7.Type.OID,
        !1,
        asn1$7.oidToDer(pki$4.oids.rsaEncryption).getBytes()
      ),
      // parameters (null)
      asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.NULL, !1, "")
    ]),
    // subjectPublicKey
    asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.BITSTRING, !1, [
      pki$4.publicKeyToRSAPublicKey(e)
    ])
  ]);
};
pki$4.publicKeyToRSAPublicKey = function(e) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, !0, [
    // modulus (n)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.n)
    ),
    // publicExponent (e)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      !1,
      _bnToBytes(e.e)
    )
  ]);
};
function _encodePkcs1_v1_5(e, t, a) {
  var n = forge$i.util.createBuffer(), u = Math.ceil(t.n.bitLength() / 8);
  if (e.length > u - 11) {
    var o = new Error("Message is too long for PKCS#1 v1.5 padding.");
    throw o.length = e.length, o.max = u - 11, o;
  }
  n.putByte(0), n.putByte(a);
  var l = u - 3 - e.length, h;
  if (a === 0 || a === 1) {
    h = a === 0 ? 0 : 255;
    for (var y = 0; y < l; ++y)
      n.putByte(h);
  } else
    for (; l > 0; ) {
      for (var _ = 0, d = forge$i.random.getBytes(l), y = 0; y < l; ++y)
        h = d.charCodeAt(y), h === 0 ? ++_ : n.putByte(h);
      l = _;
    }
  return n.putByte(0), n.putBytes(e), n;
}
function _decodePkcs1_v1_5(e, t, a, n) {
  var u = Math.ceil(t.n.bitLength() / 8), o = forge$i.util.createBuffer(e), l = o.getByte(), h = o.getByte();
  if (l !== 0 || a && h !== 0 && h !== 1 || !a && h != 2 || a && h === 0 && typeof n > "u")
    throw new Error("Encryption block is invalid.");
  var y = 0;
  if (h === 0) {
    y = u - 3 - n;
    for (var _ = 0; _ < y; ++_)
      if (o.getByte() !== 0)
        throw new Error("Encryption block is invalid.");
  } else if (h === 1)
    for (y = 0; o.length() > 1; ) {
      if (o.getByte() !== 255) {
        --o.read;
        break;
      }
      ++y;
    }
  else if (h === 2)
    for (y = 0; o.length() > 1; ) {
      if (o.getByte() === 0) {
        --o.read;
        break;
      }
      ++y;
    }
  var d = o.getByte();
  if (d !== 0 || y !== u - 3 - o.length())
    throw new Error("Encryption block is invalid.");
  return o.getBytes();
}
function _generateKeyPair(e, t, a) {
  typeof t == "function" && (a = t, t = {}), t = t || {};
  var n = {
    algorithm: {
      name: t.algorithm || "PRIMEINC",
      options: {
        workers: t.workers || 2,
        workLoad: t.workLoad || 100,
        workerScript: t.workerScript
      }
    }
  };
  "prng" in t && (n.prng = t.prng), u();
  function u() {
    o(e.pBits, function(h, y) {
      if (h)
        return a(h);
      if (e.p = y, e.q !== null)
        return l(h, e.q);
      o(e.qBits, l);
    });
  }
  function o(h, y) {
    forge$i.prime.generateProbablePrime(h, n, y);
  }
  function l(h, y) {
    if (h)
      return a(h);
    if (e.q = y, e.p.compareTo(e.q) < 0) {
      var _ = e.p;
      e.p = e.q, e.q = _;
    }
    if (e.p.subtract(BigInteger$3.ONE).gcd(e.e).compareTo(BigInteger$3.ONE) !== 0) {
      e.p = null, u();
      return;
    }
    if (e.q.subtract(BigInteger$3.ONE).gcd(e.e).compareTo(BigInteger$3.ONE) !== 0) {
      e.q = null, o(e.qBits, l);
      return;
    }
    if (e.p1 = e.p.subtract(BigInteger$3.ONE), e.q1 = e.q.subtract(BigInteger$3.ONE), e.phi = e.p1.multiply(e.q1), e.phi.gcd(e.e).compareTo(BigInteger$3.ONE) !== 0) {
      e.p = e.q = null, u();
      return;
    }
    if (e.n = e.p.multiply(e.q), e.n.bitLength() !== e.bits) {
      e.q = null, o(e.qBits, l);
      return;
    }
    var d = e.e.modInverse(e.phi);
    e.keys = {
      privateKey: pki$4.rsa.setPrivateKey(
        e.n,
        e.e,
        d,
        e.p,
        e.q,
        d.mod(e.p1),
        d.mod(e.q1),
        e.q.modInverse(e.p)
      ),
      publicKey: pki$4.rsa.setPublicKey(e.n, e.e)
    }, a(null, e.keys);
  }
}
function _bnToBytes(e) {
  var t = e.toString(16);
  t[0] >= "8" && (t = "00" + t);
  var a = forge$i.util.hexToBytes(t);
  return a.length > 1 && // leading 0x00 for positive integer
  (a.charCodeAt(0) === 0 && !(a.charCodeAt(1) & 128) || // leading 0xFF for negative integer
  a.charCodeAt(0) === 255 && (a.charCodeAt(1) & 128) === 128) ? a.substr(1) : a;
}
function _getMillerRabinTests(e) {
  return e <= 100 ? 27 : e <= 150 ? 18 : e <= 200 ? 15 : e <= 250 ? 12 : e <= 300 ? 9 : e <= 350 ? 8 : e <= 400 ? 7 : e <= 500 ? 6 : e <= 600 ? 5 : e <= 800 ? 4 : e <= 1250 ? 3 : 2;
}
function _detectNodeCrypto(e) {
  return forge$i.util.isNodejs && typeof _crypto[e] == "function";
}
function _detectSubtleCrypto(e) {
  return typeof util.globalScope < "u" && typeof util.globalScope.crypto == "object" && typeof util.globalScope.crypto.subtle == "object" && typeof util.globalScope.crypto.subtle[e] == "function";
}
function _detectSubtleMsCrypto(e) {
  return typeof util.globalScope < "u" && typeof util.globalScope.msCrypto == "object" && typeof util.globalScope.msCrypto.subtle == "object" && typeof util.globalScope.msCrypto.subtle[e] == "function";
}
function _intToUint8Array(e) {
  for (var t = forge$i.util.hexToBytes(e.toString(16)), a = new Uint8Array(t.length), n = 0; n < t.length; ++n)
    a[n] = t.charCodeAt(n);
  return a;
}
var forge$h = forge$D;
if (typeof BigInteger$2 > "u")
  var BigInteger$2 = forge$h.jsbn.BigInteger;
var asn1$6 = forge$h.asn1, pki$3 = forge$h.pki = forge$h.pki || {};
pki$3.pbe = forge$h.pbe = forge$h.pbe || {};
var oids$1 = pki$3.oids, encryptedPrivateKeyValidator = {
  name: "EncryptedPrivateKeyInfo",
  tagClass: asn1$6.Class.UNIVERSAL,
  type: asn1$6.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OID,
      constructed: !1,
      capture: "encryptionOid"
    }, {
      name: "AlgorithmIdentifier.parameters",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "encryptionParams"
    }]
  }, {
    // encryptedData
    name: "EncryptedPrivateKeyInfo.encryptedData",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.OCTETSTRING,
    constructed: !1,
    capture: "encryptedData"
  }]
}, PBES2AlgorithmsValidator = {
  name: "PBES2Algorithms",
  tagClass: asn1$6.Class.UNIVERSAL,
  type: asn1$6.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "PBES2Algorithms.keyDerivationFunc",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc.oid",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OID,
      constructed: !1,
      capture: "kdfOid"
    }, {
      name: "PBES2Algorithms.params",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PBES2Algorithms.params.salt",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.OCTETSTRING,
        constructed: !1,
        capture: "kdfSalt"
      }, {
        name: "PBES2Algorithms.params.iterationCount",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.INTEGER,
        constructed: !1,
        capture: "kdfIterationCount"
      }, {
        name: "PBES2Algorithms.params.keyLength",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.INTEGER,
        constructed: !1,
        optional: !0,
        capture: "keyLength"
      }, {
        // prf
        name: "PBES2Algorithms.params.prf",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.SEQUENCE,
        constructed: !0,
        optional: !0,
        value: [{
          name: "PBES2Algorithms.params.prf.algorithm",
          tagClass: asn1$6.Class.UNIVERSAL,
          type: asn1$6.Type.OID,
          constructed: !1,
          capture: "prfOid"
        }]
      }]
    }]
  }, {
    name: "PBES2Algorithms.encryptionScheme",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PBES2Algorithms.encryptionScheme.oid",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OID,
      constructed: !1,
      capture: "encOid"
    }, {
      name: "PBES2Algorithms.encryptionScheme.iv",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OCTETSTRING,
      constructed: !1,
      capture: "encIv"
    }]
  }]
}, pkcs12PbeParamsValidator = {
  name: "pkcs-12PbeParams",
  tagClass: asn1$6.Class.UNIVERSAL,
  type: asn1$6.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "pkcs-12PbeParams.salt",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.OCTETSTRING,
    constructed: !1,
    capture: "salt"
  }, {
    name: "pkcs-12PbeParams.iterations",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.INTEGER,
    constructed: !1,
    capture: "iterations"
  }]
};
pki$3.encryptPrivateKeyInfo = function(e, t, a) {
  a = a || {}, a.saltSize = a.saltSize || 8, a.count = a.count || 2048, a.algorithm = a.algorithm || "aes128", a.prfAlgorithm = a.prfAlgorithm || "sha1";
  var n = forge$h.random.getBytesSync(a.saltSize), u = a.count, o = asn1$6.integerToDer(u), l, h, y;
  if (a.algorithm.indexOf("aes") === 0 || a.algorithm === "des") {
    var _, d, $;
    switch (a.algorithm) {
      case "aes128":
        l = 16, _ = 16, d = oids$1["aes128-CBC"], $ = forge$h.aes.createEncryptionCipher;
        break;
      case "aes192":
        l = 24, _ = 16, d = oids$1["aes192-CBC"], $ = forge$h.aes.createEncryptionCipher;
        break;
      case "aes256":
        l = 32, _ = 16, d = oids$1["aes256-CBC"], $ = forge$h.aes.createEncryptionCipher;
        break;
      case "des":
        l = 8, _ = 8, d = oids$1.desCBC, $ = forge$h.des.createEncryptionCipher;
        break;
      default:
        var N = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        throw N.algorithm = a.algorithm, N;
    }
    var U = "hmacWith" + a.prfAlgorithm.toUpperCase(), V = prfAlgorithmToMessageDigest(U), Q = forge$h.pkcs5.pbkdf2(t, n, u, l, V), ie = forge$h.random.getBytesSync(_), ee = $(Q);
    ee.start(ie), ee.update(asn1$6.toDer(e)), ee.finish(), y = ee.output.getBytes();
    var ne = createPbkdf2Params(n, o, l, U);
    h = asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.SEQUENCE,
      !0,
      [
        asn1$6.create(
          asn1$6.Class.UNIVERSAL,
          asn1$6.Type.OID,
          !1,
          asn1$6.oidToDer(oids$1.pkcs5PBES2).getBytes()
        ),
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, !0, [
          // keyDerivationFunc
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, !0, [
            asn1$6.create(
              asn1$6.Class.UNIVERSAL,
              asn1$6.Type.OID,
              !1,
              asn1$6.oidToDer(oids$1.pkcs5PBKDF2).getBytes()
            ),
            // PBKDF2-params
            ne
          ]),
          // encryptionScheme
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, !0, [
            asn1$6.create(
              asn1$6.Class.UNIVERSAL,
              asn1$6.Type.OID,
              !1,
              asn1$6.oidToDer(d).getBytes()
            ),
            // iv
            asn1$6.create(
              asn1$6.Class.UNIVERSAL,
              asn1$6.Type.OCTETSTRING,
              !1,
              ie
            )
          ])
        ])
      ]
    );
  } else if (a.algorithm === "3des") {
    l = 24;
    var ge = new forge$h.util.ByteBuffer(n), Q = pki$3.pbe.generatePkcs12Key(t, ge, 1, u, l), ie = pki$3.pbe.generatePkcs12Key(t, ge, 2, u, l), ee = forge$h.des.createEncryptionCipher(Q);
    ee.start(ie), ee.update(asn1$6.toDer(e)), ee.finish(), y = ee.output.getBytes(), h = asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.SEQUENCE,
      !0,
      [
        asn1$6.create(
          asn1$6.Class.UNIVERSAL,
          asn1$6.Type.OID,
          !1,
          asn1$6.oidToDer(oids$1["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
        ),
        // pkcs-12PbeParams
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, !0, [
          // salt
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OCTETSTRING, !1, n),
          // iteration count
          asn1$6.create(
            asn1$6.Class.UNIVERSAL,
            asn1$6.Type.INTEGER,
            !1,
            o.getBytes()
          )
        ])
      ]
    );
  } else {
    var N = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
    throw N.algorithm = a.algorithm, N;
  }
  var be = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, !0, [
    // encryptionAlgorithm
    h,
    // encryptedData
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.OCTETSTRING,
      !1,
      y
    )
  ]);
  return be;
};
pki$3.decryptPrivateKeyInfo = function(e, t) {
  var a = null, n = {}, u = [];
  if (!asn1$6.validate(e, encryptedPrivateKeyValidator, n, u)) {
    var o = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw o.errors = u, o;
  }
  var l = asn1$6.derToOid(n.encryptionOid), h = pki$3.pbe.getCipher(l, n.encryptionParams, t), y = forge$h.util.createBuffer(n.encryptedData);
  return h.update(y), h.finish() && (a = asn1$6.fromDer(h.output)), a;
};
pki$3.encryptedPrivateKeyToPem = function(e, t) {
  var a = {
    type: "ENCRYPTED PRIVATE KEY",
    body: asn1$6.toDer(e).getBytes()
  };
  return forge$h.pem.encode(a, { maxline: t });
};
pki$3.encryptedPrivateKeyFromPem = function(e) {
  var t = forge$h.pem.decode(e)[0];
  if (t.type !== "ENCRYPTED PRIVATE KEY") {
    var a = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    throw a.headerType = t.type, a;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  return asn1$6.fromDer(t.body);
};
pki$3.encryptRsaPrivateKey = function(e, t, a) {
  if (a = a || {}, !a.legacy) {
    var n = pki$3.wrapRsaPrivateKey(pki$3.privateKeyToAsn1(e));
    return n = pki$3.encryptPrivateKeyInfo(n, t, a), pki$3.encryptedPrivateKeyToPem(n);
  }
  var u, o, l, h;
  switch (a.algorithm) {
    case "aes128":
      u = "AES-128-CBC", l = 16, o = forge$h.random.getBytesSync(16), h = forge$h.aes.createEncryptionCipher;
      break;
    case "aes192":
      u = "AES-192-CBC", l = 24, o = forge$h.random.getBytesSync(16), h = forge$h.aes.createEncryptionCipher;
      break;
    case "aes256":
      u = "AES-256-CBC", l = 32, o = forge$h.random.getBytesSync(16), h = forge$h.aes.createEncryptionCipher;
      break;
    case "3des":
      u = "DES-EDE3-CBC", l = 24, o = forge$h.random.getBytesSync(8), h = forge$h.des.createEncryptionCipher;
      break;
    case "des":
      u = "DES-CBC", l = 8, o = forge$h.random.getBytesSync(8), h = forge$h.des.createEncryptionCipher;
      break;
    default:
      var y = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + a.algorithm + '".');
      throw y.algorithm = a.algorithm, y;
  }
  var _ = forge$h.pbe.opensslDeriveBytes(t, o.substr(0, 8), l), d = h(_);
  d.start(o), d.update(asn1$6.toDer(pki$3.privateKeyToAsn1(e))), d.finish();
  var $ = {
    type: "RSA PRIVATE KEY",
    procType: {
      version: "4",
      type: "ENCRYPTED"
    },
    dekInfo: {
      algorithm: u,
      parameters: forge$h.util.bytesToHex(o).toUpperCase()
    },
    body: d.output.getBytes()
  };
  return forge$h.pem.encode($);
};
pki$3.decryptRsaPrivateKey = function(e, t) {
  var a = null, n = forge$h.pem.decode(e)[0];
  if (n.type !== "ENCRYPTED PRIVATE KEY" && n.type !== "PRIVATE KEY" && n.type !== "RSA PRIVATE KEY") {
    var u = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    throw u.headerType = u, u;
  }
  if (n.procType && n.procType.type === "ENCRYPTED") {
    var o, l;
    switch (n.dekInfo.algorithm) {
      case "DES-CBC":
        o = 8, l = forge$h.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        o = 24, l = forge$h.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        o = 16, l = forge$h.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        o = 24, l = forge$h.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        o = 32, l = forge$h.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        o = 5, l = function($) {
          return forge$h.rc2.createDecryptionCipher($, 40);
        };
        break;
      case "RC2-64-CBC":
        o = 8, l = function($) {
          return forge$h.rc2.createDecryptionCipher($, 64);
        };
        break;
      case "RC2-128-CBC":
        o = 16, l = function($) {
          return forge$h.rc2.createDecryptionCipher($, 128);
        };
        break;
      default:
        var u = new Error('Could not decrypt private key; unsupported encryption algorithm "' + n.dekInfo.algorithm + '".');
        throw u.algorithm = n.dekInfo.algorithm, u;
    }
    var h = forge$h.util.hexToBytes(n.dekInfo.parameters), y = forge$h.pbe.opensslDeriveBytes(t, h.substr(0, 8), o), _ = l(y);
    if (_.start(h), _.update(forge$h.util.createBuffer(n.body)), _.finish())
      a = _.output.getBytes();
    else
      return a;
  } else
    a = n.body;
  return n.type === "ENCRYPTED PRIVATE KEY" ? a = pki$3.decryptPrivateKeyInfo(asn1$6.fromDer(a), t) : a = asn1$6.fromDer(a), a !== null && (a = pki$3.privateKeyFromAsn1(a)), a;
};
pki$3.pbe.generatePkcs12Key = function(e, t, a, n, u, o) {
  var l, h;
  if (typeof o > "u" || o === null) {
    if (!("sha1" in forge$h.md))
      throw new Error('"sha1" hash algorithm unavailable.');
    o = forge$h.md.sha1.create();
  }
  var y = o.digestLength, _ = o.blockLength, d = new forge$h.util.ByteBuffer(), $ = new forge$h.util.ByteBuffer();
  if (e != null) {
    for (h = 0; h < e.length; h++)
      $.putInt16(e.charCodeAt(h));
    $.putInt16(0);
  }
  var N = $.length(), U = t.length(), V = new forge$h.util.ByteBuffer();
  V.fillWithByte(a, _);
  var Q = _ * Math.ceil(U / _), ie = new forge$h.util.ByteBuffer();
  for (h = 0; h < Q; h++)
    ie.putByte(t.at(h % U));
  var ee = _ * Math.ceil(N / _), ne = new forge$h.util.ByteBuffer();
  for (h = 0; h < ee; h++)
    ne.putByte($.at(h % N));
  var ge = ie;
  ge.putBuffer(ne);
  for (var be = Math.ceil(u / y), Ee = 1; Ee <= be; Ee++) {
    var xe = new forge$h.util.ByteBuffer();
    xe.putBytes(V.bytes()), xe.putBytes(ge.bytes());
    for (var Le = 0; Le < n; Le++)
      o.start(), o.update(xe.getBytes()), xe = o.digest();
    var Ne = new forge$h.util.ByteBuffer();
    for (h = 0; h < _; h++)
      Ne.putByte(xe.at(h % y));
    var Re = Math.ceil(U / _) + Math.ceil(N / _), Xe = new forge$h.util.ByteBuffer();
    for (l = 0; l < Re; l++) {
      var pe = new forge$h.util.ByteBuffer(ge.getBytes(_)), O = 511;
      for (h = Ne.length() - 1; h >= 0; h--)
        O = O >> 8, O += Ne.at(h) + pe.at(h), pe.setAt(h, O & 255);
      Xe.putBuffer(pe);
    }
    ge = Xe, d.putBuffer(xe);
  }
  return d.truncate(d.length() - u), d;
};
pki$3.pbe.getCipher = function(e, t, a) {
  switch (e) {
    case pki$3.oids.pkcs5PBES2:
      return pki$3.pbe.getCipherForPBES2(e, t, a);
    case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return pki$3.pbe.getCipherForPKCS12PBE(e, t, a);
    default:
      var n = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      throw n.oid = e, n.supportedOids = [
        "pkcs5PBES2",
        "pbeWithSHAAnd3-KeyTripleDES-CBC",
        "pbewithSHAAnd40BitRC2-CBC"
      ], n;
  }
};
pki$3.pbe.getCipherForPBES2 = function(e, t, a) {
  var n = {}, u = [];
  if (!asn1$6.validate(t, PBES2AlgorithmsValidator, n, u)) {
    var o = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw o.errors = u, o;
  }
  if (e = asn1$6.derToOid(n.kdfOid), e !== pki$3.oids.pkcs5PBKDF2) {
    var o = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
    throw o.oid = e, o.supportedOids = ["pkcs5PBKDF2"], o;
  }
  if (e = asn1$6.derToOid(n.encOid), e !== pki$3.oids["aes128-CBC"] && e !== pki$3.oids["aes192-CBC"] && e !== pki$3.oids["aes256-CBC"] && e !== pki$3.oids["des-EDE3-CBC"] && e !== pki$3.oids.desCBC) {
    var o = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
    throw o.oid = e, o.supportedOids = [
      "aes128-CBC",
      "aes192-CBC",
      "aes256-CBC",
      "des-EDE3-CBC",
      "desCBC"
    ], o;
  }
  var l = n.kdfSalt, h = forge$h.util.createBuffer(n.kdfIterationCount);
  h = h.getInt(h.length() << 3);
  var y, _;
  switch (pki$3.oids[e]) {
    case "aes128-CBC":
      y = 16, _ = forge$h.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      y = 24, _ = forge$h.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      y = 32, _ = forge$h.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      y = 24, _ = forge$h.des.createDecryptionCipher;
      break;
    case "desCBC":
      y = 8, _ = forge$h.des.createDecryptionCipher;
      break;
  }
  var d = prfOidToMessageDigest(n.prfOid), $ = forge$h.pkcs5.pbkdf2(a, l, h, y, d), N = n.encIv, U = _($);
  return U.start(N), U;
};
pki$3.pbe.getCipherForPKCS12PBE = function(e, t, a) {
  var n = {}, u = [];
  if (!asn1$6.validate(t, pkcs12PbeParamsValidator, n, u)) {
    var o = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw o.errors = u, o;
  }
  var l = forge$h.util.createBuffer(n.salt), h = forge$h.util.createBuffer(n.iterations);
  h = h.getInt(h.length() << 3);
  var y, _, d;
  switch (e) {
    case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      y = 24, _ = 8, d = forge$h.des.startDecrypting;
      break;
    case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
      y = 5, _ = 8, d = function(Q, ie) {
        var ee = forge$h.rc2.createDecryptionCipher(Q, 40);
        return ee.start(ie, null), ee;
      };
      break;
    default:
      var o = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
      throw o.oid = e, o;
  }
  var $ = prfOidToMessageDigest(n.prfOid), N = pki$3.pbe.generatePkcs12Key(a, l, 1, h, y, $);
  $.start();
  var U = pki$3.pbe.generatePkcs12Key(a, l, 2, h, _, $);
  return d(N, U);
};
pki$3.pbe.opensslDeriveBytes = function(e, t, a, n) {
  if (typeof n > "u" || n === null) {
    if (!("md5" in forge$h.md))
      throw new Error('"md5" hash algorithm unavailable.');
    n = forge$h.md.md5.create();
  }
  t === null && (t = "");
  for (var u = [hash(n, e + t)], o = 16, l = 1; o < a; ++l, o += 16)
    u.push(hash(n, u[l - 1] + e + t));
  return u.join("").substr(0, a);
};
function hash(e, t) {
  return e.start().update(t).digest().getBytes();
}
function prfOidToMessageDigest(e) {
  var t;
  if (!e)
    t = "hmacWithSHA1";
  else if (t = pki$3.oids[asn1$6.derToOid(e)], !t) {
    var a = new Error("Unsupported PRF OID.");
    throw a.oid = e, a.supported = [
      "hmacWithSHA1",
      "hmacWithSHA224",
      "hmacWithSHA256",
      "hmacWithSHA384",
      "hmacWithSHA512"
    ], a;
  }
  return prfAlgorithmToMessageDigest(t);
}
function prfAlgorithmToMessageDigest(e) {
  var t = forge$h.md;
  switch (e) {
    case "hmacWithSHA224":
      t = forge$h.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      e = e.substr(8).toLowerCase();
      break;
    default:
      var a = new Error("Unsupported PRF algorithm.");
      throw a.algorithm = e, a.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ], a;
  }
  if (!t || !(e in t))
    throw new Error("Unknown hash algorithm: " + e);
  return t[e].create();
}
function createPbkdf2Params(e, t, a, n) {
  var u = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, !0, [
    // salt
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.OCTETSTRING,
      !1,
      e
    ),
    // iteration count
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.INTEGER,
      !1,
      t.getBytes()
    )
  ]);
  return n !== "hmacWithSHA1" && u.value.push(
    // key length
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.INTEGER,
      !1,
      forge$h.util.hexToBytes(a.toString(16))
    ),
    // AlgorithmIdentifier
    asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, !0, [
      // algorithm
      asn1$6.create(
        asn1$6.Class.UNIVERSAL,
        asn1$6.Type.OID,
        !1,
        asn1$6.oidToDer(pki$3.oids[n]).getBytes()
      ),
      // parameters (null)
      asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.NULL, !1, "")
    ])
  ), u;
}
var forge$g = forge$D, asn1$5 = forge$g.asn1, p7v = forge$g.pkcs7asn1 = forge$g.pkcs7asn1 || {};
forge$g.pkcs7 = forge$g.pkcs7 || {};
forge$g.pkcs7.asn1 = p7v;
var contentInfoValidator$1 = {
  name: "ContentInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "ContentInfo.ContentType",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OID,
    constructed: !1,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: !0,
    optional: !0,
    captureAsn1: "content"
  }]
};
p7v.contentInfoValidator = contentInfoValidator$1;
var encryptedContentInfoValidator = {
  name: "EncryptedContentInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedContentInfo.contentType",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OID,
    constructed: !1,
    capture: "contentType"
  }, {
    name: "EncryptedContentInfo.contentEncryptionAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.OID,
      constructed: !1,
      capture: "encAlgorithm"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
      tagClass: asn1$5.Class.UNIVERSAL,
      captureAsn1: "encParameter"
    }]
  }, {
    name: "EncryptedContentInfo.encryptedContent",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 0,
    /* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */
    capture: "encryptedContent",
    captureAsn1: "encryptedContentAsn1"
  }]
};
p7v.envelopedDataValidator = {
  name: "EnvelopedData",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EnvelopedData.Version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: !1,
    capture: "version"
  }, {
    name: "EnvelopedData.RecipientInfos",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SET,
    constructed: !0,
    captureAsn1: "recipientInfos"
  }].concat(encryptedContentInfoValidator)
};
p7v.encryptedDataValidator = {
  name: "EncryptedData",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedData.Version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: !1,
    capture: "version"
  }].concat(encryptedContentInfoValidator)
};
var signerValidator = {
  name: "SignerInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "SignerInfo.version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: !1
  }, {
    name: "SignerInfo.issuerAndSerialNumber",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SignerInfo.issuerAndSerialNumber.issuer",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "issuer"
    }, {
      name: "SignerInfo.issuerAndSerialNumber.serialNumber",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.INTEGER,
      constructed: !1,
      capture: "serial"
    }]
  }, {
    name: "SignerInfo.digestAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SignerInfo.digestAlgorithm.algorithm",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.OID,
      constructed: !1,
      capture: "digestAlgorithm"
    }, {
      name: "SignerInfo.digestAlgorithm.parameter",
      tagClass: asn1$5.Class.UNIVERSAL,
      constructed: !1,
      captureAsn1: "digestParameter",
      optional: !0
    }]
  }, {
    name: "SignerInfo.authenticatedAttributes",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: !0,
    optional: !0,
    capture: "authenticatedAttributes"
  }, {
    name: "SignerInfo.digestEncryptionAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: !0,
    capture: "signatureAlgorithm"
  }, {
    name: "SignerInfo.encryptedDigest",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OCTETSTRING,
    constructed: !1,
    capture: "signature"
  }, {
    name: "SignerInfo.unauthenticatedAttributes",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: !0,
    optional: !0,
    capture: "unauthenticatedAttributes"
  }]
};
p7v.signedDataValidator = {
  name: "SignedData",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: !0,
  value: [
    {
      name: "SignedData.Version",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.INTEGER,
      constructed: !1,
      capture: "version"
    },
    {
      name: "SignedData.DigestAlgorithms",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SET,
      constructed: !0,
      captureAsn1: "digestAlgorithms"
    },
    contentInfoValidator$1,
    {
      name: "SignedData.Certificates",
      tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
      type: 0,
      optional: !0,
      captureAsn1: "certificates"
    },
    {
      name: "SignedData.CertificateRevocationLists",
      tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
      type: 1,
      optional: !0,
      captureAsn1: "crls"
    },
    {
      name: "SignedData.SignerInfos",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SET,
      capture: "signerInfos",
      optional: !0,
      value: [signerValidator]
    }
  ]
};
p7v.recipientInfoValidator = {
  name: "RecipientInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "RecipientInfo.version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: !1,
    capture: "version"
  }, {
    name: "RecipientInfo.issuerAndSerial",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "RecipientInfo.issuerAndSerial.issuer",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "issuer"
    }, {
      name: "RecipientInfo.issuerAndSerial.serialNumber",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.INTEGER,
      constructed: !1,
      capture: "serial"
    }]
  }, {
    name: "RecipientInfo.keyEncryptionAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.OID,
      constructed: !1,
      capture: "encAlgorithm"
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
      tagClass: asn1$5.Class.UNIVERSAL,
      constructed: !1,
      captureAsn1: "encParameter",
      optional: !0
    }]
  }, {
    name: "RecipientInfo.encryptedKey",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OCTETSTRING,
    constructed: !1,
    capture: "encKey"
  }]
};
var forge$f = forge$D;
forge$f.mgf = forge$f.mgf || {};
var mgf1 = forge$f.mgf.mgf1 = forge$f.mgf1 = forge$f.mgf1 || {};
mgf1.create = function(e) {
  var t = {
    /**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */
    generate: function(a, n) {
      for (var u = new forge$f.util.ByteBuffer(), o = Math.ceil(n / e.digestLength), l = 0; l < o; l++) {
        var h = new forge$f.util.ByteBuffer();
        h.putInt32(l), e.start(), e.update(a + h.getBytes()), u.putBuffer(e.digest());
      }
      return u.truncate(u.length() - n), u.getBytes();
    }
  };
  return t;
};
var forge$e = forge$D;
forge$e.mgf = forge$e.mgf || {};
forge$e.mgf.mgf1 = forge$e.mgf1;
var forge$d = forge$D, pss = forge$d.pss = forge$d.pss || {};
pss.create = function(e) {
  arguments.length === 3 && (e = {
    md: arguments[0],
    mgf: arguments[1],
    saltLength: arguments[2]
  });
  var t = e.md, a = e.mgf, n = t.digestLength, u = e.salt || null;
  typeof u == "string" && (u = forge$d.util.createBuffer(u));
  var o;
  if ("saltLength" in e)
    o = e.saltLength;
  else if (u !== null)
    o = u.length();
  else
    throw new Error("Salt length not specified or specific salt not given.");
  if (u !== null && u.length() !== o)
    throw new Error("Given salt length does not match length of given salt.");
  var l = e.prng || forge$d.random, h = {};
  return h.encode = function(y, _) {
    var d, $ = _ - 1, N = Math.ceil($ / 8), U = y.digest().getBytes();
    if (N < n + o + 2)
      throw new Error("Message is too long to encrypt.");
    var V;
    u === null ? V = l.getBytesSync(o) : V = u.bytes();
    var Q = new forge$d.util.ByteBuffer();
    Q.fillWithByte(0, 8), Q.putBytes(U), Q.putBytes(V), t.start(), t.update(Q.getBytes());
    var ie = t.digest().getBytes(), ee = new forge$d.util.ByteBuffer();
    ee.fillWithByte(0, N - o - n - 2), ee.putByte(1), ee.putBytes(V);
    var ne = ee.getBytes(), ge = N - n - 1, be = a.generate(ie, ge), Ee = "";
    for (d = 0; d < ge; d++)
      Ee += String.fromCharCode(ne.charCodeAt(d) ^ be.charCodeAt(d));
    var xe = 65280 >> 8 * N - $ & 255;
    return Ee = String.fromCharCode(Ee.charCodeAt(0) & ~xe) + Ee.substr(1), Ee + ie + String.fromCharCode(188);
  }, h.verify = function(y, _, d) {
    var $, N = d - 1, U = Math.ceil(N / 8);
    if (_ = _.substr(-U), U < n + o + 2)
      throw new Error("Inconsistent parameters to PSS signature verification.");
    if (_.charCodeAt(U - 1) !== 188)
      throw new Error("Encoded message does not end in 0xBC.");
    var V = U - n - 1, Q = _.substr(0, V), ie = _.substr(V, n), ee = 65280 >> 8 * U - N & 255;
    if (Q.charCodeAt(0) & ee)
      throw new Error("Bits beyond keysize not zero as expected.");
    var ne = a.generate(ie, V), ge = "";
    for ($ = 0; $ < V; $++)
      ge += String.fromCharCode(Q.charCodeAt($) ^ ne.charCodeAt($));
    ge = String.fromCharCode(ge.charCodeAt(0) & ~ee) + ge.substr(1);
    var be = U - n - o - 2;
    for ($ = 0; $ < be; $++)
      if (ge.charCodeAt($) !== 0)
        throw new Error("Leftmost octets not zero as expected");
    if (ge.charCodeAt(be) !== 1)
      throw new Error("Inconsistent PSS signature, 0x01 marker not found");
    var Ee = ge.substr(-o), xe = new forge$d.util.ByteBuffer();
    xe.fillWithByte(0, 8), xe.putBytes(y), xe.putBytes(Ee), t.start(), t.update(xe.getBytes());
    var Le = t.digest().getBytes();
    return ie === Le;
  }, h;
};
var forge$c = forge$D, asn1$4 = forge$c.asn1, pki$2 = forge$c.pki = forge$c.pki || {}, oids = pki$2.oids, _shortNames = {};
_shortNames.CN = oids.commonName;
_shortNames.commonName = "CN";
_shortNames.C = oids.countryName;
_shortNames.countryName = "C";
_shortNames.L = oids.localityName;
_shortNames.localityName = "L";
_shortNames.ST = oids.stateOrProvinceName;
_shortNames.stateOrProvinceName = "ST";
_shortNames.O = oids.organizationName;
_shortNames.organizationName = "O";
_shortNames.OU = oids.organizationalUnitName;
_shortNames.organizationalUnitName = "OU";
_shortNames.E = oids.emailAddress;
_shortNames.emailAddress = "E";
var publicKeyValidator$1 = forge$c.pki.rsa.publicKeyValidator, x509CertificateValidator = {
  name: "Certificate",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "Certificate.TBSCertificate",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: !0,
    captureAsn1: "tbsCertificate",
    value: [
      {
        name: "Certificate.TBSCertificate.version",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        value: [{
          name: "Certificate.TBSCertificate.version.integer",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.INTEGER,
          constructed: !1,
          capture: "certVersion"
        }]
      },
      {
        name: "Certificate.TBSCertificate.serialNumber",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.INTEGER,
        constructed: !1,
        capture: "certSerialNumber"
      },
      {
        name: "Certificate.TBSCertificate.signature",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "Certificate.TBSCertificate.signature.algorithm",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: !1,
          capture: "certinfoSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1$4.Class.UNIVERSAL,
          optional: !0,
          captureAsn1: "certinfoSignatureParams"
        }]
      },
      {
        name: "Certificate.TBSCertificate.issuer",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certIssuer"
      },
      {
        name: "Certificate.TBSCertificate.validity",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: !0,
        // Note: UTC and generalized times may both appear so the capture
        // names are based on their detected order, the names used below
        // are only for the common case, which validity time really means
        // "notBefore" and which means "notAfter" will be determined by order
        value: [{
          // notBefore (Time) (UTC time case)
          name: "Certificate.TBSCertificate.validity.notBefore (utc)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.UTCTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity1UTCTime"
        }, {
          // notBefore (Time) (generalized time case)
          name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.GENERALIZEDTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity2GeneralizedTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (utc)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.UTCTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity3UTCTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.GENERALIZEDTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity4GeneralizedTime"
        }]
      },
      {
        // Name (subject) (RDNSequence)
        name: "Certificate.TBSCertificate.subject",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certSubject"
      },
      // SubjectPublicKeyInfo
      publicKeyValidator$1,
      {
        // issuerUniqueID (optional)
        name: "Certificate.TBSCertificate.issuerUniqueID",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: !0,
        optional: !0,
        value: [{
          name: "Certificate.TBSCertificate.issuerUniqueID.id",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.BITSTRING,
          constructed: !1,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certIssuerUniqueId"
        }]
      },
      {
        // subjectUniqueID (optional)
        name: "Certificate.TBSCertificate.subjectUniqueID",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 2,
        constructed: !0,
        optional: !0,
        value: [{
          name: "Certificate.TBSCertificate.subjectUniqueID.id",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.BITSTRING,
          constructed: !1,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certSubjectUniqueId"
        }]
      },
      {
        // Extensions (optional)
        name: "Certificate.TBSCertificate.extensions",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 3,
        constructed: !0,
        captureAsn1: "certExtensions",
        optional: !0
      }
    ]
  }, {
    // AlgorithmIdentifier (signature algorithm)
    name: "Certificate.signatureAlgorithm",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: !0,
    value: [{
      // algorithm
      name: "Certificate.signatureAlgorithm.algorithm",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.OID,
      constructed: !1,
      capture: "certSignatureOid"
    }, {
      name: "Certificate.TBSCertificate.signature.parameters",
      tagClass: asn1$4.Class.UNIVERSAL,
      optional: !0,
      captureAsn1: "certSignatureParams"
    }]
  }, {
    // SignatureValue
    name: "Certificate.signatureValue",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.BITSTRING,
    constructed: !1,
    captureBitStringValue: "certSignature"
  }]
}, rsassaPssParameterValidator = {
  name: "rsapss",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "rsapss.hashAlgorithm",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: !0,
    value: [{
      name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.SEQUENCE,
      constructed: !0,
      optional: !0,
      value: [{
        name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OID,
        constructed: !1,
        capture: "hashOid"
        /* parameter block omitted, for SHA1 NULL anyhow. */
      }]
    }]
  }, {
    name: "rsapss.maskGenAlgorithm",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: !0,
    value: [{
      name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.SEQUENCE,
      constructed: !0,
      optional: !0,
      value: [{
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OID,
        constructed: !1,
        capture: "maskGenOid"
      }, {
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: !1,
          capture: "maskGenHashOid"
          /* parameter block omitted, for SHA1 NULL anyhow. */
        }]
      }]
    }]
  }, {
    name: "rsapss.saltLength",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: !0,
    value: [{
      name: "rsapss.saltLength.saltLength",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.INTEGER,
      constructed: !1,
      capture: "saltLength"
    }]
  }, {
    name: "rsapss.trailerField",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: !0,
    value: [{
      name: "rsapss.trailer.trailer",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.INTEGER,
      constructed: !1,
      capture: "trailer"
    }]
  }]
}, certificationRequestInfoValidator = {
  name: "CertificationRequestInfo",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "certificationRequestInfo",
  value: [
    {
      name: "CertificationRequestInfo.integer",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.INTEGER,
      constructed: !1,
      capture: "certificationRequestInfoVersion"
    },
    {
      // Name (subject) (RDNSequence)
      name: "CertificationRequestInfo.subject",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "certificationRequestInfoSubject"
    },
    // SubjectPublicKeyInfo
    publicKeyValidator$1,
    {
      name: "CertificationRequestInfo.attributes",
      tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: !0,
      optional: !0,
      capture: "certificationRequestInfoAttributes",
      value: [{
        name: "CertificationRequestInfo.attributes",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "CertificationRequestInfo.attributes.type",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: !1
        }, {
          name: "CertificationRequestInfo.attributes.value",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.SET,
          constructed: !0
        }]
      }]
    }
  ]
}, certificationRequestValidator = {
  name: "CertificationRequest",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "csr",
  value: [
    certificationRequestInfoValidator,
    {
      // AlgorithmIdentifier (signature algorithm)
      name: "CertificationRequest.signatureAlgorithm",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: !0,
      value: [{
        // algorithm
        name: "CertificationRequest.signatureAlgorithm.algorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OID,
        constructed: !1,
        capture: "csrSignatureOid"
      }, {
        name: "CertificationRequest.signatureAlgorithm.parameters",
        tagClass: asn1$4.Class.UNIVERSAL,
        optional: !0,
        captureAsn1: "csrSignatureParams"
      }]
    },
    {
      // signature
      name: "CertificationRequest.signature",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.BITSTRING,
      constructed: !1,
      captureBitStringValue: "csrSignature"
    }
  ]
};
pki$2.RDNAttributesAsArray = function(e, t) {
  for (var a = [], n, u, o, l = 0; l < e.value.length; ++l) {
    n = e.value[l];
    for (var h = 0; h < n.value.length; ++h)
      o = {}, u = n.value[h], o.type = asn1$4.derToOid(u.value[0].value), o.value = u.value[1].value, o.valueTagClass = u.value[1].type, o.type in oids && (o.name = oids[o.type], o.name in _shortNames && (o.shortName = _shortNames[o.name])), t && (t.update(o.type), t.update(o.value)), a.push(o);
  }
  return a;
};
pki$2.CRIAttributesAsArray = function(e) {
  for (var t = [], a = 0; a < e.length; ++a)
    for (var n = e[a], u = asn1$4.derToOid(n.value[0].value), o = n.value[1].value, l = 0; l < o.length; ++l) {
      var h = {};
      if (h.type = u, h.value = o[l].value, h.valueTagClass = o[l].type, h.type in oids && (h.name = oids[h.type], h.name in _shortNames && (h.shortName = _shortNames[h.name])), h.type === oids.extensionRequest) {
        h.extensions = [];
        for (var y = 0; y < h.value.length; ++y)
          h.extensions.push(pki$2.certificateExtensionFromAsn1(h.value[y]));
      }
      t.push(h);
    }
  return t;
};
function _getAttribute(e, t) {
  typeof t == "string" && (t = { shortName: t });
  for (var a = null, n, u = 0; a === null && u < e.attributes.length; ++u)
    n = e.attributes[u], (t.type && t.type === n.type || t.name && t.name === n.name || t.shortName && t.shortName === n.shortName) && (a = n);
  return a;
}
var _readSignatureParameters = function(e, t, a) {
  var n = {};
  if (e !== oids["RSASSA-PSS"])
    return n;
  a && (n = {
    hash: {
      algorithmOid: oids.sha1
    },
    mgf: {
      algorithmOid: oids.mgf1,
      hash: {
        algorithmOid: oids.sha1
      }
    },
    saltLength: 20
  });
  var u = {}, o = [];
  if (!asn1$4.validate(t, rsassaPssParameterValidator, u, o)) {
    var l = new Error("Cannot read RSASSA-PSS parameter block.");
    throw l.errors = o, l;
  }
  return u.hashOid !== void 0 && (n.hash = n.hash || {}, n.hash.algorithmOid = asn1$4.derToOid(u.hashOid)), u.maskGenOid !== void 0 && (n.mgf = n.mgf || {}, n.mgf.algorithmOid = asn1$4.derToOid(u.maskGenOid), n.mgf.hash = n.mgf.hash || {}, n.mgf.hash.algorithmOid = asn1$4.derToOid(u.maskGenHashOid)), u.saltLength !== void 0 && (n.saltLength = u.saltLength.charCodeAt(0)), n;
}, _createSignatureDigest = function(e) {
  switch (oids[e.signatureOid]) {
    case "sha1WithRSAEncryption":
    case "sha1WithRSASignature":
      return forge$c.md.sha1.create();
    case "md5WithRSAEncryption":
      return forge$c.md.md5.create();
    case "sha256WithRSAEncryption":
      return forge$c.md.sha256.create();
    case "sha384WithRSAEncryption":
      return forge$c.md.sha384.create();
    case "sha512WithRSAEncryption":
      return forge$c.md.sha512.create();
    case "RSASSA-PSS":
      return forge$c.md.sha256.create();
    default:
      var t = new Error(
        "Could not compute " + e.type + " digest. Unknown signature OID."
      );
      throw t.signatureOid = e.signatureOid, t;
  }
}, _verifySignature = function(e) {
  var t = e.certificate, a;
  switch (t.signatureOid) {
    case oids.sha1WithRSAEncryption:
    case oids.sha1WithRSASignature:
      break;
    case oids["RSASSA-PSS"]:
      var n, u;
      if (n = oids[t.signatureParameters.mgf.hash.algorithmOid], n === void 0 || forge$c.md[n] === void 0) {
        var o = new Error("Unsupported MGF hash function.");
        throw o.oid = t.signatureParameters.mgf.hash.algorithmOid, o.name = n, o;
      }
      if (u = oids[t.signatureParameters.mgf.algorithmOid], u === void 0 || forge$c.mgf[u] === void 0) {
        var o = new Error("Unsupported MGF function.");
        throw o.oid = t.signatureParameters.mgf.algorithmOid, o.name = u, o;
      }
      if (u = forge$c.mgf[u].create(forge$c.md[n].create()), n = oids[t.signatureParameters.hash.algorithmOid], n === void 0 || forge$c.md[n] === void 0) {
        var o = new Error("Unsupported RSASSA-PSS hash function.");
        throw o.oid = t.signatureParameters.hash.algorithmOid, o.name = n, o;
      }
      a = forge$c.pss.create(
        forge$c.md[n].create(),
        u,
        t.signatureParameters.saltLength
      );
      break;
  }
  return t.publicKey.verify(
    e.md.digest().getBytes(),
    e.signature,
    a
  );
};
pki$2.certificateFromPem = function(e, t, a) {
  var n = forge$c.pem.decode(e)[0];
  if (n.type !== "CERTIFICATE" && n.type !== "X509 CERTIFICATE" && n.type !== "TRUSTED CERTIFICATE") {
    var u = new Error(
      'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
    );
    throw u.headerType = n.type, u;
  }
  if (n.procType && n.procType.type === "ENCRYPTED")
    throw new Error(
      "Could not convert certificate from PEM; PEM is encrypted."
    );
  var o = asn1$4.fromDer(n.body, a);
  return pki$2.certificateFromAsn1(o, t);
};
pki$2.certificateToPem = function(e, t) {
  var a = {
    type: "CERTIFICATE",
    body: asn1$4.toDer(pki$2.certificateToAsn1(e)).getBytes()
  };
  return forge$c.pem.encode(a, { maxline: t });
};
pki$2.publicKeyFromPem = function(e) {
  var t = forge$c.pem.decode(e)[0];
  if (t.type !== "PUBLIC KEY" && t.type !== "RSA PUBLIC KEY") {
    var a = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    throw a.headerType = t.type, a;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert public key from PEM; PEM is encrypted.");
  var n = asn1$4.fromDer(t.body);
  return pki$2.publicKeyFromAsn1(n);
};
pki$2.publicKeyToPem = function(e, t) {
  var a = {
    type: "PUBLIC KEY",
    body: asn1$4.toDer(pki$2.publicKeyToAsn1(e)).getBytes()
  };
  return forge$c.pem.encode(a, { maxline: t });
};
pki$2.publicKeyToRSAPublicKeyPem = function(e, t) {
  var a = {
    type: "RSA PUBLIC KEY",
    body: asn1$4.toDer(pki$2.publicKeyToRSAPublicKey(e)).getBytes()
  };
  return forge$c.pem.encode(a, { maxline: t });
};
pki$2.getPublicKeyFingerprint = function(e, t) {
  t = t || {};
  var a = t.md || forge$c.md.sha1.create(), n = t.type || "RSAPublicKey", u;
  switch (n) {
    case "RSAPublicKey":
      u = asn1$4.toDer(pki$2.publicKeyToRSAPublicKey(e)).getBytes();
      break;
    case "SubjectPublicKeyInfo":
      u = asn1$4.toDer(pki$2.publicKeyToAsn1(e)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + t.type + '".');
  }
  a.start(), a.update(u);
  var o = a.digest();
  if (t.encoding === "hex") {
    var l = o.toHex();
    return t.delimiter ? l.match(/.{2}/g).join(t.delimiter) : l;
  } else {
    if (t.encoding === "binary")
      return o.getBytes();
    if (t.encoding)
      throw new Error('Unknown encoding "' + t.encoding + '".');
  }
  return o;
};
pki$2.certificationRequestFromPem = function(e, t, a) {
  var n = forge$c.pem.decode(e)[0];
  if (n.type !== "CERTIFICATE REQUEST") {
    var u = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
    throw u.headerType = n.type, u;
  }
  if (n.procType && n.procType.type === "ENCRYPTED")
    throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
  var o = asn1$4.fromDer(n.body, a);
  return pki$2.certificationRequestFromAsn1(o, t);
};
pki$2.certificationRequestToPem = function(e, t) {
  var a = {
    type: "CERTIFICATE REQUEST",
    body: asn1$4.toDer(pki$2.certificationRequestToAsn1(e)).getBytes()
  };
  return forge$c.pem.encode(a, { maxline: t });
};
pki$2.createCertificate = function() {
  var e = {};
  return e.version = 2, e.serialNumber = "00", e.signatureOid = null, e.signature = null, e.siginfo = {}, e.siginfo.algorithmOid = null, e.validity = {}, e.validity.notBefore = /* @__PURE__ */ new Date(), e.validity.notAfter = /* @__PURE__ */ new Date(), e.issuer = {}, e.issuer.getField = function(t) {
    return _getAttribute(e.issuer, t);
  }, e.issuer.addField = function(t) {
    _fillMissingFields([t]), e.issuer.attributes.push(t);
  }, e.issuer.attributes = [], e.issuer.hash = null, e.subject = {}, e.subject.getField = function(t) {
    return _getAttribute(e.subject, t);
  }, e.subject.addField = function(t) {
    _fillMissingFields([t]), e.subject.attributes.push(t);
  }, e.subject.attributes = [], e.subject.hash = null, e.extensions = [], e.publicKey = null, e.md = null, e.setSubject = function(t, a) {
    _fillMissingFields(t), e.subject.attributes = t, delete e.subject.uniqueId, a && (e.subject.uniqueId = a), e.subject.hash = null;
  }, e.setIssuer = function(t, a) {
    _fillMissingFields(t), e.issuer.attributes = t, delete e.issuer.uniqueId, a && (e.issuer.uniqueId = a), e.issuer.hash = null;
  }, e.setExtensions = function(t) {
    for (var a = 0; a < t.length; ++a)
      _fillMissingExtensionFields(t[a], { cert: e });
    e.extensions = t;
  }, e.getExtension = function(t) {
    typeof t == "string" && (t = { name: t });
    for (var a = null, n, u = 0; a === null && u < e.extensions.length; ++u)
      n = e.extensions[u], (t.id && n.id === t.id || t.name && n.name === t.name) && (a = n);
    return a;
  }, e.sign = function(t, a) {
    e.md = a || forge$c.md.sha1.create();
    var n = oids[e.md.algorithm + "WithRSAEncryption"];
    if (!n) {
      var u = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
      throw u.algorithm = e.md.algorithm, u;
    }
    e.signatureOid = e.siginfo.algorithmOid = n, e.tbsCertificate = pki$2.getTBSCertificate(e);
    var o = asn1$4.toDer(e.tbsCertificate);
    e.md.update(o.getBytes()), e.signature = t.sign(e.md);
  }, e.verify = function(t) {
    var a = !1;
    if (!e.issued(t)) {
      var n = t.issuer, u = e.subject, o = new Error(
        "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
      );
      throw o.expectedIssuer = u.attributes, o.actualIssuer = n.attributes, o;
    }
    var l = t.md;
    if (l === null) {
      l = _createSignatureDigest({
        signatureOid: t.signatureOid,
        type: "certificate"
      });
      var h = t.tbsCertificate || pki$2.getTBSCertificate(t), y = asn1$4.toDer(h);
      l.update(y.getBytes());
    }
    return l !== null && (a = _verifySignature({
      certificate: e,
      md: l,
      signature: t.signature
    })), a;
  }, e.isIssuer = function(t) {
    var a = !1, n = e.issuer, u = t.subject;
    if (n.hash && u.hash)
      a = n.hash === u.hash;
    else if (n.attributes.length === u.attributes.length) {
      a = !0;
      for (var o, l, h = 0; a && h < n.attributes.length; ++h)
        o = n.attributes[h], l = u.attributes[h], (o.type !== l.type || o.value !== l.value) && (a = !1);
    }
    return a;
  }, e.issued = function(t) {
    return t.isIssuer(e);
  }, e.generateSubjectKeyIdentifier = function() {
    return pki$2.getPublicKeyFingerprint(e.publicKey, { type: "RSAPublicKey" });
  }, e.verifySubjectKeyIdentifier = function() {
    for (var t = oids.subjectKeyIdentifier, a = 0; a < e.extensions.length; ++a) {
      var n = e.extensions[a];
      if (n.id === t) {
        var u = e.generateSubjectKeyIdentifier().getBytes();
        return forge$c.util.hexToBytes(n.subjectKeyIdentifier) === u;
      }
    }
    return !1;
  }, e;
};
pki$2.certificateFromAsn1 = function(e, t) {
  var a = {}, n = [];
  if (!asn1$4.validate(e, x509CertificateValidator, a, n)) {
    var u = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
    throw u.errors = n, u;
  }
  var o = asn1$4.derToOid(a.publicKeyOid);
  if (o !== pki$2.oids.rsaEncryption)
    throw new Error("Cannot read public key. OID is not RSA.");
  var l = pki$2.createCertificate();
  l.version = a.certVersion ? a.certVersion.charCodeAt(0) : 0;
  var h = forge$c.util.createBuffer(a.certSerialNumber);
  l.serialNumber = h.toHex(), l.signatureOid = forge$c.asn1.derToOid(a.certSignatureOid), l.signatureParameters = _readSignatureParameters(
    l.signatureOid,
    a.certSignatureParams,
    !0
  ), l.siginfo.algorithmOid = forge$c.asn1.derToOid(a.certinfoSignatureOid), l.siginfo.parameters = _readSignatureParameters(
    l.siginfo.algorithmOid,
    a.certinfoSignatureParams,
    !1
  ), l.signature = a.certSignature;
  var y = [];
  if (a.certValidity1UTCTime !== void 0 && y.push(asn1$4.utcTimeToDate(a.certValidity1UTCTime)), a.certValidity2GeneralizedTime !== void 0 && y.push(asn1$4.generalizedTimeToDate(
    a.certValidity2GeneralizedTime
  )), a.certValidity3UTCTime !== void 0 && y.push(asn1$4.utcTimeToDate(a.certValidity3UTCTime)), a.certValidity4GeneralizedTime !== void 0 && y.push(asn1$4.generalizedTimeToDate(
    a.certValidity4GeneralizedTime
  )), y.length > 2)
    throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
  if (y.length < 2)
    throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
  if (l.validity.notBefore = y[0], l.validity.notAfter = y[1], l.tbsCertificate = a.tbsCertificate, t) {
    l.md = _createSignatureDigest({
      signatureOid: l.signatureOid,
      type: "certificate"
    });
    var _ = asn1$4.toDer(l.tbsCertificate);
    l.md.update(_.getBytes());
  }
  var d = forge$c.md.sha1.create(), $ = asn1$4.toDer(a.certIssuer);
  d.update($.getBytes()), l.issuer.getField = function(V) {
    return _getAttribute(l.issuer, V);
  }, l.issuer.addField = function(V) {
    _fillMissingFields([V]), l.issuer.attributes.push(V);
  }, l.issuer.attributes = pki$2.RDNAttributesAsArray(a.certIssuer), a.certIssuerUniqueId && (l.issuer.uniqueId = a.certIssuerUniqueId), l.issuer.hash = d.digest().toHex();
  var N = forge$c.md.sha1.create(), U = asn1$4.toDer(a.certSubject);
  return N.update(U.getBytes()), l.subject.getField = function(V) {
    return _getAttribute(l.subject, V);
  }, l.subject.addField = function(V) {
    _fillMissingFields([V]), l.subject.attributes.push(V);
  }, l.subject.attributes = pki$2.RDNAttributesAsArray(a.certSubject), a.certSubjectUniqueId && (l.subject.uniqueId = a.certSubjectUniqueId), l.subject.hash = N.digest().toHex(), a.certExtensions ? l.extensions = pki$2.certificateExtensionsFromAsn1(a.certExtensions) : l.extensions = [], l.publicKey = pki$2.publicKeyFromAsn1(a.subjectPublicKeyInfo), l;
};
pki$2.certificateExtensionsFromAsn1 = function(e) {
  for (var t = [], a = 0; a < e.value.length; ++a)
    for (var n = e.value[a], u = 0; u < n.value.length; ++u)
      t.push(pki$2.certificateExtensionFromAsn1(n.value[u]));
  return t;
};
pki$2.certificateExtensionFromAsn1 = function(e) {
  var t = {};
  if (t.id = asn1$4.derToOid(e.value[0].value), t.critical = !1, e.value[1].type === asn1$4.Type.BOOLEAN ? (t.critical = e.value[1].value.charCodeAt(0) !== 0, t.value = e.value[2].value) : t.value = e.value[1].value, t.id in oids) {
    if (t.name = oids[t.id], t.name === "keyUsage") {
      var a = asn1$4.fromDer(t.value), n = 0, u = 0;
      a.value.length > 1 && (n = a.value.charCodeAt(1), u = a.value.length > 2 ? a.value.charCodeAt(2) : 0), t.digitalSignature = (n & 128) === 128, t.nonRepudiation = (n & 64) === 64, t.keyEncipherment = (n & 32) === 32, t.dataEncipherment = (n & 16) === 16, t.keyAgreement = (n & 8) === 8, t.keyCertSign = (n & 4) === 4, t.cRLSign = (n & 2) === 2, t.encipherOnly = (n & 1) === 1, t.decipherOnly = (u & 128) === 128;
    } else if (t.name === "basicConstraints") {
      var a = asn1$4.fromDer(t.value);
      a.value.length > 0 && a.value[0].type === asn1$4.Type.BOOLEAN ? t.cA = a.value[0].value.charCodeAt(0) !== 0 : t.cA = !1;
      var o = null;
      a.value.length > 0 && a.value[0].type === asn1$4.Type.INTEGER ? o = a.value[0].value : a.value.length > 1 && (o = a.value[1].value), o !== null && (t.pathLenConstraint = asn1$4.derToInteger(o));
    } else if (t.name === "extKeyUsage")
      for (var a = asn1$4.fromDer(t.value), l = 0; l < a.value.length; ++l) {
        var h = asn1$4.derToOid(a.value[l].value);
        h in oids ? t[oids[h]] = !0 : t[h] = !0;
      }
    else if (t.name === "nsCertType") {
      var a = asn1$4.fromDer(t.value), n = 0;
      a.value.length > 1 && (n = a.value.charCodeAt(1)), t.client = (n & 128) === 128, t.server = (n & 64) === 64, t.email = (n & 32) === 32, t.objsign = (n & 16) === 16, t.reserved = (n & 8) === 8, t.sslCA = (n & 4) === 4, t.emailCA = (n & 2) === 2, t.objCA = (n & 1) === 1;
    } else if (t.name === "subjectAltName" || t.name === "issuerAltName") {
      t.altNames = [];
      for (var y, a = asn1$4.fromDer(t.value), _ = 0; _ < a.value.length; ++_) {
        y = a.value[_];
        var d = {
          type: y.type,
          value: y.value
        };
        switch (t.altNames.push(d), y.type) {
          case 1:
          case 2:
          case 6:
            break;
          case 7:
            d.ip = forge$c.util.bytesToIP(y.value);
            break;
          case 8:
            d.oid = asn1$4.derToOid(y.value);
            break;
        }
      }
    } else if (t.name === "subjectKeyIdentifier") {
      var a = asn1$4.fromDer(t.value);
      t.subjectKeyIdentifier = forge$c.util.bytesToHex(a.value);
    }
  }
  return t;
};
pki$2.certificationRequestFromAsn1 = function(e, t) {
  var a = {}, n = [];
  if (!asn1$4.validate(e, certificationRequestValidator, a, n)) {
    var u = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
    throw u.errors = n, u;
  }
  var o = asn1$4.derToOid(a.publicKeyOid);
  if (o !== pki$2.oids.rsaEncryption)
    throw new Error("Cannot read public key. OID is not RSA.");
  var l = pki$2.createCertificationRequest();
  if (l.version = a.csrVersion ? a.csrVersion.charCodeAt(0) : 0, l.signatureOid = forge$c.asn1.derToOid(a.csrSignatureOid), l.signatureParameters = _readSignatureParameters(
    l.signatureOid,
    a.csrSignatureParams,
    !0
  ), l.siginfo.algorithmOid = forge$c.asn1.derToOid(a.csrSignatureOid), l.siginfo.parameters = _readSignatureParameters(
    l.siginfo.algorithmOid,
    a.csrSignatureParams,
    !1
  ), l.signature = a.csrSignature, l.certificationRequestInfo = a.certificationRequestInfo, t) {
    l.md = _createSignatureDigest({
      signatureOid: l.signatureOid,
      type: "certification request"
    });
    var h = asn1$4.toDer(l.certificationRequestInfo);
    l.md.update(h.getBytes());
  }
  var y = forge$c.md.sha1.create();
  return l.subject.getField = function(_) {
    return _getAttribute(l.subject, _);
  }, l.subject.addField = function(_) {
    _fillMissingFields([_]), l.subject.attributes.push(_);
  }, l.subject.attributes = pki$2.RDNAttributesAsArray(
    a.certificationRequestInfoSubject,
    y
  ), l.subject.hash = y.digest().toHex(), l.publicKey = pki$2.publicKeyFromAsn1(a.subjectPublicKeyInfo), l.getAttribute = function(_) {
    return _getAttribute(l, _);
  }, l.addAttribute = function(_) {
    _fillMissingFields([_]), l.attributes.push(_);
  }, l.attributes = pki$2.CRIAttributesAsArray(
    a.certificationRequestInfoAttributes || []
  ), l;
};
pki$2.createCertificationRequest = function() {
  var e = {};
  return e.version = 0, e.signatureOid = null, e.signature = null, e.siginfo = {}, e.siginfo.algorithmOid = null, e.subject = {}, e.subject.getField = function(t) {
    return _getAttribute(e.subject, t);
  }, e.subject.addField = function(t) {
    _fillMissingFields([t]), e.subject.attributes.push(t);
  }, e.subject.attributes = [], e.subject.hash = null, e.publicKey = null, e.attributes = [], e.getAttribute = function(t) {
    return _getAttribute(e, t);
  }, e.addAttribute = function(t) {
    _fillMissingFields([t]), e.attributes.push(t);
  }, e.md = null, e.setSubject = function(t) {
    _fillMissingFields(t), e.subject.attributes = t, e.subject.hash = null;
  }, e.setAttributes = function(t) {
    _fillMissingFields(t), e.attributes = t;
  }, e.sign = function(t, a) {
    e.md = a || forge$c.md.sha1.create();
    var n = oids[e.md.algorithm + "WithRSAEncryption"];
    if (!n) {
      var u = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
      throw u.algorithm = e.md.algorithm, u;
    }
    e.signatureOid = e.siginfo.algorithmOid = n, e.certificationRequestInfo = pki$2.getCertificationRequestInfo(e);
    var o = asn1$4.toDer(e.certificationRequestInfo);
    e.md.update(o.getBytes()), e.signature = t.sign(e.md);
  }, e.verify = function() {
    var t = !1, a = e.md;
    if (a === null) {
      a = _createSignatureDigest({
        signatureOid: e.signatureOid,
        type: "certification request"
      });
      var n = e.certificationRequestInfo || pki$2.getCertificationRequestInfo(e), u = asn1$4.toDer(n);
      a.update(u.getBytes());
    }
    return a !== null && (t = _verifySignature({
      certificate: e,
      md: a,
      signature: e.signature
    })), t;
  }, e;
};
function _dnToAsn1(e) {
  for (var t = asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.SEQUENCE,
    !0,
    []
  ), a, n, u = e.attributes, o = 0; o < u.length; ++o) {
    a = u[o];
    var l = a.value, h = asn1$4.Type.PRINTABLESTRING;
    "valueTagClass" in a && (h = a.valueTagClass, h === asn1$4.Type.UTF8 && (l = forge$c.util.encodeUtf8(l))), n = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SET, !0, [
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
        // AttributeType
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.OID,
          !1,
          asn1$4.oidToDer(a.type).getBytes()
        ),
        // AttributeValue
        asn1$4.create(asn1$4.Class.UNIVERSAL, h, !1, l)
      ])
    ]), t.value.push(n);
  }
  return t;
}
function _fillMissingFields(e) {
  for (var t, a = 0; a < e.length; ++a) {
    if (t = e[a], typeof t.name > "u" && (t.type && t.type in pki$2.oids ? t.name = pki$2.oids[t.type] : t.shortName && t.shortName in _shortNames && (t.name = pki$2.oids[_shortNames[t.shortName]])), typeof t.type > "u")
      if (t.name && t.name in pki$2.oids)
        t.type = pki$2.oids[t.name];
      else {
        var n = new Error("Attribute type not specified.");
        throw n.attribute = t, n;
      }
    if (typeof t.shortName > "u" && t.name && t.name in _shortNames && (t.shortName = _shortNames[t.name]), t.type === oids.extensionRequest && (t.valueConstructed = !0, t.valueTagClass = asn1$4.Type.SEQUENCE, !t.value && t.extensions)) {
      t.value = [];
      for (var u = 0; u < t.extensions.length; ++u)
        t.value.push(pki$2.certificateExtensionToAsn1(
          _fillMissingExtensionFields(t.extensions[u])
        ));
    }
    if (typeof t.value > "u") {
      var n = new Error("Attribute value not specified.");
      throw n.attribute = t, n;
    }
  }
}
function _fillMissingExtensionFields(e, t) {
  if (t = t || {}, typeof e.name > "u" && e.id && e.id in pki$2.oids && (e.name = pki$2.oids[e.id]), typeof e.id > "u")
    if (e.name && e.name in pki$2.oids)
      e.id = pki$2.oids[e.name];
    else {
      var a = new Error("Extension ID not specified.");
      throw a.extension = e, a;
    }
  if (typeof e.value < "u")
    return e;
  if (e.name === "keyUsage") {
    var n = 0, u = 0, o = 0;
    e.digitalSignature && (u |= 128, n = 7), e.nonRepudiation && (u |= 64, n = 6), e.keyEncipherment && (u |= 32, n = 5), e.dataEncipherment && (u |= 16, n = 4), e.keyAgreement && (u |= 8, n = 3), e.keyCertSign && (u |= 4, n = 2), e.cRLSign && (u |= 2, n = 1), e.encipherOnly && (u |= 1, n = 0), e.decipherOnly && (o |= 128, n = 7);
    var l = String.fromCharCode(n);
    o !== 0 ? l += String.fromCharCode(u) + String.fromCharCode(o) : u !== 0 && (l += String.fromCharCode(u)), e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      !1,
      l
    );
  } else if (e.name === "basicConstraints")
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.SEQUENCE,
      !0,
      []
    ), e.cA && e.value.value.push(asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BOOLEAN,
      !1,
      String.fromCharCode(255)
    )), "pathLenConstraint" in e && e.value.value.push(asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      !1,
      asn1$4.integerToDer(e.pathLenConstraint).getBytes()
    ));
  else if (e.name === "extKeyUsage") {
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.SEQUENCE,
      !0,
      []
    );
    var h = e.value.value;
    for (var y in e)
      e[y] === !0 && (y in oids ? h.push(asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        !1,
        asn1$4.oidToDer(oids[y]).getBytes()
      )) : y.indexOf(".") !== -1 && h.push(asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        !1,
        asn1$4.oidToDer(y).getBytes()
      )));
  } else if (e.name === "nsCertType") {
    var n = 0, u = 0;
    e.client && (u |= 128, n = 7), e.server && (u |= 64, n = 6), e.email && (u |= 32, n = 5), e.objsign && (u |= 16, n = 4), e.reserved && (u |= 8, n = 3), e.sslCA && (u |= 4, n = 2), e.emailCA && (u |= 2, n = 1), e.objCA && (u |= 1, n = 0);
    var l = String.fromCharCode(n);
    u !== 0 && (l += String.fromCharCode(u)), e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      !1,
      l
    );
  } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
    e.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, []);
    for (var _, d = 0; d < e.altNames.length; ++d) {
      _ = e.altNames[d];
      var l = _.value;
      if (_.type === 7 && _.ip) {
        if (l = forge$c.util.bytesFromIP(_.ip), l === null) {
          var a = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          throw a.extension = e, a;
        }
      } else
        _.type === 8 && (_.oid ? l = asn1$4.oidToDer(asn1$4.oidToDer(_.oid)) : l = asn1$4.oidToDer(l));
      e.value.value.push(asn1$4.create(
        asn1$4.Class.CONTEXT_SPECIFIC,
        _.type,
        !1,
        l
      ));
    }
  } else if (e.name === "nsComment" && t.cert) {
    if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128)
      throw new Error('Invalid "nsComment" content.');
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.IA5STRING,
      !1,
      e.comment
    );
  } else if (e.name === "subjectKeyIdentifier" && t.cert) {
    var $ = t.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = $.toHex(), e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.OCTETSTRING,
      !1,
      $.getBytes()
    );
  } else if (e.name === "authorityKeyIdentifier" && t.cert) {
    e.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, []);
    var h = e.value.value;
    if (e.keyIdentifier) {
      var N = e.keyIdentifier === !0 ? t.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
      h.push(
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, !1, N)
      );
    }
    if (e.authorityCertIssuer) {
      var U = [
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 4, !0, [
          _dnToAsn1(e.authorityCertIssuer === !0 ? t.cert.issuer : e.authorityCertIssuer)
        ])
      ];
      h.push(
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, !0, U)
      );
    }
    if (e.serialNumber) {
      var V = forge$c.util.hexToBytes(e.serialNumber === !0 ? t.cert.serialNumber : e.serialNumber);
      h.push(
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, !1, V)
      );
    }
  } else if (e.name === "cRLDistributionPoints") {
    e.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, []);
    for (var h = e.value.value, Q = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.SEQUENCE,
      !0,
      []
    ), ie = asn1$4.create(
      asn1$4.Class.CONTEXT_SPECIFIC,
      0,
      !0,
      []
    ), _, d = 0; d < e.altNames.length; ++d) {
      _ = e.altNames[d];
      var l = _.value;
      if (_.type === 7 && _.ip) {
        if (l = forge$c.util.bytesFromIP(_.ip), l === null) {
          var a = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          throw a.extension = e, a;
        }
      } else
        _.type === 8 && (_.oid ? l = asn1$4.oidToDer(asn1$4.oidToDer(_.oid)) : l = asn1$4.oidToDer(l));
      ie.value.push(asn1$4.create(
        asn1$4.Class.CONTEXT_SPECIFIC,
        _.type,
        !1,
        l
      ));
    }
    Q.value.push(asn1$4.create(
      asn1$4.Class.CONTEXT_SPECIFIC,
      0,
      !0,
      [ie]
    )), h.push(Q);
  }
  if (typeof e.value > "u") {
    var a = new Error("Extension value not specified.");
    throw a.extension = e, a;
  }
  return e;
}
function _signatureParametersToAsn1(e, t) {
  switch (e) {
    case oids["RSASSA-PSS"]:
      var a = [];
      return t.hash.algorithmOid !== void 0 && a.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, !0, [
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
          asn1$4.create(
            asn1$4.Class.UNIVERSAL,
            asn1$4.Type.OID,
            !1,
            asn1$4.oidToDer(t.hash.algorithmOid).getBytes()
          ),
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, !1, "")
        ])
      ])), t.mgf.algorithmOid !== void 0 && a.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, !0, [
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
          asn1$4.create(
            asn1$4.Class.UNIVERSAL,
            asn1$4.Type.OID,
            !1,
            asn1$4.oidToDer(t.mgf.algorithmOid).getBytes()
          ),
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
            asn1$4.create(
              asn1$4.Class.UNIVERSAL,
              asn1$4.Type.OID,
              !1,
              asn1$4.oidToDer(t.mgf.hash.algorithmOid).getBytes()
            ),
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, !1, "")
          ])
        ])
      ])), t.saltLength !== void 0 && a.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, !0, [
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.INTEGER,
          !1,
          asn1$4.integerToDer(t.saltLength).getBytes()
        )
      ])), asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, a);
    default:
      return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, !1, "");
  }
}
function _CRIAttributesToAsn1(e) {
  var t = asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, !0, []);
  if (e.attributes.length === 0)
    return t;
  for (var a = e.attributes, n = 0; n < a.length; ++n) {
    var u = a[n], o = u.value, l = asn1$4.Type.UTF8;
    "valueTagClass" in u && (l = u.valueTagClass), l === asn1$4.Type.UTF8 && (o = forge$c.util.encodeUtf8(o));
    var h = !1;
    "valueConstructed" in u && (h = u.valueConstructed);
    var y = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
      // AttributeType
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        !1,
        asn1$4.oidToDer(u.type).getBytes()
      ),
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SET, !0, [
        // AttributeValue
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          l,
          h,
          o
        )
      ])
    ]);
    t.value.push(y);
  }
  return t;
}
var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
function _dateToAsn1(e) {
  return e >= jan_1_1950 && e < jan_1_2050 ? asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.UTCTIME,
    !1,
    asn1$4.dateToUtcTime(e)
  ) : asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.GENERALIZEDTIME,
    !1,
    asn1$4.dateToGeneralizedTime(e)
  );
}
pki$2.getTBSCertificate = function(e) {
  var t = _dateToAsn1(e.validity.notBefore), a = _dateToAsn1(e.validity.notAfter), n = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
    // version
    asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, !0, [
      // integer
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.INTEGER,
        !1,
        asn1$4.integerToDer(e.version).getBytes()
      )
    ]),
    // serialNumber
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      !1,
      forge$c.util.hexToBytes(e.serialNumber)
    ),
    // signature
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
      // algorithm
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        !1,
        asn1$4.oidToDer(e.siginfo.algorithmOid).getBytes()
      ),
      // parameters
      _signatureParametersToAsn1(
        e.siginfo.algorithmOid,
        e.siginfo.parameters
      )
    ]),
    // issuer
    _dnToAsn1(e.issuer),
    // validity
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
      t,
      a
    ]),
    // subject
    _dnToAsn1(e.subject),
    // SubjectPublicKeyInfo
    pki$2.publicKeyToAsn1(e.publicKey)
  ]);
  return e.issuer.uniqueId && n.value.push(
    asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, !0, [
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.BITSTRING,
        !1,
        // TODO: support arbitrary bit length ids
        String.fromCharCode(0) + e.issuer.uniqueId
      )
    ])
  ), e.subject.uniqueId && n.value.push(
    asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, !0, [
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.BITSTRING,
        !1,
        // TODO: support arbitrary bit length ids
        String.fromCharCode(0) + e.subject.uniqueId
      )
    ])
  ), e.extensions.length > 0 && n.value.push(pki$2.certificateExtensionsToAsn1(e.extensions)), n;
};
pki$2.getCertificationRequestInfo = function(e) {
  var t = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
    // version
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      !1,
      asn1$4.integerToDer(e.version).getBytes()
    ),
    // subject
    _dnToAsn1(e.subject),
    // SubjectPublicKeyInfo
    pki$2.publicKeyToAsn1(e.publicKey),
    // attributes
    _CRIAttributesToAsn1(e)
  ]);
  return t;
};
pki$2.distinguishedNameToAsn1 = function(e) {
  return _dnToAsn1(e);
};
pki$2.certificateToAsn1 = function(e) {
  var t = e.tbsCertificate || pki$2.getTBSCertificate(e);
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
    // TBSCertificate
    t,
    // AlgorithmIdentifier (signature algorithm)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
      // algorithm
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        !1,
        asn1$4.oidToDer(e.signatureOid).getBytes()
      ),
      // parameters
      _signatureParametersToAsn1(e.signatureOid, e.signatureParameters)
    ]),
    // SignatureValue
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      !1,
      String.fromCharCode(0) + e.signature
    )
  ]);
};
pki$2.certificateExtensionsToAsn1 = function(e) {
  var t = asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 3, !0, []), a = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, []);
  t.value.push(a);
  for (var n = 0; n < e.length; ++n)
    a.value.push(pki$2.certificateExtensionToAsn1(e[n]));
  return t;
};
pki$2.certificateExtensionToAsn1 = function(e) {
  var t = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, []);
  t.value.push(asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.OID,
    !1,
    asn1$4.oidToDer(e.id).getBytes()
  )), e.critical && t.value.push(asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.BOOLEAN,
    !1,
    String.fromCharCode(255)
  ));
  var a = e.value;
  return typeof e.value != "string" && (a = asn1$4.toDer(a).getBytes()), t.value.push(asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.OCTETSTRING,
    !1,
    a
  )), t;
};
pki$2.certificationRequestToAsn1 = function(e) {
  var t = e.certificationRequestInfo || pki$2.getCertificationRequestInfo(e);
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
    // CertificationRequestInfo
    t,
    // AlgorithmIdentifier (signature algorithm)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, !0, [
      // algorithm
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        !1,
        asn1$4.oidToDer(e.signatureOid).getBytes()
      ),
      // parameters
      _signatureParametersToAsn1(e.signatureOid, e.signatureParameters)
    ]),
    // signature
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      !1,
      String.fromCharCode(0) + e.signature
    )
  ]);
};
pki$2.createCaStore = function(e) {
  var t = {
    // stored certificates
    certs: {}
  };
  t.getIssuer = function(l) {
    var h = a(l.issuer);
    return h;
  }, t.addCertificate = function(l) {
    if (typeof l == "string" && (l = forge$c.pki.certificateFromPem(l)), n(l.subject), !t.hasCertificate(l))
      if (l.subject.hash in t.certs) {
        var h = t.certs[l.subject.hash];
        forge$c.util.isArray(h) || (h = [h]), h.push(l), t.certs[l.subject.hash] = h;
      } else
        t.certs[l.subject.hash] = l;
  }, t.hasCertificate = function(l) {
    typeof l == "string" && (l = forge$c.pki.certificateFromPem(l));
    var h = a(l.subject);
    if (!h)
      return !1;
    forge$c.util.isArray(h) || (h = [h]);
    for (var y = asn1$4.toDer(pki$2.certificateToAsn1(l)).getBytes(), _ = 0; _ < h.length; ++_) {
      var d = asn1$4.toDer(pki$2.certificateToAsn1(h[_])).getBytes();
      if (y === d)
        return !0;
    }
    return !1;
  }, t.listAllCertificates = function() {
    var l = [];
    for (var h in t.certs)
      if (t.certs.hasOwnProperty(h)) {
        var y = t.certs[h];
        if (!forge$c.util.isArray(y))
          l.push(y);
        else
          for (var _ = 0; _ < y.length; ++_)
            l.push(y[_]);
      }
    return l;
  }, t.removeCertificate = function(l) {
    var h;
    if (typeof l == "string" && (l = forge$c.pki.certificateFromPem(l)), n(l.subject), !t.hasCertificate(l))
      return null;
    var y = a(l.subject);
    if (!forge$c.util.isArray(y))
      return h = t.certs[l.subject.hash], delete t.certs[l.subject.hash], h;
    for (var _ = asn1$4.toDer(pki$2.certificateToAsn1(l)).getBytes(), d = 0; d < y.length; ++d) {
      var $ = asn1$4.toDer(pki$2.certificateToAsn1(y[d])).getBytes();
      _ === $ && (h = y[d], y.splice(d, 1));
    }
    return y.length === 0 && delete t.certs[l.subject.hash], h;
  };
  function a(l) {
    return n(l), t.certs[l.hash] || null;
  }
  function n(l) {
    if (!l.hash) {
      var h = forge$c.md.sha1.create();
      l.attributes = pki$2.RDNAttributesAsArray(_dnToAsn1(l), h), l.hash = h.digest().toHex();
    }
  }
  if (e)
    for (var u = 0; u < e.length; ++u) {
      var o = e[u];
      t.addCertificate(o);
    }
  return t;
};
pki$2.certificateError = {
  bad_certificate: "forge.pki.BadCertificate",
  unsupported_certificate: "forge.pki.UnsupportedCertificate",
  certificate_revoked: "forge.pki.CertificateRevoked",
  certificate_expired: "forge.pki.CertificateExpired",
  certificate_unknown: "forge.pki.CertificateUnknown",
  unknown_ca: "forge.pki.UnknownCertificateAuthority"
};
pki$2.verifyCertificateChain = function(e, t, a) {
  typeof a == "function" && (a = { verify: a }), a = a || {}, t = t.slice(0);
  var n = t.slice(0), u = a.validityCheckDate;
  typeof u > "u" && (u = /* @__PURE__ */ new Date());
  var o = !0, l = null, h = 0;
  do {
    var y = t.shift(), _ = null, d = !1;
    if (u && (u < y.validity.notBefore || u > y.validity.notAfter) && (l = {
      message: "Certificate is not valid yet or has expired.",
      error: pki$2.certificateError.certificate_expired,
      notBefore: y.validity.notBefore,
      notAfter: y.validity.notAfter,
      // TODO: we might want to reconsider renaming 'now' to
      // 'validityCheckDate' should this API be changed in the future.
      now: u
    }), l === null) {
      if (_ = t[0] || e.getIssuer(y), _ === null && y.isIssuer(y) && (d = !0, _ = y), _) {
        var $ = _;
        forge$c.util.isArray($) || ($ = [$]);
        for (var N = !1; !N && $.length > 0; ) {
          _ = $.shift();
          try {
            N = _.verify(y);
          } catch {
          }
        }
        N || (l = {
          message: "Certificate signature is invalid.",
          error: pki$2.certificateError.bad_certificate
        });
      }
      l === null && (!_ || d) && !e.hasCertificate(y) && (l = {
        message: "Certificate is not trusted.",
        error: pki$2.certificateError.unknown_ca
      });
    }
    if (l === null && _ && !y.isIssuer(_) && (l = {
      message: "Certificate issuer is invalid.",
      error: pki$2.certificateError.bad_certificate
    }), l === null)
      for (var U = {
        keyUsage: !0,
        basicConstraints: !0
      }, V = 0; l === null && V < y.extensions.length; ++V) {
        var Q = y.extensions[V];
        Q.critical && !(Q.name in U) && (l = {
          message: "Certificate has an unsupported critical extension.",
          error: pki$2.certificateError.unsupported_certificate
        });
      }
    if (l === null && (!o || t.length === 0 && (!_ || d))) {
      var ie = y.getExtension("basicConstraints"), ee = y.getExtension("keyUsage");
      if (ee !== null && (!ee.keyCertSign || ie === null) && (l = {
        message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
        error: pki$2.certificateError.bad_certificate
      }), l === null && ie !== null && !ie.cA && (l = {
        message: "Certificate basicConstraints indicates the certificate is not a CA.",
        error: pki$2.certificateError.bad_certificate
      }), l === null && ee !== null && "pathLenConstraint" in ie) {
        var ne = h - 1;
        ne > ie.pathLenConstraint && (l = {
          message: "Certificate basicConstraints pathLenConstraint violated.",
          error: pki$2.certificateError.bad_certificate
        });
      }
    }
    var ge = l === null ? !0 : l.error, be = a.verify ? a.verify(ge, h, n) : ge;
    if (be === !0)
      l = null;
    else
      throw ge === !0 && (l = {
        message: "The application rejected the certificate.",
        error: pki$2.certificateError.bad_certificate
      }), (be || be === 0) && (typeof be == "object" && !forge$c.util.isArray(be) ? (be.message && (l.message = be.message), be.error && (l.error = be.error)) : typeof be == "string" && (l.error = be)), l;
    o = !1, ++h;
  } while (t.length > 0);
  return !0;
};
var forge$b = forge$D, asn1$3 = forge$b.asn1, pki$1 = forge$b.pki, p12 = forge$b.pkcs12 = forge$b.pkcs12 || {}, contentInfoValidator = {
  name: "ContentInfo",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  // a ContentInfo
  constructed: !0,
  value: [{
    name: "ContentInfo.contentType",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: !1,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
    constructed: !0,
    captureAsn1: "content"
  }]
}, pfxValidator = {
  name: "PFX",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: !0,
  value: [
    {
      name: "PFX.version",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.INTEGER,
      constructed: !1,
      capture: "version"
    },
    contentInfoValidator,
    {
      name: "PFX.macData",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: !0,
      optional: !0,
      captureAsn1: "mac",
      value: [{
        name: "PFX.macData.mac",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        // DigestInfo
        constructed: !0,
        value: [{
          name: "PFX.macData.mac.digestAlgorithm",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.SEQUENCE,
          // DigestAlgorithmIdentifier
          constructed: !0,
          value: [{
            name: "PFX.macData.mac.digestAlgorithm.algorithm",
            tagClass: asn1$3.Class.UNIVERSAL,
            type: asn1$3.Type.OID,
            constructed: !1,
            capture: "macAlgorithm"
          }, {
            name: "PFX.macData.mac.digestAlgorithm.parameters",
            tagClass: asn1$3.Class.UNIVERSAL,
            captureAsn1: "macAlgorithmParameters"
          }]
        }, {
          name: "PFX.macData.mac.digest",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.OCTETSTRING,
          constructed: !1,
          capture: "macDigest"
        }]
      }, {
        name: "PFX.macData.macSalt",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OCTETSTRING,
        constructed: !1,
        capture: "macSalt"
      }, {
        name: "PFX.macData.iterations",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.INTEGER,
        constructed: !1,
        optional: !0,
        capture: "macIterations"
      }]
    }
  ]
}, safeBagValidator = {
  name: "SafeBag",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "SafeBag.bagId",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: !1,
    capture: "bagId"
  }, {
    name: "SafeBag.bagValue",
    tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
    constructed: !0,
    captureAsn1: "bagValue"
  }, {
    name: "SafeBag.bagAttributes",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.SET,
    constructed: !0,
    optional: !0,
    capture: "bagAttributes"
  }]
}, attributeValidator = {
  name: "Attribute",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "Attribute.attrId",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: !1,
    capture: "oid"
  }, {
    name: "Attribute.attrValues",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.SET,
    constructed: !0,
    capture: "values"
  }]
}, certBagValidator = {
  name: "CertBag",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "CertBag.certId",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: !1,
    capture: "certId"
  }, {
    name: "CertBag.certValue",
    tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
    constructed: !0,
    /* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */
    value: [{
      name: "CertBag.certValue[0]",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Class.OCTETSTRING,
      constructed: !1,
      capture: "cert"
    }]
  }]
};
function _getBagsByAttribute(e, t, a, n) {
  for (var u = [], o = 0; o < e.length; o++)
    for (var l = 0; l < e[o].safeBags.length; l++) {
      var h = e[o].safeBags[l];
      if (!(n !== void 0 && h.type !== n)) {
        if (t === null) {
          u.push(h);
          continue;
        }
        h.attributes[t] !== void 0 && h.attributes[t].indexOf(a) >= 0 && u.push(h);
      }
    }
  return u;
}
p12.pkcs12FromAsn1 = function(e, t, a) {
  typeof t == "string" ? (a = t, t = !0) : t === void 0 && (t = !0);
  var n = {}, u = [];
  if (!asn1$3.validate(e, pfxValidator, n, u)) {
    var o = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
    throw o.errors = o, o;
  }
  var l = {
    version: n.version.charCodeAt(0),
    safeContents: [],
    /**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */
    getBags: function(ie) {
      var ee = {}, ne;
      return "localKeyId" in ie ? ne = ie.localKeyId : "localKeyIdHex" in ie && (ne = forge$b.util.hexToBytes(ie.localKeyIdHex)), ne === void 0 && !("friendlyName" in ie) && "bagType" in ie && (ee[ie.bagType] = _getBagsByAttribute(
        l.safeContents,
        null,
        null,
        ie.bagType
      )), ne !== void 0 && (ee.localKeyId = _getBagsByAttribute(
        l.safeContents,
        "localKeyId",
        ne,
        ie.bagType
      )), "friendlyName" in ie && (ee.friendlyName = _getBagsByAttribute(
        l.safeContents,
        "friendlyName",
        ie.friendlyName,
        ie.bagType
      )), ee;
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */
    getBagsByFriendlyName: function(ie, ee) {
      return _getBagsByAttribute(
        l.safeContents,
        "friendlyName",
        ie,
        ee
      );
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */
    getBagsByLocalKeyId: function(ie, ee) {
      return _getBagsByAttribute(
        l.safeContents,
        "localKeyId",
        ie,
        ee
      );
    }
  };
  if (n.version.charCodeAt(0) !== 3) {
    var o = new Error("PKCS#12 PFX of version other than 3 not supported.");
    throw o.version = n.version.charCodeAt(0), o;
  }
  if (asn1$3.derToOid(n.contentType) !== pki$1.oids.data) {
    var o = new Error("Only PKCS#12 PFX in password integrity mode supported.");
    throw o.oid = asn1$3.derToOid(n.contentType), o;
  }
  var h = n.content.value[0];
  if (h.tagClass !== asn1$3.Class.UNIVERSAL || h.type !== asn1$3.Type.OCTETSTRING)
    throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
  if (h = _decodePkcs7Data(h), n.mac) {
    var y = null, _ = 0, d = asn1$3.derToOid(n.macAlgorithm);
    switch (d) {
      case pki$1.oids.sha1:
        y = forge$b.md.sha1.create(), _ = 20;
        break;
      case pki$1.oids.sha256:
        y = forge$b.md.sha256.create(), _ = 32;
        break;
      case pki$1.oids.sha384:
        y = forge$b.md.sha384.create(), _ = 48;
        break;
      case pki$1.oids.sha512:
        y = forge$b.md.sha512.create(), _ = 64;
        break;
      case pki$1.oids.md5:
        y = forge$b.md.md5.create(), _ = 16;
        break;
    }
    if (y === null)
      throw new Error("PKCS#12 uses unsupported MAC algorithm: " + d);
    var $ = new forge$b.util.ByteBuffer(n.macSalt), N = "macIterations" in n ? parseInt(forge$b.util.bytesToHex(n.macIterations), 16) : 1, U = p12.generateKey(
      a,
      $,
      3,
      N,
      _,
      y
    ), V = forge$b.hmac.create();
    V.start(y, U), V.update(h.value);
    var Q = V.getMac();
    if (Q.getBytes() !== n.macDigest)
      throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
  } else if (Array.isArray(e.value) && e.value.length > 2)
    throw new Error("Invalid PKCS#12. macData field present but MAC was not validated.");
  return _decodeAuthenticatedSafe(l, h.value, t, a), l;
};
function _decodePkcs7Data(e) {
  if (e.composed || e.constructed) {
    for (var t = forge$b.util.createBuffer(), a = 0; a < e.value.length; ++a)
      t.putBytes(e.value[a].value);
    e.composed = e.constructed = !1, e.value = t.getBytes();
  }
  return e;
}
function _decodeAuthenticatedSafe(e, t, a, n) {
  if (t = asn1$3.fromDer(t, a), t.tagClass !== asn1$3.Class.UNIVERSAL || t.type !== asn1$3.Type.SEQUENCE || t.constructed !== !0)
    throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
  for (var u = 0; u < t.value.length; u++) {
    var o = t.value[u], l = {}, h = [];
    if (!asn1$3.validate(o, contentInfoValidator, l, h)) {
      var y = new Error("Cannot read ContentInfo.");
      throw y.errors = h, y;
    }
    var _ = {
      encrypted: !1
    }, d = null, $ = l.content.value[0];
    switch (asn1$3.derToOid(l.contentType)) {
      case pki$1.oids.data:
        if ($.tagClass !== asn1$3.Class.UNIVERSAL || $.type !== asn1$3.Type.OCTETSTRING)
          throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
        d = _decodePkcs7Data($).value;
        break;
      case pki$1.oids.encryptedData:
        d = _decryptSafeContents($, n), _.encrypted = !0;
        break;
      default:
        var y = new Error("Unsupported PKCS#12 contentType.");
        throw y.contentType = asn1$3.derToOid(l.contentType), y;
    }
    _.safeBags = _decodeSafeContents(d, a, n), e.safeContents.push(_);
  }
}
function _decryptSafeContents(e, t) {
  var a = {}, n = [];
  if (!asn1$3.validate(
    e,
    forge$b.pkcs7.asn1.encryptedDataValidator,
    a,
    n
  )) {
    var u = new Error("Cannot read EncryptedContentInfo.");
    throw u.errors = n, u;
  }
  var o = asn1$3.derToOid(a.contentType);
  if (o !== pki$1.oids.data) {
    var u = new Error(
      "PKCS#12 EncryptedContentInfo ContentType is not Data."
    );
    throw u.oid = o, u;
  }
  o = asn1$3.derToOid(a.encAlgorithm);
  var l = pki$1.pbe.getCipher(o, a.encParameter, t), h = _decodePkcs7Data(a.encryptedContentAsn1), y = forge$b.util.createBuffer(h.value);
  if (l.update(y), !l.finish())
    throw new Error("Failed to decrypt PKCS#12 SafeContents.");
  return l.output.getBytes();
}
function _decodeSafeContents(e, t, a) {
  if (!t && e.length === 0)
    return [];
  if (e = asn1$3.fromDer(e, t), e.tagClass !== asn1$3.Class.UNIVERSAL || e.type !== asn1$3.Type.SEQUENCE || e.constructed !== !0)
    throw new Error(
      "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
    );
  for (var n = [], u = 0; u < e.value.length; u++) {
    var o = e.value[u], l = {}, h = [];
    if (!asn1$3.validate(o, safeBagValidator, l, h)) {
      var y = new Error("Cannot read SafeBag.");
      throw y.errors = h, y;
    }
    var _ = {
      type: asn1$3.derToOid(l.bagId),
      attributes: _decodeBagAttributes(l.bagAttributes)
    };
    n.push(_);
    var d, $, N = l.bagValue.value[0];
    switch (_.type) {
      case pki$1.oids.pkcs8ShroudedKeyBag:
        if (N = pki$1.decryptPrivateKeyInfo(N, a), N === null)
          throw new Error(
            "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
          );
      case pki$1.oids.keyBag:
        try {
          _.key = pki$1.privateKeyFromAsn1(N);
        } catch {
          _.key = null, _.asn1 = N;
        }
        continue;
      case pki$1.oids.certBag:
        d = certBagValidator, $ = function() {
          if (asn1$3.derToOid(l.certId) !== pki$1.oids.x509Certificate) {
            var V = new Error(
              "Unsupported certificate type, only X.509 supported."
            );
            throw V.oid = asn1$3.derToOid(l.certId), V;
          }
          var Q = asn1$3.fromDer(l.cert, t);
          try {
            _.cert = pki$1.certificateFromAsn1(Q, !0);
          } catch {
            _.cert = null, _.asn1 = Q;
          }
        };
        break;
      default:
        var y = new Error("Unsupported PKCS#12 SafeBag type.");
        throw y.oid = _.type, y;
    }
    if (d !== void 0 && !asn1$3.validate(N, d, l, h)) {
      var y = new Error("Cannot read PKCS#12 " + d.name);
      throw y.errors = h, y;
    }
    $();
  }
  return n;
}
function _decodeBagAttributes(e) {
  var t = {};
  if (e !== void 0)
    for (var a = 0; a < e.length; ++a) {
      var n = {}, u = [];
      if (!asn1$3.validate(e[a], attributeValidator, n, u)) {
        var o = new Error("Cannot read PKCS#12 BagAttribute.");
        throw o.errors = u, o;
      }
      var l = asn1$3.derToOid(n.oid);
      if (pki$1.oids[l] !== void 0) {
        t[pki$1.oids[l]] = [];
        for (var h = 0; h < n.values.length; ++h)
          t[pki$1.oids[l]].push(n.values[h].value);
      }
    }
  return t;
}
p12.toPkcs12Asn1 = function(e, t, a, n) {
  n = n || {}, n.saltSize = n.saltSize || 8, n.count = n.count || 2048, n.algorithm = n.algorithm || n.encAlgorithm || "aes128", "useMac" in n || (n.useMac = !0), "localKeyId" in n || (n.localKeyId = null), "generateLocalKeyId" in n || (n.generateLocalKeyId = !0);
  var u = n.localKeyId, o;
  if (u !== null)
    u = forge$b.util.hexToBytes(u);
  else if (n.generateLocalKeyId)
    if (t) {
      var l = forge$b.util.isArray(t) ? t[0] : t;
      typeof l == "string" && (l = pki$1.certificateFromPem(l));
      var h = forge$b.md.sha1.create();
      h.update(asn1$3.toDer(pki$1.certificateToAsn1(l)).getBytes()), u = h.digest().getBytes();
    } else
      u = forge$b.random.getBytes(20);
  var y = [];
  u !== null && y.push(
    // localKeyID
    asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
      // attrId
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        !1,
        asn1$3.oidToDer(pki$1.oids.localKeyId).getBytes()
      ),
      // attrValues
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, !0, [
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OCTETSTRING,
          !1,
          u
        )
      ])
    ])
  ), "friendlyName" in n && y.push(
    // friendlyName
    asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
      // attrId
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        !1,
        asn1$3.oidToDer(pki$1.oids.friendlyName).getBytes()
      ),
      // attrValues
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, !0, [
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.BMPSTRING,
          !1,
          n.friendlyName
        )
      ])
    ])
  ), y.length > 0 && (o = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, !0, y));
  var _ = [], d = [];
  t !== null && (forge$b.util.isArray(t) ? d = t : d = [t]);
  for (var $ = [], N = 0; N < d.length; ++N) {
    t = d[N], typeof t == "string" && (t = pki$1.certificateFromPem(t));
    var U = N === 0 ? o : void 0, V = pki$1.certificateToAsn1(t), Q = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
      // bagId
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        !1,
        asn1$3.oidToDer(pki$1.oids.certBag).getBytes()
      ),
      // bagValue
      asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, !0, [
        // CertBag
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
          // certId
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OID,
            !1,
            asn1$3.oidToDer(pki$1.oids.x509Certificate).getBytes()
          ),
          // certValue (x509Certificate)
          asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, !0, [
            asn1$3.create(
              asn1$3.Class.UNIVERSAL,
              asn1$3.Type.OCTETSTRING,
              !1,
              asn1$3.toDer(V).getBytes()
            )
          ])
        ])
      ]),
      // bagAttributes (OPTIONAL)
      U
    ]);
    $.push(Q);
  }
  if ($.length > 0) {
    var ie = asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.SEQUENCE,
      !0,
      $
    ), ee = (
      // PKCS#7 ContentInfo
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
        // contentType
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          !1,
          // OID for the content type is 'data'
          asn1$3.oidToDer(pki$1.oids.data).getBytes()
        ),
        // content
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, !0, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OCTETSTRING,
            !1,
            asn1$3.toDer(ie).getBytes()
          )
        ])
      ])
    );
    _.push(ee);
  }
  var ne = null;
  if (e !== null) {
    var ge = pki$1.wrapRsaPrivateKey(pki$1.privateKeyToAsn1(e));
    a === null ? ne = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
      // bagId
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        !1,
        asn1$3.oidToDer(pki$1.oids.keyBag).getBytes()
      ),
      // bagValue
      asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, !0, [
        // PrivateKeyInfo
        ge
      ]),
      // bagAttributes (OPTIONAL)
      o
    ]) : ne = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
      // bagId
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        !1,
        asn1$3.oidToDer(pki$1.oids.pkcs8ShroudedKeyBag).getBytes()
      ),
      // bagValue
      asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, !0, [
        // EncryptedPrivateKeyInfo
        pki$1.encryptPrivateKeyInfo(ge, a, n)
      ]),
      // bagAttributes (OPTIONAL)
      o
    ]);
    var be = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [ne]), Ee = (
      // PKCS#7 ContentInfo
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
        // contentType
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          !1,
          // OID for the content type is 'data'
          asn1$3.oidToDer(pki$1.oids.data).getBytes()
        ),
        // content
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, !0, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OCTETSTRING,
            !1,
            asn1$3.toDer(be).getBytes()
          )
        ])
      ])
    );
    _.push(Ee);
  }
  var xe = asn1$3.create(
    asn1$3.Class.UNIVERSAL,
    asn1$3.Type.SEQUENCE,
    !0,
    _
  ), Le;
  if (n.useMac) {
    var h = forge$b.md.sha1.create(), Ne = new forge$b.util.ByteBuffer(
      forge$b.random.getBytes(n.saltSize)
    ), Re = n.count, e = p12.generateKey(a, Ne, 3, Re, 20), Xe = forge$b.hmac.create();
    Xe.start(h, e), Xe.update(asn1$3.toDer(xe).getBytes());
    var pe = Xe.getMac();
    Le = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
      // mac DigestInfo
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
        // digestAlgorithm
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
          // algorithm = SHA-1
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OID,
            !1,
            asn1$3.oidToDer(pki$1.oids.sha1).getBytes()
          ),
          // parameters = Null
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.NULL, !1, "")
        ]),
        // digest
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OCTETSTRING,
          !1,
          pe.getBytes()
        )
      ]),
      // macSalt OCTET STRING
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OCTETSTRING,
        !1,
        Ne.getBytes()
      ),
      // iterations INTEGER (XXX: Only support count < 65536)
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.INTEGER,
        !1,
        asn1$3.integerToDer(Re).getBytes()
      )
    ]);
  }
  return asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
    // version (3)
    asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.INTEGER,
      !1,
      asn1$3.integerToDer(3).getBytes()
    ),
    // PKCS#7 ContentInfo
    asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, !0, [
      // contentType
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        !1,
        // OID for the content type is 'data'
        asn1$3.oidToDer(pki$1.oids.data).getBytes()
      ),
      // content
      asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, !0, [
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OCTETSTRING,
          !1,
          asn1$3.toDer(xe).getBytes()
        )
      ])
    ]),
    Le
  ]);
};
p12.generateKey = forge$b.pbe.generatePkcs12Key;
var forge$a = forge$D, asn1$2 = forge$a.asn1, pki = forge$a.pki = forge$a.pki || {};
pki.pemToDer = function(e) {
  var t = forge$a.pem.decode(e)[0];
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert PEM to DER; PEM is encrypted.");
  return forge$a.util.createBuffer(t.body);
};
pki.privateKeyFromPem = function(e) {
  var t = forge$a.pem.decode(e)[0];
  if (t.type !== "PRIVATE KEY" && t.type !== "RSA PRIVATE KEY") {
    var a = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
    throw a.headerType = t.type, a;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert private key from PEM; PEM is encrypted.");
  var n = asn1$2.fromDer(t.body);
  return pki.privateKeyFromAsn1(n);
};
pki.privateKeyToPem = function(e, t) {
  var a = {
    type: "RSA PRIVATE KEY",
    body: asn1$2.toDer(pki.privateKeyToAsn1(e)).getBytes()
  };
  return forge$a.pem.encode(a, { maxline: t });
};
pki.privateKeyInfoToPem = function(e, t) {
  var a = {
    type: "PRIVATE KEY",
    body: asn1$2.toDer(e).getBytes()
  };
  return forge$a.pem.encode(a, { maxline: t });
};
var forge$9 = forge$D, prf_TLS1 = function(e, t, a, n) {
  var u = forge$9.util.createBuffer(), o = e.length >> 1, l = o + (e.length & 1), h = e.substr(0, l), y = e.substr(o, l), _ = forge$9.util.createBuffer(), d = forge$9.hmac.create();
  a = t + a;
  var $ = Math.ceil(n / 16), N = Math.ceil(n / 20);
  d.start("MD5", h);
  var U = forge$9.util.createBuffer();
  _.putBytes(a);
  for (var V = 0; V < $; ++V)
    d.start(null, null), d.update(_.getBytes()), _.putBuffer(d.digest()), d.start(null, null), d.update(_.bytes() + a), U.putBuffer(d.digest());
  d.start("SHA1", y);
  var Q = forge$9.util.createBuffer();
  _.clear(), _.putBytes(a);
  for (var V = 0; V < N; ++V)
    d.start(null, null), d.update(_.getBytes()), _.putBuffer(d.digest()), d.start(null, null), d.update(_.bytes() + a), Q.putBuffer(d.digest());
  return u.putBytes(forge$9.util.xorBytes(
    U.getBytes(),
    Q.getBytes(),
    n
  )), u;
}, hmac_sha1 = function(e, t, a) {
  var n = forge$9.hmac.create();
  n.start("SHA1", e);
  var u = forge$9.util.createBuffer();
  return u.putInt32(t[0]), u.putInt32(t[1]), u.putByte(a.type), u.putByte(a.version.major), u.putByte(a.version.minor), u.putInt16(a.length), u.putBytes(a.fragment.bytes()), n.update(u.getBytes()), n.digest().getBytes();
}, deflate = function(e, t, a) {
  var n = !1;
  try {
    var u = e.deflate(t.fragment.getBytes());
    t.fragment = forge$9.util.createBuffer(u), t.length = u.length, n = !0;
  } catch {
  }
  return n;
}, inflate = function(e, t, a) {
  var n = !1;
  try {
    var u = e.inflate(t.fragment.getBytes());
    t.fragment = forge$9.util.createBuffer(u), t.length = u.length, n = !0;
  } catch {
  }
  return n;
}, readVector = function(e, t) {
  var a = 0;
  switch (t) {
    case 1:
      a = e.getByte();
      break;
    case 2:
      a = e.getInt16();
      break;
    case 3:
      a = e.getInt24();
      break;
    case 4:
      a = e.getInt32();
      break;
  }
  return forge$9.util.createBuffer(e.getBytes(a));
}, writeVector = function(e, t, a) {
  e.putInt(a.length(), t << 3), e.putBuffer(a);
}, tls$1 = {};
tls$1.Versions = {
  TLS_1_0: { major: 3, minor: 1 },
  TLS_1_1: { major: 3, minor: 2 },
  TLS_1_2: { major: 3, minor: 3 }
};
tls$1.SupportedVersions = [
  tls$1.Versions.TLS_1_1,
  tls$1.Versions.TLS_1_0
];
tls$1.Version = tls$1.SupportedVersions[0];
tls$1.MaxFragment = 16384 - 1024;
tls$1.ConnectionEnd = {
  server: 0,
  client: 1
};
tls$1.PRFAlgorithm = {
  tls_prf_sha256: 0
};
tls$1.BulkCipherAlgorithm = {
  none: null,
  rc4: 0,
  des3: 1,
  aes: 2
};
tls$1.CipherType = {
  stream: 0,
  block: 1,
  aead: 2
};
tls$1.MACAlgorithm = {
  none: null,
  hmac_md5: 0,
  hmac_sha1: 1,
  hmac_sha256: 2,
  hmac_sha384: 3,
  hmac_sha512: 4
};
tls$1.CompressionMethod = {
  none: 0,
  deflate: 1
};
tls$1.ContentType = {
  change_cipher_spec: 20,
  alert: 21,
  handshake: 22,
  application_data: 23,
  heartbeat: 24
};
tls$1.HandshakeType = {
  hello_request: 0,
  client_hello: 1,
  server_hello: 2,
  certificate: 11,
  server_key_exchange: 12,
  certificate_request: 13,
  server_hello_done: 14,
  certificate_verify: 15,
  client_key_exchange: 16,
  finished: 20
};
tls$1.Alert = {};
tls$1.Alert.Level = {
  warning: 1,
  fatal: 2
};
tls$1.Alert.Description = {
  close_notify: 0,
  unexpected_message: 10,
  bad_record_mac: 20,
  decryption_failed: 21,
  record_overflow: 22,
  decompression_failure: 30,
  handshake_failure: 40,
  bad_certificate: 42,
  unsupported_certificate: 43,
  certificate_revoked: 44,
  certificate_expired: 45,
  certificate_unknown: 46,
  illegal_parameter: 47,
  unknown_ca: 48,
  access_denied: 49,
  decode_error: 50,
  decrypt_error: 51,
  export_restriction: 60,
  protocol_version: 70,
  insufficient_security: 71,
  internal_error: 80,
  user_canceled: 90,
  no_renegotiation: 100
};
tls$1.HeartbeatMessageType = {
  heartbeat_request: 1,
  heartbeat_response: 2
};
tls$1.CipherSuites = {};
tls$1.getCipherSuite = function(e) {
  var t = null;
  for (var a in tls$1.CipherSuites) {
    var n = tls$1.CipherSuites[a];
    if (n.id[0] === e.charCodeAt(0) && n.id[1] === e.charCodeAt(1)) {
      t = n;
      break;
    }
  }
  return t;
};
tls$1.handleUnexpected = function(e, t) {
  var a = !e.open && e.entity === tls$1.ConnectionEnd.client;
  a || e.error(e, {
    message: "Unexpected message. Received TLS record out of order.",
    send: !0,
    alert: {
      level: tls$1.Alert.Level.fatal,
      description: tls$1.Alert.Description.unexpected_message
    }
  });
};
tls$1.handleHelloRequest = function(e, t, a) {
  !e.handshaking && e.handshakes > 0 && (tls$1.queue(e, tls$1.createAlert(e, {
    level: tls$1.Alert.Level.warning,
    description: tls$1.Alert.Description.no_renegotiation
  })), tls$1.flush(e)), e.process();
};
tls$1.parseHelloMessage = function(e, t, a) {
  var n = null, u = e.entity === tls$1.ConnectionEnd.client;
  if (a < 38)
    e.error(e, {
      message: u ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  else {
    var o = t.fragment, l = o.length();
    if (n = {
      version: {
        major: o.getByte(),
        minor: o.getByte()
      },
      random: forge$9.util.createBuffer(o.getBytes(32)),
      session_id: readVector(o, 1),
      extensions: []
    }, u ? (n.cipher_suite = o.getBytes(2), n.compression_method = o.getByte()) : (n.cipher_suites = readVector(o, 2), n.compression_methods = readVector(o, 1)), l = a - (l - o.length()), l > 0) {
      for (var h = readVector(o, 2); h.length() > 0; )
        n.extensions.push({
          type: [h.getByte(), h.getByte()],
          data: readVector(h, 2)
        });
      if (!u)
        for (var y = 0; y < n.extensions.length; ++y) {
          var _ = n.extensions[y];
          if (_.type[0] === 0 && _.type[1] === 0)
            for (var d = readVector(_.data, 2); d.length() > 0; ) {
              var $ = d.getByte();
              if ($ !== 0)
                break;
              e.session.extensions.server_name.serverNameList.push(
                readVector(d, 2).getBytes()
              );
            }
        }
    }
    if (e.session.version && (n.version.major !== e.session.version.major || n.version.minor !== e.session.version.minor))
      return e.error(e, {
        message: "TLS version change is disallowed during renegotiation.",
        send: !0,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.protocol_version
        }
      });
    if (u)
      e.session.cipherSuite = tls$1.getCipherSuite(n.cipher_suite);
    else
      for (var N = forge$9.util.createBuffer(n.cipher_suites.bytes()); N.length() > 0 && (e.session.cipherSuite = tls$1.getCipherSuite(N.getBytes(2)), e.session.cipherSuite === null); )
        ;
    if (e.session.cipherSuite === null)
      return e.error(e, {
        message: "No cipher suites in common.",
        send: !0,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.handshake_failure
        },
        cipherSuite: forge$9.util.bytesToHex(n.cipher_suite)
      });
    u ? e.session.compressionMethod = n.compression_method : e.session.compressionMethod = tls$1.CompressionMethod.none;
  }
  return n;
};
tls$1.createSecurityParameters = function(e, t) {
  var a = e.entity === tls$1.ConnectionEnd.client, n = t.random.bytes(), u = a ? e.session.sp.client_random : n, o = a ? n : tls$1.createRandom().getBytes();
  e.session.sp = {
    entity: e.entity,
    prf_algorithm: tls$1.PRFAlgorithm.tls_prf_sha256,
    bulk_cipher_algorithm: null,
    cipher_type: null,
    enc_key_length: null,
    block_length: null,
    fixed_iv_length: null,
    record_iv_length: null,
    mac_algorithm: null,
    mac_length: null,
    mac_key_length: null,
    compression_algorithm: e.session.compressionMethod,
    pre_master_secret: null,
    master_secret: null,
    client_random: u,
    server_random: o
  };
};
tls$1.handleServerHello = function(e, t, a) {
  var n = tls$1.parseHelloMessage(e, t, a);
  if (!e.fail) {
    if (n.version.minor <= e.version.minor)
      e.version.minor = n.version.minor;
    else
      return e.error(e, {
        message: "Incompatible TLS version.",
        send: !0,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.protocol_version
        }
      });
    e.session.version = e.version;
    var u = n.session_id.bytes();
    u.length > 0 && u === e.session.id ? (e.expect = SCC, e.session.resuming = !0, e.session.sp.server_random = n.random.bytes()) : (e.expect = SCE, e.session.resuming = !1, tls$1.createSecurityParameters(e, n)), e.session.id = u, e.process();
  }
};
tls$1.handleClientHello = function(e, t, a) {
  var n = tls$1.parseHelloMessage(e, t, a);
  if (!e.fail) {
    var u = n.session_id.bytes(), o = null;
    if (e.sessionCache && (o = e.sessionCache.getSession(u), o === null ? u = "" : (o.version.major !== n.version.major || o.version.minor > n.version.minor) && (o = null, u = "")), u.length === 0 && (u = forge$9.random.getBytes(32)), e.session.id = u, e.session.clientHelloVersion = n.version, e.session.sp = {}, o)
      e.version = e.session.version = o.version, e.session.sp = o.sp;
    else {
      for (var l, h = 1; h < tls$1.SupportedVersions.length && (l = tls$1.SupportedVersions[h], !(l.minor <= n.version.minor)); ++h)
        ;
      e.version = { major: l.major, minor: l.minor }, e.session.version = e.version;
    }
    o !== null ? (e.expect = CCC, e.session.resuming = !0, e.session.sp.client_random = n.random.bytes()) : (e.expect = e.verifyClient !== !1 ? CCE : CKE, e.session.resuming = !1, tls$1.createSecurityParameters(e, n)), e.open = !0, tls$1.queue(e, tls$1.createRecord(e, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createServerHello(e)
    })), e.session.resuming ? (tls$1.queue(e, tls$1.createRecord(e, {
      type: tls$1.ContentType.change_cipher_spec,
      data: tls$1.createChangeCipherSpec()
    })), e.state.pending = tls$1.createConnectionState(e), e.state.current.write = e.state.pending.write, tls$1.queue(e, tls$1.createRecord(e, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createFinished(e)
    }))) : (tls$1.queue(e, tls$1.createRecord(e, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createCertificate(e)
    })), e.fail || (tls$1.queue(e, tls$1.createRecord(e, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createServerKeyExchange(e)
    })), e.verifyClient !== !1 && tls$1.queue(e, tls$1.createRecord(e, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createCertificateRequest(e)
    })), tls$1.queue(e, tls$1.createRecord(e, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createServerHelloDone(e)
    })))), tls$1.flush(e), e.process();
  }
};
tls$1.handleCertificate = function(e, t, a) {
  if (a < 3)
    return e.error(e, {
      message: "Invalid Certificate message. Message too short.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  var n = t.fragment, u = {
    certificate_list: readVector(n, 3)
  }, o, l, h = [];
  try {
    for (; u.certificate_list.length() > 0; )
      o = readVector(u.certificate_list, 3), l = forge$9.asn1.fromDer(o), o = forge$9.pki.certificateFromAsn1(l, !0), h.push(o);
  } catch (_) {
    return e.error(e, {
      message: "Could not parse certificate list.",
      cause: _,
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.bad_certificate
      }
    });
  }
  var y = e.entity === tls$1.ConnectionEnd.client;
  (y || e.verifyClient === !0) && h.length === 0 ? e.error(e, {
    message: y ? "No server certificate provided." : "No client certificate provided.",
    send: !0,
    alert: {
      level: tls$1.Alert.Level.fatal,
      description: tls$1.Alert.Description.illegal_parameter
    }
  }) : h.length === 0 ? e.expect = y ? SKE : CKE : (y ? e.session.serverCertificate = h[0] : e.session.clientCertificate = h[0], tls$1.verifyCertificateChain(e, h) && (e.expect = y ? SKE : CKE)), e.process();
};
tls$1.handleServerKeyExchange = function(e, t, a) {
  if (a > 0)
    return e.error(e, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.unsupported_certificate
      }
    });
  e.expect = SCR, e.process();
};
tls$1.handleClientKeyExchange = function(e, t, a) {
  if (a < 48)
    return e.error(e, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.unsupported_certificate
      }
    });
  var n = t.fragment, u = {
    enc_pre_master_secret: readVector(n, 2).getBytes()
  }, o = null;
  if (e.getPrivateKey)
    try {
      o = e.getPrivateKey(e, e.session.serverCertificate), o = forge$9.pki.privateKeyFromPem(o);
    } catch (y) {
      e.error(e, {
        message: "Could not get private key.",
        cause: y,
        send: !0,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.internal_error
        }
      });
    }
  if (o === null)
    return e.error(e, {
      message: "No private key set.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.internal_error
      }
    });
  try {
    var l = e.session.sp;
    l.pre_master_secret = o.decrypt(u.enc_pre_master_secret);
    var h = e.session.clientHelloVersion;
    if (h.major !== l.pre_master_secret.charCodeAt(0) || h.minor !== l.pre_master_secret.charCodeAt(1))
      throw new Error("TLS version rollback attack detected.");
  } catch {
    l.pre_master_secret = forge$9.random.getBytes(48);
  }
  e.expect = CCC, e.session.clientCertificate !== null && (e.expect = CCV), e.process();
};
tls$1.handleCertificateRequest = function(e, t, a) {
  if (a < 3)
    return e.error(e, {
      message: "Invalid CertificateRequest. Message too short.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  var n = t.fragment, u = {
    certificate_types: readVector(n, 1),
    certificate_authorities: readVector(n, 2)
  };
  e.session.certificateRequest = u, e.expect = SHD, e.process();
};
tls$1.handleCertificateVerify = function(e, t, a) {
  if (a < 2)
    return e.error(e, {
      message: "Invalid CertificateVerify. Message too short.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  var n = t.fragment;
  n.read -= 4;
  var u = n.bytes();
  n.read += 4;
  var o = {
    signature: readVector(n, 2).getBytes()
  }, l = forge$9.util.createBuffer();
  l.putBuffer(e.session.md5.digest()), l.putBuffer(e.session.sha1.digest()), l = l.getBytes();
  try {
    var h = e.session.clientCertificate;
    if (!h.publicKey.verify(l, o.signature, "NONE"))
      throw new Error("CertificateVerify signature does not match.");
    e.session.md5.update(u), e.session.sha1.update(u);
  } catch {
    return e.error(e, {
      message: "Bad signature in CertificateVerify.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.handshake_failure
      }
    });
  }
  e.expect = CCC, e.process();
};
tls$1.handleServerHelloDone = function(e, t, a) {
  if (a > 0)
    return e.error(e, {
      message: "Invalid ServerHelloDone message. Invalid length.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.record_overflow
      }
    });
  if (e.serverCertificate === null) {
    var n = {
      message: "No server certificate provided. Not enough security.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.insufficient_security
      }
    }, u = 0, o = e.verify(e, n.alert.description, u, []);
    if (o !== !0)
      return (o || o === 0) && (typeof o == "object" && !forge$9.util.isArray(o) ? (o.message && (n.message = o.message), o.alert && (n.alert.description = o.alert)) : typeof o == "number" && (n.alert.description = o)), e.error(e, n);
  }
  e.session.certificateRequest !== null && (t = tls$1.createRecord(e, {
    type: tls$1.ContentType.handshake,
    data: tls$1.createCertificate(e)
  }), tls$1.queue(e, t)), t = tls$1.createRecord(e, {
    type: tls$1.ContentType.handshake,
    data: tls$1.createClientKeyExchange(e)
  }), tls$1.queue(e, t), e.expect = SER;
  var l = function(h, y) {
    h.session.certificateRequest !== null && h.session.clientCertificate !== null && tls$1.queue(h, tls$1.createRecord(h, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createCertificateVerify(h, y)
    })), tls$1.queue(h, tls$1.createRecord(h, {
      type: tls$1.ContentType.change_cipher_spec,
      data: tls$1.createChangeCipherSpec()
    })), h.state.pending = tls$1.createConnectionState(h), h.state.current.write = h.state.pending.write, tls$1.queue(h, tls$1.createRecord(h, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createFinished(h)
    })), h.expect = SCC, tls$1.flush(h), h.process();
  };
  if (e.session.certificateRequest === null || e.session.clientCertificate === null)
    return l(e, null);
  tls$1.getClientSignature(e, l);
};
tls$1.handleChangeCipherSpec = function(e, t) {
  if (t.fragment.getByte() !== 1)
    return e.error(e, {
      message: "Invalid ChangeCipherSpec message received.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  var a = e.entity === tls$1.ConnectionEnd.client;
  (e.session.resuming && a || !e.session.resuming && !a) && (e.state.pending = tls$1.createConnectionState(e)), e.state.current.read = e.state.pending.read, (!e.session.resuming && a || e.session.resuming && !a) && (e.state.pending = null), e.expect = a ? SFI : CFI, e.process();
};
tls$1.handleFinished = function(e, t, a) {
  var n = t.fragment;
  n.read -= 4;
  var u = n.bytes();
  n.read += 4;
  var o = t.fragment.getBytes();
  n = forge$9.util.createBuffer(), n.putBuffer(e.session.md5.digest()), n.putBuffer(e.session.sha1.digest());
  var l = e.entity === tls$1.ConnectionEnd.client, h = l ? "server finished" : "client finished", y = e.session.sp, _ = 12, d = prf_TLS1;
  if (n = d(y.master_secret, h, n.getBytes(), _), n.getBytes() !== o)
    return e.error(e, {
      message: "Invalid verify_data in Finished message.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.decrypt_error
      }
    });
  e.session.md5.update(u), e.session.sha1.update(u), (e.session.resuming && l || !e.session.resuming && !l) && (tls$1.queue(e, tls$1.createRecord(e, {
    type: tls$1.ContentType.change_cipher_spec,
    data: tls$1.createChangeCipherSpec()
  })), e.state.current.write = e.state.pending.write, e.state.pending = null, tls$1.queue(e, tls$1.createRecord(e, {
    type: tls$1.ContentType.handshake,
    data: tls$1.createFinished(e)
  }))), e.expect = l ? SAD : CAD, e.handshaking = !1, ++e.handshakes, e.peerCertificate = l ? e.session.serverCertificate : e.session.clientCertificate, tls$1.flush(e), e.isConnected = !0, e.connected(e), e.process();
};
tls$1.handleAlert = function(e, t) {
  var a = t.fragment, n = {
    level: a.getByte(),
    description: a.getByte()
  }, u;
  switch (n.description) {
    case tls$1.Alert.Description.close_notify:
      u = "Connection closed.";
      break;
    case tls$1.Alert.Description.unexpected_message:
      u = "Unexpected message.";
      break;
    case tls$1.Alert.Description.bad_record_mac:
      u = "Bad record MAC.";
      break;
    case tls$1.Alert.Description.decryption_failed:
      u = "Decryption failed.";
      break;
    case tls$1.Alert.Description.record_overflow:
      u = "Record overflow.";
      break;
    case tls$1.Alert.Description.decompression_failure:
      u = "Decompression failed.";
      break;
    case tls$1.Alert.Description.handshake_failure:
      u = "Handshake failure.";
      break;
    case tls$1.Alert.Description.bad_certificate:
      u = "Bad certificate.";
      break;
    case tls$1.Alert.Description.unsupported_certificate:
      u = "Unsupported certificate.";
      break;
    case tls$1.Alert.Description.certificate_revoked:
      u = "Certificate revoked.";
      break;
    case tls$1.Alert.Description.certificate_expired:
      u = "Certificate expired.";
      break;
    case tls$1.Alert.Description.certificate_unknown:
      u = "Certificate unknown.";
      break;
    case tls$1.Alert.Description.illegal_parameter:
      u = "Illegal parameter.";
      break;
    case tls$1.Alert.Description.unknown_ca:
      u = "Unknown certificate authority.";
      break;
    case tls$1.Alert.Description.access_denied:
      u = "Access denied.";
      break;
    case tls$1.Alert.Description.decode_error:
      u = "Decode error.";
      break;
    case tls$1.Alert.Description.decrypt_error:
      u = "Decrypt error.";
      break;
    case tls$1.Alert.Description.export_restriction:
      u = "Export restriction.";
      break;
    case tls$1.Alert.Description.protocol_version:
      u = "Unsupported protocol version.";
      break;
    case tls$1.Alert.Description.insufficient_security:
      u = "Insufficient security.";
      break;
    case tls$1.Alert.Description.internal_error:
      u = "Internal error.";
      break;
    case tls$1.Alert.Description.user_canceled:
      u = "User canceled.";
      break;
    case tls$1.Alert.Description.no_renegotiation:
      u = "Renegotiation not supported.";
      break;
    default:
      u = "Unknown error.";
      break;
  }
  if (n.description === tls$1.Alert.Description.close_notify)
    return e.close();
  e.error(e, {
    message: u,
    send: !1,
    // origin is the opposite end
    origin: e.entity === tls$1.ConnectionEnd.client ? "server" : "client",
    alert: n
  }), e.process();
};
tls$1.handleHandshake = function(e, t) {
  var a = t.fragment, n = a.getByte(), u = a.getInt24();
  if (u > a.length())
    return e.fragmented = t, t.fragment = forge$9.util.createBuffer(), a.read -= 4, e.process();
  e.fragmented = null, a.read -= 4;
  var o = a.bytes(u + 4);
  a.read += 4, n in hsTable[e.entity][e.expect] ? (e.entity === tls$1.ConnectionEnd.server && !e.open && !e.fail && (e.handshaking = !0, e.session = {
    version: null,
    extensions: {
      server_name: {
        serverNameList: []
      }
    },
    cipherSuite: null,
    compressionMethod: null,
    serverCertificate: null,
    clientCertificate: null,
    md5: forge$9.md.md5.create(),
    sha1: forge$9.md.sha1.create()
  }), n !== tls$1.HandshakeType.hello_request && n !== tls$1.HandshakeType.certificate_verify && n !== tls$1.HandshakeType.finished && (e.session.md5.update(o), e.session.sha1.update(o)), hsTable[e.entity][e.expect][n](e, t, u)) : tls$1.handleUnexpected(e, t);
};
tls$1.handleApplicationData = function(e, t) {
  e.data.putBuffer(t.fragment), e.dataReady(e), e.process();
};
tls$1.handleHeartbeat = function(e, t) {
  var a = t.fragment, n = a.getByte(), u = a.getInt16(), o = a.getBytes(u);
  if (n === tls$1.HeartbeatMessageType.heartbeat_request) {
    if (e.handshaking || u > o.length)
      return e.process();
    tls$1.queue(e, tls$1.createRecord(e, {
      type: tls$1.ContentType.heartbeat,
      data: tls$1.createHeartbeat(
        tls$1.HeartbeatMessageType.heartbeat_response,
        o
      )
    })), tls$1.flush(e);
  } else if (n === tls$1.HeartbeatMessageType.heartbeat_response) {
    if (o !== e.expectedHeartbeatPayload)
      return e.process();
    e.heartbeatReceived && e.heartbeatReceived(e, forge$9.util.createBuffer(o));
  }
  e.process();
};
var SHE = 0, SCE = 1, SKE = 2, SCR = 3, SHD = 4, SCC = 5, SFI = 6, SAD = 7, SER = 8, CHE = 0, CCE = 1, CKE = 2, CCV = 3, CCC = 4, CFI = 5, CAD = 6, __ = tls$1.handleUnexpected, R0 = tls$1.handleChangeCipherSpec, R1 = tls$1.handleAlert, R2 = tls$1.handleHandshake, R3 = tls$1.handleApplicationData, R4 = tls$1.handleHeartbeat, ctTable = [];
ctTable[tls$1.ConnectionEnd.client] = [
  //      CC,AL,HS,AD,HB
  /*SHE*/
  [__, R1, R2, __, R4],
  /*SCE*/
  [__, R1, R2, __, R4],
  /*SKE*/
  [__, R1, R2, __, R4],
  /*SCR*/
  [__, R1, R2, __, R4],
  /*SHD*/
  [__, R1, R2, __, R4],
  /*SCC*/
  [R0, R1, __, __, R4],
  /*SFI*/
  [__, R1, R2, __, R4],
  /*SAD*/
  [__, R1, R2, R3, R4],
  /*SER*/
  [__, R1, R2, __, R4]
];
ctTable[tls$1.ConnectionEnd.server] = [
  //      CC,AL,HS,AD
  /*CHE*/
  [__, R1, R2, __, R4],
  /*CCE*/
  [__, R1, R2, __, R4],
  /*CKE*/
  [__, R1, R2, __, R4],
  /*CCV*/
  [__, R1, R2, __, R4],
  /*CCC*/
  [R0, R1, __, __, R4],
  /*CFI*/
  [__, R1, R2, __, R4],
  /*CAD*/
  [__, R1, R2, R3, R4],
  /*CER*/
  [__, R1, R2, __, R4]
];
var H0 = tls$1.handleHelloRequest, H1 = tls$1.handleServerHello, H2 = tls$1.handleCertificate, H3 = tls$1.handleServerKeyExchange, H4 = tls$1.handleCertificateRequest, H5 = tls$1.handleServerHelloDone, H6 = tls$1.handleFinished, hsTable = [];
hsTable[tls$1.ConnectionEnd.client] = [
  //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
  /*SHE*/
  [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*SCE*/
  [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
  /*SKE*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
  /*SCR*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
  /*SHD*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
  /*SCC*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*SFI*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
  /*SAD*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*SER*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
];
var H7 = tls$1.handleClientHello, H8 = tls$1.handleClientKeyExchange, H9 = tls$1.handleCertificateVerify;
hsTable[tls$1.ConnectionEnd.server] = [
  //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
  /*CHE*/
  [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*CCE*/
  [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
  /*CKE*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
  /*CCV*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
  /*CCC*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*CFI*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
  /*CAD*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*CER*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
];
tls$1.generateKeys = function(e, t) {
  var a = prf_TLS1, n = t.client_random + t.server_random;
  e.session.resuming || (t.master_secret = a(
    t.pre_master_secret,
    "master secret",
    n,
    48
  ).bytes(), t.pre_master_secret = null), n = t.server_random + t.client_random;
  var u = 2 * t.mac_key_length + 2 * t.enc_key_length, o = e.version.major === tls$1.Versions.TLS_1_0.major && e.version.minor === tls$1.Versions.TLS_1_0.minor;
  o && (u += 2 * t.fixed_iv_length);
  var l = a(t.master_secret, "key expansion", n, u), h = {
    client_write_MAC_key: l.getBytes(t.mac_key_length),
    server_write_MAC_key: l.getBytes(t.mac_key_length),
    client_write_key: l.getBytes(t.enc_key_length),
    server_write_key: l.getBytes(t.enc_key_length)
  };
  return o && (h.client_write_IV = l.getBytes(t.fixed_iv_length), h.server_write_IV = l.getBytes(t.fixed_iv_length)), h;
};
tls$1.createConnectionState = function(e) {
  var t = e.entity === tls$1.ConnectionEnd.client, a = function() {
    var o = {
      // two 32-bit numbers, first is most significant
      sequenceNumber: [0, 0],
      macKey: null,
      macLength: 0,
      macFunction: null,
      cipherState: null,
      cipherFunction: function(l) {
        return !0;
      },
      compressionState: null,
      compressFunction: function(l) {
        return !0;
      },
      updateSequenceNumber: function() {
        o.sequenceNumber[1] === 4294967295 ? (o.sequenceNumber[1] = 0, ++o.sequenceNumber[0]) : ++o.sequenceNumber[1];
      }
    };
    return o;
  }, n = {
    read: a(),
    write: a()
  };
  if (n.read.update = function(o, l) {
    return n.read.cipherFunction(l, n.read) ? n.read.compressFunction(o, l, n.read) || o.error(o, {
      message: "Could not decompress record.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.decompression_failure
      }
    }) : o.error(o, {
      message: "Could not decrypt record or bad MAC.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        // doesn't matter if decryption failed or MAC was
        // invalid, return the same error so as not to reveal
        // which one occurred
        description: tls$1.Alert.Description.bad_record_mac
      }
    }), !o.fail;
  }, n.write.update = function(o, l) {
    return n.write.compressFunction(o, l, n.write) ? n.write.cipherFunction(l, n.write) || o.error(o, {
      message: "Could not encrypt record.",
      send: !1,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.internal_error
      }
    }) : o.error(o, {
      message: "Could not compress record.",
      send: !1,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.internal_error
      }
    }), !o.fail;
  }, e.session) {
    var u = e.session.sp;
    switch (e.session.cipherSuite.initSecurityParameters(u), u.keys = tls$1.generateKeys(e, u), n.read.macKey = t ? u.keys.server_write_MAC_key : u.keys.client_write_MAC_key, n.write.macKey = t ? u.keys.client_write_MAC_key : u.keys.server_write_MAC_key, e.session.cipherSuite.initConnectionState(n, e, u), u.compression_algorithm) {
      case tls$1.CompressionMethod.none:
        break;
      case tls$1.CompressionMethod.deflate:
        n.read.compressFunction = inflate, n.write.compressFunction = deflate;
        break;
      default:
        throw new Error("Unsupported compression algorithm.");
    }
  }
  return n;
};
tls$1.createRandom = function() {
  var e = /* @__PURE__ */ new Date(), t = +e + e.getTimezoneOffset() * 6e4, a = forge$9.util.createBuffer();
  return a.putInt32(t), a.putBytes(forge$9.random.getBytes(28)), a;
};
tls$1.createRecord = function(e, t) {
  if (!t.data)
    return null;
  var a = {
    type: t.type,
    version: {
      major: e.version.major,
      minor: e.version.minor
    },
    length: t.data.length(),
    fragment: t.data
  };
  return a;
};
tls$1.createAlert = function(e, t) {
  var a = forge$9.util.createBuffer();
  return a.putByte(t.level), a.putByte(t.description), tls$1.createRecord(e, {
    type: tls$1.ContentType.alert,
    data: a
  });
};
tls$1.createClientHello = function(e) {
  e.session.clientHelloVersion = {
    major: e.version.major,
    minor: e.version.minor
  };
  for (var t = forge$9.util.createBuffer(), a = 0; a < e.cipherSuites.length; ++a) {
    var n = e.cipherSuites[a];
    t.putByte(n.id[0]), t.putByte(n.id[1]);
  }
  var u = t.length(), o = forge$9.util.createBuffer();
  o.putByte(tls$1.CompressionMethod.none);
  var l = o.length(), h = forge$9.util.createBuffer();
  if (e.virtualHost) {
    var y = forge$9.util.createBuffer();
    y.putByte(0), y.putByte(0);
    var _ = forge$9.util.createBuffer();
    _.putByte(0), writeVector(_, 2, forge$9.util.createBuffer(e.virtualHost));
    var d = forge$9.util.createBuffer();
    writeVector(d, 2, _), writeVector(y, 2, d), h.putBuffer(y);
  }
  var $ = h.length();
  $ > 0 && ($ += 2);
  var N = e.session.id, U = N.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + u + // cipher suites vector
  1 + l + // compression methods vector
  $, V = forge$9.util.createBuffer();
  return V.putByte(tls$1.HandshakeType.client_hello), V.putInt24(U), V.putByte(e.version.major), V.putByte(e.version.minor), V.putBytes(e.session.sp.client_random), writeVector(V, 1, forge$9.util.createBuffer(N)), writeVector(V, 2, t), writeVector(V, 1, o), $ > 0 && writeVector(V, 2, h), V;
};
tls$1.createServerHello = function(e) {
  var t = e.session.id, a = t.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + // chosen cipher suite
  1, n = forge$9.util.createBuffer();
  return n.putByte(tls$1.HandshakeType.server_hello), n.putInt24(a), n.putByte(e.version.major), n.putByte(e.version.minor), n.putBytes(e.session.sp.server_random), writeVector(n, 1, forge$9.util.createBuffer(t)), n.putByte(e.session.cipherSuite.id[0]), n.putByte(e.session.cipherSuite.id[1]), n.putByte(e.session.compressionMethod), n;
};
tls$1.createCertificate = function(e) {
  var t = e.entity === tls$1.ConnectionEnd.client, a = null;
  if (e.getCertificate) {
    var n;
    t ? n = e.session.certificateRequest : n = e.session.extensions.server_name.serverNameList, a = e.getCertificate(e, n);
  }
  var u = forge$9.util.createBuffer();
  if (a !== null)
    try {
      forge$9.util.isArray(a) || (a = [a]);
      for (var o = null, l = 0; l < a.length; ++l) {
        var h = forge$9.pem.decode(a[l])[0];
        if (h.type !== "CERTIFICATE" && h.type !== "X509 CERTIFICATE" && h.type !== "TRUSTED CERTIFICATE") {
          var y = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
          throw y.headerType = h.type, y;
        }
        if (h.procType && h.procType.type === "ENCRYPTED")
          throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
        var _ = forge$9.util.createBuffer(h.body);
        o === null && (o = forge$9.asn1.fromDer(_.bytes(), !1));
        var d = forge$9.util.createBuffer();
        writeVector(d, 3, _), u.putBuffer(d);
      }
      a = forge$9.pki.certificateFromAsn1(o), t ? e.session.clientCertificate = a : e.session.serverCertificate = a;
    } catch (U) {
      return e.error(e, {
        message: "Could not send certificate list.",
        cause: U,
        send: !0,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.bad_certificate
        }
      });
    }
  var $ = 3 + u.length(), N = forge$9.util.createBuffer();
  return N.putByte(tls$1.HandshakeType.certificate), N.putInt24($), writeVector(N, 3, u), N;
};
tls$1.createClientKeyExchange = function(e) {
  var t = forge$9.util.createBuffer();
  t.putByte(e.session.clientHelloVersion.major), t.putByte(e.session.clientHelloVersion.minor), t.putBytes(forge$9.random.getBytes(46));
  var a = e.session.sp;
  a.pre_master_secret = t.getBytes();
  var n = e.session.serverCertificate.publicKey;
  t = n.encrypt(a.pre_master_secret);
  var u = t.length + 2, o = forge$9.util.createBuffer();
  return o.putByte(tls$1.HandshakeType.client_key_exchange), o.putInt24(u), o.putInt16(t.length), o.putBytes(t), o;
};
tls$1.createServerKeyExchange = function(e) {
  var t = forge$9.util.createBuffer();
  return t;
};
tls$1.getClientSignature = function(e, t) {
  var a = forge$9.util.createBuffer();
  a.putBuffer(e.session.md5.digest()), a.putBuffer(e.session.sha1.digest()), a = a.getBytes(), e.getSignature = e.getSignature || function(n, u, o) {
    var l = null;
    if (n.getPrivateKey)
      try {
        l = n.getPrivateKey(n, n.session.clientCertificate), l = forge$9.pki.privateKeyFromPem(l);
      } catch (h) {
        n.error(n, {
          message: "Could not get private key.",
          cause: h,
          send: !0,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.internal_error
          }
        });
      }
    l === null ? n.error(n, {
      message: "No private key set.",
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.internal_error
      }
    }) : u = l.sign(u, null), o(n, u);
  }, e.getSignature(e, a, t);
};
tls$1.createCertificateVerify = function(e, t) {
  var a = t.length + 2, n = forge$9.util.createBuffer();
  return n.putByte(tls$1.HandshakeType.certificate_verify), n.putInt24(a), n.putInt16(t.length), n.putBytes(t), n;
};
tls$1.createCertificateRequest = function(e) {
  var t = forge$9.util.createBuffer();
  t.putByte(1);
  var a = forge$9.util.createBuffer();
  for (var n in e.caStore.certs) {
    var u = e.caStore.certs[n], o = forge$9.pki.distinguishedNameToAsn1(u.subject), l = forge$9.asn1.toDer(o);
    a.putInt16(l.length()), a.putBuffer(l);
  }
  var h = 1 + t.length() + 2 + a.length(), y = forge$9.util.createBuffer();
  return y.putByte(tls$1.HandshakeType.certificate_request), y.putInt24(h), writeVector(y, 1, t), writeVector(y, 2, a), y;
};
tls$1.createServerHelloDone = function(e) {
  var t = forge$9.util.createBuffer();
  return t.putByte(tls$1.HandshakeType.server_hello_done), t.putInt24(0), t;
};
tls$1.createChangeCipherSpec = function() {
  var e = forge$9.util.createBuffer();
  return e.putByte(1), e;
};
tls$1.createFinished = function(e) {
  var t = forge$9.util.createBuffer();
  t.putBuffer(e.session.md5.digest()), t.putBuffer(e.session.sha1.digest());
  var a = e.entity === tls$1.ConnectionEnd.client, n = e.session.sp, u = 12, o = prf_TLS1, l = a ? "client finished" : "server finished";
  t = o(n.master_secret, l, t.getBytes(), u);
  var h = forge$9.util.createBuffer();
  return h.putByte(tls$1.HandshakeType.finished), h.putInt24(t.length()), h.putBuffer(t), h;
};
tls$1.createHeartbeat = function(e, t, a) {
  typeof a > "u" && (a = t.length);
  var n = forge$9.util.createBuffer();
  n.putByte(e), n.putInt16(a), n.putBytes(t);
  var u = n.length(), o = Math.max(16, u - a - 3);
  return n.putBytes(forge$9.random.getBytes(o)), n;
};
tls$1.queue = function(e, t) {
  if (t && !(t.fragment.length() === 0 && (t.type === tls$1.ContentType.handshake || t.type === tls$1.ContentType.alert || t.type === tls$1.ContentType.change_cipher_spec))) {
    if (t.type === tls$1.ContentType.handshake) {
      var a = t.fragment.bytes();
      e.session.md5.update(a), e.session.sha1.update(a), a = null;
    }
    var n;
    if (t.fragment.length() <= tls$1.MaxFragment)
      n = [t];
    else {
      n = [];
      for (var u = t.fragment.bytes(); u.length > tls$1.MaxFragment; )
        n.push(tls$1.createRecord(e, {
          type: t.type,
          data: forge$9.util.createBuffer(u.slice(0, tls$1.MaxFragment))
        })), u = u.slice(tls$1.MaxFragment);
      u.length > 0 && n.push(tls$1.createRecord(e, {
        type: t.type,
        data: forge$9.util.createBuffer(u)
      }));
    }
    for (var o = 0; o < n.length && !e.fail; ++o) {
      var l = n[o], h = e.state.current.write;
      h.update(e, l) && e.records.push(l);
    }
  }
};
tls$1.flush = function(e) {
  for (var t = 0; t < e.records.length; ++t) {
    var a = e.records[t];
    e.tlsData.putByte(a.type), e.tlsData.putByte(a.version.major), e.tlsData.putByte(a.version.minor), e.tlsData.putInt16(a.fragment.length()), e.tlsData.putBuffer(e.records[t].fragment);
  }
  return e.records = [], e.tlsDataReady(e);
};
var _certErrorToAlertDesc = function(e) {
  switch (e) {
    case !0:
      return !0;
    case forge$9.pki.certificateError.bad_certificate:
      return tls$1.Alert.Description.bad_certificate;
    case forge$9.pki.certificateError.unsupported_certificate:
      return tls$1.Alert.Description.unsupported_certificate;
    case forge$9.pki.certificateError.certificate_revoked:
      return tls$1.Alert.Description.certificate_revoked;
    case forge$9.pki.certificateError.certificate_expired:
      return tls$1.Alert.Description.certificate_expired;
    case forge$9.pki.certificateError.certificate_unknown:
      return tls$1.Alert.Description.certificate_unknown;
    case forge$9.pki.certificateError.unknown_ca:
      return tls$1.Alert.Description.unknown_ca;
    default:
      return tls$1.Alert.Description.bad_certificate;
  }
}, _alertDescToCertError = function(e) {
  switch (e) {
    case !0:
      return !0;
    case tls$1.Alert.Description.bad_certificate:
      return forge$9.pki.certificateError.bad_certificate;
    case tls$1.Alert.Description.unsupported_certificate:
      return forge$9.pki.certificateError.unsupported_certificate;
    case tls$1.Alert.Description.certificate_revoked:
      return forge$9.pki.certificateError.certificate_revoked;
    case tls$1.Alert.Description.certificate_expired:
      return forge$9.pki.certificateError.certificate_expired;
    case tls$1.Alert.Description.certificate_unknown:
      return forge$9.pki.certificateError.certificate_unknown;
    case tls$1.Alert.Description.unknown_ca:
      return forge$9.pki.certificateError.unknown_ca;
    default:
      return forge$9.pki.certificateError.bad_certificate;
  }
};
tls$1.verifyCertificateChain = function(e, t) {
  try {
    var a = {};
    for (var n in e.verifyOptions)
      a[n] = e.verifyOptions[n];
    a.verify = function(o, l, h) {
      var y = _certErrorToAlertDesc(o), _ = e.verify(e, o, l, h);
      if (_ !== !0) {
        if (typeof _ == "object" && !forge$9.util.isArray(_)) {
          var d = new Error("The application rejected the certificate.");
          throw d.send = !0, d.alert = {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.bad_certificate
          }, _.message && (d.message = _.message), _.alert && (d.alert.description = _.alert), d;
        }
        _ !== o && (_ = _alertDescToCertError(_));
      }
      return _;
    }, forge$9.pki.verifyCertificateChain(e.caStore, t, a);
  } catch (o) {
    var u = o;
    (typeof u != "object" || forge$9.util.isArray(u)) && (u = {
      send: !0,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: _certErrorToAlertDesc(o)
      }
    }), "send" in u || (u.send = !0), "alert" in u || (u.alert = {
      level: tls$1.Alert.Level.fatal,
      description: _certErrorToAlertDesc(u.error)
    }), e.error(e, u);
  }
  return !e.fail;
};
tls$1.createSessionCache = function(e, t) {
  var a = null;
  if (e && e.getSession && e.setSession && e.order)
    a = e;
  else {
    a = {}, a.cache = e || {}, a.capacity = Math.max(t || 100, 1), a.order = [];
    for (var n in e)
      a.order.length <= t ? a.order.push(n) : delete e[n];
    a.getSession = function(u) {
      var o = null, l = null;
      if (u ? l = forge$9.util.bytesToHex(u) : a.order.length > 0 && (l = a.order[0]), l !== null && l in a.cache) {
        o = a.cache[l], delete a.cache[l];
        for (var h in a.order)
          if (a.order[h] === l) {
            a.order.splice(h, 1);
            break;
          }
      }
      return o;
    }, a.setSession = function(u, o) {
      if (a.order.length === a.capacity) {
        var l = a.order.shift();
        delete a.cache[l];
      }
      var l = forge$9.util.bytesToHex(u);
      a.order.push(l), a.cache[l] = o;
    };
  }
  return a;
};
tls$1.createConnection = function(e) {
  var t = null;
  e.caStore ? forge$9.util.isArray(e.caStore) ? t = forge$9.pki.createCaStore(e.caStore) : t = e.caStore : t = forge$9.pki.createCaStore();
  var a = e.cipherSuites || null;
  if (a === null) {
    a = [];
    for (var n in tls$1.CipherSuites)
      a.push(tls$1.CipherSuites[n]);
  }
  var u = e.server ? tls$1.ConnectionEnd.server : tls$1.ConnectionEnd.client, o = e.sessionCache ? tls$1.createSessionCache(e.sessionCache) : null, l = {
    version: { major: tls$1.Version.major, minor: tls$1.Version.minor },
    entity: u,
    sessionId: e.sessionId,
    caStore: t,
    sessionCache: o,
    cipherSuites: a,
    connected: e.connected,
    virtualHost: e.virtualHost || null,
    verifyClient: e.verifyClient || !1,
    verify: e.verify || function(d, $, N, U) {
      return $;
    },
    verifyOptions: e.verifyOptions || {},
    getCertificate: e.getCertificate || null,
    getPrivateKey: e.getPrivateKey || null,
    getSignature: e.getSignature || null,
    input: forge$9.util.createBuffer(),
    tlsData: forge$9.util.createBuffer(),
    data: forge$9.util.createBuffer(),
    tlsDataReady: e.tlsDataReady,
    dataReady: e.dataReady,
    heartbeatReceived: e.heartbeatReceived,
    closed: e.closed,
    error: function(d, $) {
      $.origin = $.origin || (d.entity === tls$1.ConnectionEnd.client ? "client" : "server"), $.send && (tls$1.queue(d, tls$1.createAlert(d, $.alert)), tls$1.flush(d));
      var N = $.fatal !== !1;
      N && (d.fail = !0), e.error(d, $), N && d.close(!1);
    },
    deflate: e.deflate || null,
    inflate: e.inflate || null
  };
  l.reset = function(d) {
    l.version = { major: tls$1.Version.major, minor: tls$1.Version.minor }, l.record = null, l.session = null, l.peerCertificate = null, l.state = {
      pending: null,
      current: null
    }, l.expect = l.entity === tls$1.ConnectionEnd.client ? SHE : CHE, l.fragmented = null, l.records = [], l.open = !1, l.handshakes = 0, l.handshaking = !1, l.isConnected = !1, l.fail = !(d || typeof d > "u"), l.input.clear(), l.tlsData.clear(), l.data.clear(), l.state.current = tls$1.createConnectionState(l);
  }, l.reset();
  var h = function(d, $) {
    var N = $.type - tls$1.ContentType.change_cipher_spec, U = ctTable[d.entity][d.expect];
    N in U ? U[N](d, $) : tls$1.handleUnexpected(d, $);
  }, y = function(d) {
    var $ = 0, N = d.input, U = N.length();
    if (U < 5)
      $ = 5 - U;
    else {
      d.record = {
        type: N.getByte(),
        version: {
          major: N.getByte(),
          minor: N.getByte()
        },
        length: N.getInt16(),
        fragment: forge$9.util.createBuffer(),
        ready: !1
      };
      var V = d.record.version.major === d.version.major;
      V && d.session && d.session.version && (V = d.record.version.minor === d.version.minor), V || d.error(d, {
        message: "Incompatible TLS version.",
        send: !0,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.protocol_version
        }
      });
    }
    return $;
  }, _ = function(d) {
    var $ = 0, N = d.input, U = N.length();
    if (U < d.record.length)
      $ = d.record.length - U;
    else {
      d.record.fragment.putBytes(N.getBytes(d.record.length)), N.compact();
      var V = d.state.current.read;
      V.update(d, d.record) && (d.fragmented !== null && (d.fragmented.type === d.record.type ? (d.fragmented.fragment.putBuffer(d.record.fragment), d.record = d.fragmented) : d.error(d, {
        message: "Invalid fragmented record.",
        send: !0,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.unexpected_message
        }
      })), d.record.ready = !0);
    }
    return $;
  };
  return l.handshake = function(d) {
    if (l.entity !== tls$1.ConnectionEnd.client)
      l.error(l, {
        message: "Cannot initiate handshake as a server.",
        fatal: !1
      });
    else if (l.handshaking)
      l.error(l, {
        message: "Handshake already in progress.",
        fatal: !1
      });
    else {
      l.fail && !l.open && l.handshakes === 0 && (l.fail = !1), l.handshaking = !0, d = d || "";
      var $ = null;
      d.length > 0 && (l.sessionCache && ($ = l.sessionCache.getSession(d)), $ === null && (d = "")), d.length === 0 && l.sessionCache && ($ = l.sessionCache.getSession(), $ !== null && (d = $.id)), l.session = {
        id: d,
        version: null,
        cipherSuite: null,
        compressionMethod: null,
        serverCertificate: null,
        certificateRequest: null,
        clientCertificate: null,
        sp: {},
        md5: forge$9.md.md5.create(),
        sha1: forge$9.md.sha1.create()
      }, $ && (l.version = $.version, l.session.sp = $.sp), l.session.sp.client_random = tls$1.createRandom().getBytes(), l.open = !0, tls$1.queue(l, tls$1.createRecord(l, {
        type: tls$1.ContentType.handshake,
        data: tls$1.createClientHello(l)
      })), tls$1.flush(l);
    }
  }, l.process = function(d) {
    var $ = 0;
    return d && l.input.putBytes(d), l.fail || (l.record !== null && l.record.ready && l.record.fragment.isEmpty() && (l.record = null), l.record === null && ($ = y(l)), !l.fail && l.record !== null && !l.record.ready && ($ = _(l)), !l.fail && l.record !== null && l.record.ready && h(l, l.record)), $;
  }, l.prepare = function(d) {
    return tls$1.queue(l, tls$1.createRecord(l, {
      type: tls$1.ContentType.application_data,
      data: forge$9.util.createBuffer(d)
    })), tls$1.flush(l);
  }, l.prepareHeartbeatRequest = function(d, $) {
    return d instanceof forge$9.util.ByteBuffer && (d = d.bytes()), typeof $ > "u" && ($ = d.length), l.expectedHeartbeatPayload = d, tls$1.queue(l, tls$1.createRecord(l, {
      type: tls$1.ContentType.heartbeat,
      data: tls$1.createHeartbeat(
        tls$1.HeartbeatMessageType.heartbeat_request,
        d,
        $
      )
    })), tls$1.flush(l);
  }, l.close = function(d) {
    if (!l.fail && l.sessionCache && l.session) {
      var $ = {
        id: l.session.id,
        version: l.session.version,
        sp: l.session.sp
      };
      $.sp.keys = null, l.sessionCache.setSession($.id, $);
    }
    l.open && (l.open = !1, l.input.clear(), (l.isConnected || l.handshaking) && (l.isConnected = l.handshaking = !1, tls$1.queue(l, tls$1.createAlert(l, {
      level: tls$1.Alert.Level.warning,
      description: tls$1.Alert.Description.close_notify
    })), tls$1.flush(l)), l.closed(l)), l.reset(d);
  }, l;
};
forge$9.tls = forge$9.tls || {};
for (var key in tls$1)
  typeof tls$1[key] != "function" && (forge$9.tls[key] = tls$1[key]);
forge$9.tls.prf_tls1 = prf_TLS1;
forge$9.tls.hmac_sha1 = hmac_sha1;
forge$9.tls.createSessionCache = tls$1.createSessionCache;
forge$9.tls.createConnection = tls$1.createConnection;
var forge$8 = forge$D, tls = forge$8.tls;
tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
  id: [0, 47],
  name: "TLS_RSA_WITH_AES_128_CBC_SHA",
  initSecurityParameters: function(e) {
    e.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes, e.cipher_type = tls.CipherType.block, e.enc_key_length = 16, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = tls.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
  },
  initConnectionState
};
tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
  id: [0, 53],
  name: "TLS_RSA_WITH_AES_256_CBC_SHA",
  initSecurityParameters: function(e) {
    e.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes, e.cipher_type = tls.CipherType.block, e.enc_key_length = 32, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = tls.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
  },
  initConnectionState
};
function initConnectionState(e, t, a) {
  var n = t.entity === forge$8.tls.ConnectionEnd.client;
  e.read.cipherState = {
    init: !1,
    cipher: forge$8.cipher.createDecipher("AES-CBC", n ? a.keys.server_write_key : a.keys.client_write_key),
    iv: n ? a.keys.server_write_IV : a.keys.client_write_IV
  }, e.write.cipherState = {
    init: !1,
    cipher: forge$8.cipher.createCipher("AES-CBC", n ? a.keys.client_write_key : a.keys.server_write_key),
    iv: n ? a.keys.client_write_IV : a.keys.server_write_IV
  }, e.read.cipherFunction = decrypt_aes_cbc_sha1, e.write.cipherFunction = encrypt_aes_cbc_sha1, e.read.macLength = e.write.macLength = a.mac_length, e.read.macFunction = e.write.macFunction = tls.hmac_sha1;
}
function encrypt_aes_cbc_sha1(e, t) {
  var a = !1, n = t.macFunction(t.macKey, t.sequenceNumber, e);
  e.fragment.putBytes(n), t.updateSequenceNumber();
  var u;
  e.version.minor === tls.Versions.TLS_1_0.minor ? u = t.cipherState.init ? null : t.cipherState.iv : u = forge$8.random.getBytesSync(16), t.cipherState.init = !0;
  var o = t.cipherState.cipher;
  return o.start({ iv: u }), e.version.minor >= tls.Versions.TLS_1_1.minor && o.output.putBytes(u), o.update(e.fragment), o.finish(encrypt_aes_cbc_sha1_padding) && (e.fragment = o.output, e.length = e.fragment.length(), a = !0), a;
}
function encrypt_aes_cbc_sha1_padding(e, t, a) {
  if (!a) {
    var n = e - t.length() % e;
    t.fillWithByte(n - 1, n);
  }
  return !0;
}
function decrypt_aes_cbc_sha1_padding(e, t, a) {
  var n = !0;
  if (a) {
    for (var u = t.length(), o = t.last(), l = u - 1 - o; l < u - 1; ++l)
      n = n && t.at(l) == o;
    n && t.truncate(o + 1);
  }
  return n;
}
function decrypt_aes_cbc_sha1(e, t) {
  var a = !1, n;
  e.version.minor === tls.Versions.TLS_1_0.minor ? n = t.cipherState.init ? null : t.cipherState.iv : n = e.fragment.getBytes(16), t.cipherState.init = !0;
  var u = t.cipherState.cipher;
  u.start({ iv: n }), u.update(e.fragment), a = u.finish(decrypt_aes_cbc_sha1_padding);
  var o = t.macLength, l = forge$8.random.getBytesSync(o), h = u.output.length();
  h >= o ? (e.fragment = u.output.getBytes(h - o), l = u.output.getBytes(o)) : e.fragment = u.output.getBytes(), e.fragment = forge$8.util.createBuffer(e.fragment), e.length = e.fragment.length();
  var y = t.macFunction(t.macKey, t.sequenceNumber, e);
  return t.updateSequenceNumber(), a = compareMacs(t.macKey, l, y) && a, a;
}
function compareMacs(e, t, a) {
  var n = forge$8.hmac.create();
  return n.start("SHA1", e), n.update(t), t = n.digest().getBytes(), n.start(null, null), n.update(a), a = n.digest().getBytes(), t === a;
}
var forge$7 = forge$D, sha512$1 = forge$7.sha512 = forge$7.sha512 || {};
forge$7.md.sha512 = forge$7.md.algorithms.sha512 = sha512$1;
var sha384 = forge$7.sha384 = forge$7.sha512.sha384 = forge$7.sha512.sha384 || {};
sha384.create = function() {
  return sha512$1.create("SHA-384");
};
forge$7.md.sha384 = forge$7.md.algorithms.sha384 = sha384;
forge$7.sha512.sha256 = forge$7.sha512.sha256 || {
  create: function() {
    return sha512$1.create("SHA-512/256");
  }
};
forge$7.md["sha512/256"] = forge$7.md.algorithms["sha512/256"] = forge$7.sha512.sha256;
forge$7.sha512.sha224 = forge$7.sha512.sha224 || {
  create: function() {
    return sha512$1.create("SHA-512/224");
  }
};
forge$7.md["sha512/224"] = forge$7.md.algorithms["sha512/224"] = forge$7.sha512.sha224;
sha512$1.create = function(e) {
  if (_initialized || _init(), typeof e > "u" && (e = "SHA-512"), !(e in _states))
    throw new Error("Invalid SHA-512 algorithm: " + e);
  for (var t = _states[e], a = null, n = forge$7.util.createBuffer(), u = new Array(80), o = 0; o < 80; ++o)
    u[o] = new Array(2);
  var l = 64;
  switch (e) {
    case "SHA-384":
      l = 48;
      break;
    case "SHA-512/256":
      l = 32;
      break;
    case "SHA-512/224":
      l = 28;
      break;
  }
  var h = {
    // SHA-512 => sha512
    algorithm: e.replace("-", "").toLowerCase(),
    blockLength: 128,
    digestLength: l,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };
  return h.start = function() {
    h.messageLength = 0, h.fullMessageLength = h.messageLength128 = [];
    for (var y = h.messageLengthSize / 4, _ = 0; _ < y; ++_)
      h.fullMessageLength.push(0);
    n = forge$7.util.createBuffer(), a = new Array(t.length);
    for (var _ = 0; _ < t.length; ++_)
      a[_] = t[_].slice(0);
    return h;
  }, h.start(), h.update = function(y, _) {
    _ === "utf8" && (y = forge$7.util.encodeUtf8(y));
    var d = y.length;
    h.messageLength += d, d = [d / 4294967296 >>> 0, d >>> 0];
    for (var $ = h.fullMessageLength.length - 1; $ >= 0; --$)
      h.fullMessageLength[$] += d[1], d[1] = d[0] + (h.fullMessageLength[$] / 4294967296 >>> 0), h.fullMessageLength[$] = h.fullMessageLength[$] >>> 0, d[0] = d[1] / 4294967296 >>> 0;
    return n.putBytes(y), _update(a, u, n), (n.read > 2048 || n.length() === 0) && n.compact(), h;
  }, h.digest = function() {
    var y = forge$7.util.createBuffer();
    y.putBytes(n.bytes());
    var _ = h.fullMessageLength[h.fullMessageLength.length - 1] + h.messageLengthSize, d = _ & h.blockLength - 1;
    y.putBytes(_padding.substr(0, h.blockLength - d));
    for (var $, N, U = h.fullMessageLength[0] * 8, V = 0; V < h.fullMessageLength.length - 1; ++V)
      $ = h.fullMessageLength[V + 1] * 8, N = $ / 4294967296 >>> 0, U += N, y.putInt32(U >>> 0), U = $ >>> 0;
    y.putInt32(U);
    for (var Q = new Array(a.length), V = 0; V < a.length; ++V)
      Q[V] = a[V].slice(0);
    _update(Q, u, y);
    var ie = forge$7.util.createBuffer(), ee;
    e === "SHA-512" ? ee = Q.length : e === "SHA-384" ? ee = Q.length - 2 : ee = Q.length - 4;
    for (var V = 0; V < ee; ++V)
      ie.putInt32(Q[V][0]), (V !== ee - 1 || e !== "SHA-512/224") && ie.putInt32(Q[V][1]);
    return ie;
  }, h;
};
var _padding = null, _initialized = !1, _k = null, _states = null;
function _init() {
  _padding = String.fromCharCode(128), _padding += forge$7.util.fillString(String.fromCharCode(0), 128), _k = [
    [1116352408, 3609767458],
    [1899447441, 602891725],
    [3049323471, 3964484399],
    [3921009573, 2173295548],
    [961987163, 4081628472],
    [1508970993, 3053834265],
    [2453635748, 2937671579],
    [2870763221, 3664609560],
    [3624381080, 2734883394],
    [310598401, 1164996542],
    [607225278, 1323610764],
    [1426881987, 3590304994],
    [1925078388, 4068182383],
    [2162078206, 991336113],
    [2614888103, 633803317],
    [3248222580, 3479774868],
    [3835390401, 2666613458],
    [4022224774, 944711139],
    [264347078, 2341262773],
    [604807628, 2007800933],
    [770255983, 1495990901],
    [1249150122, 1856431235],
    [1555081692, 3175218132],
    [1996064986, 2198950837],
    [2554220882, 3999719339],
    [2821834349, 766784016],
    [2952996808, 2566594879],
    [3210313671, 3203337956],
    [3336571891, 1034457026],
    [3584528711, 2466948901],
    [113926993, 3758326383],
    [338241895, 168717936],
    [666307205, 1188179964],
    [773529912, 1546045734],
    [1294757372, 1522805485],
    [1396182291, 2643833823],
    [1695183700, 2343527390],
    [1986661051, 1014477480],
    [2177026350, 1206759142],
    [2456956037, 344077627],
    [2730485921, 1290863460],
    [2820302411, 3158454273],
    [3259730800, 3505952657],
    [3345764771, 106217008],
    [3516065817, 3606008344],
    [3600352804, 1432725776],
    [4094571909, 1467031594],
    [275423344, 851169720],
    [430227734, 3100823752],
    [506948616, 1363258195],
    [659060556, 3750685593],
    [883997877, 3785050280],
    [958139571, 3318307427],
    [1322822218, 3812723403],
    [1537002063, 2003034995],
    [1747873779, 3602036899],
    [1955562222, 1575990012],
    [2024104815, 1125592928],
    [2227730452, 2716904306],
    [2361852424, 442776044],
    [2428436474, 593698344],
    [2756734187, 3733110249],
    [3204031479, 2999351573],
    [3329325298, 3815920427],
    [3391569614, 3928383900],
    [3515267271, 566280711],
    [3940187606, 3454069534],
    [4118630271, 4000239992],
    [116418474, 1914138554],
    [174292421, 2731055270],
    [289380356, 3203993006],
    [460393269, 320620315],
    [685471733, 587496836],
    [852142971, 1086792851],
    [1017036298, 365543100],
    [1126000580, 2618297676],
    [1288033470, 3409855158],
    [1501505948, 4234509866],
    [1607167915, 987167468],
    [1816402316, 1246189591]
  ], _states = {}, _states["SHA-512"] = [
    [1779033703, 4089235720],
    [3144134277, 2227873595],
    [1013904242, 4271175723],
    [2773480762, 1595750129],
    [1359893119, 2917565137],
    [2600822924, 725511199],
    [528734635, 4215389547],
    [1541459225, 327033209]
  ], _states["SHA-384"] = [
    [3418070365, 3238371032],
    [1654270250, 914150663],
    [2438529370, 812702999],
    [355462360, 4144912697],
    [1731405415, 4290775857],
    [2394180231, 1750603025],
    [3675008525, 1694076839],
    [1203062813, 3204075428]
  ], _states["SHA-512/256"] = [
    [573645204, 4230739756],
    [2673172387, 3360449730],
    [596883563, 1867755857],
    [2520282905, 1497426621],
    [2519219938, 2827943907],
    [3193839141, 1401305490],
    [721525244, 746961066],
    [246885852, 2177182882]
  ], _states["SHA-512/224"] = [
    [2352822216, 424955298],
    [1944164710, 2312950998],
    [502970286, 855612546],
    [1738396948, 1479516111],
    [258812777, 2077511080],
    [2011393907, 79989058],
    [1067287976, 1780299464],
    [286451373, 2446758561]
  ], _initialized = !0;
}
function _update(e, t, a) {
  for (var n, u, o, l, h, y, _, d, $, N, U, V, Q, ie, ee, ne, ge, be, Ee, xe, Le, Ne, Re, Xe, pe, O, E, c, b, C, x, B, k, w, T, p = a.length(); p >= 128; ) {
    for (b = 0; b < 16; ++b)
      t[b][0] = a.getInt32() >>> 0, t[b][1] = a.getInt32() >>> 0;
    for (; b < 80; ++b)
      B = t[b - 2], C = B[0], x = B[1], n = ((C >>> 19 | x << 13) ^ // ROTR 19
      (x >>> 29 | C << 3) ^ // ROTR 61/(swap + ROTR 29)
      C >>> 6) >>> 0, u = ((C << 13 | x >>> 19) ^ // ROTR 19
      (x << 3 | C >>> 29) ^ // ROTR 61/(swap + ROTR 29)
      (C << 26 | x >>> 6)) >>> 0, w = t[b - 15], C = w[0], x = w[1], o = ((C >>> 1 | x << 31) ^ // ROTR 1
      (C >>> 8 | x << 24) ^ // ROTR 8
      C >>> 7) >>> 0, l = ((C << 31 | x >>> 1) ^ // ROTR 1
      (C << 24 | x >>> 8) ^ // ROTR 8
      (C << 25 | x >>> 7)) >>> 0, k = t[b - 7], T = t[b - 16], x = u + k[1] + l + T[1], t[b][0] = n + k[0] + o + T[0] + (x / 4294967296 >>> 0) >>> 0, t[b][1] = x >>> 0;
    for (Q = e[0][0], ie = e[0][1], ee = e[1][0], ne = e[1][1], ge = e[2][0], be = e[2][1], Ee = e[3][0], xe = e[3][1], Le = e[4][0], Ne = e[4][1], Re = e[5][0], Xe = e[5][1], pe = e[6][0], O = e[6][1], E = e[7][0], c = e[7][1], b = 0; b < 80; ++b)
      _ = ((Le >>> 14 | Ne << 18) ^ // ROTR 14
      (Le >>> 18 | Ne << 14) ^ // ROTR 18
      (Ne >>> 9 | Le << 23)) >>> 0, d = ((Le << 18 | Ne >>> 14) ^ // ROTR 14
      (Le << 14 | Ne >>> 18) ^ // ROTR 18
      (Ne << 23 | Le >>> 9)) >>> 0, $ = (pe ^ Le & (Re ^ pe)) >>> 0, N = (O ^ Ne & (Xe ^ O)) >>> 0, h = ((Q >>> 28 | ie << 4) ^ // ROTR 28
      (ie >>> 2 | Q << 30) ^ // ROTR 34/(swap + ROTR 2)
      (ie >>> 7 | Q << 25)) >>> 0, y = ((Q << 4 | ie >>> 28) ^ // ROTR 28
      (ie << 30 | Q >>> 2) ^ // ROTR 34/(swap + ROTR 2)
      (ie << 25 | Q >>> 7)) >>> 0, U = (Q & ee | ge & (Q ^ ee)) >>> 0, V = (ie & ne | be & (ie ^ ne)) >>> 0, x = c + d + N + _k[b][1] + t[b][1], n = E + _ + $ + _k[b][0] + t[b][0] + (x / 4294967296 >>> 0) >>> 0, u = x >>> 0, x = y + V, o = h + U + (x / 4294967296 >>> 0) >>> 0, l = x >>> 0, E = pe, c = O, pe = Re, O = Xe, Re = Le, Xe = Ne, x = xe + u, Le = Ee + n + (x / 4294967296 >>> 0) >>> 0, Ne = x >>> 0, Ee = ge, xe = be, ge = ee, be = ne, ee = Q, ne = ie, x = u + l, Q = n + o + (x / 4294967296 >>> 0) >>> 0, ie = x >>> 0;
    x = e[0][1] + ie, e[0][0] = e[0][0] + Q + (x / 4294967296 >>> 0) >>> 0, e[0][1] = x >>> 0, x = e[1][1] + ne, e[1][0] = e[1][0] + ee + (x / 4294967296 >>> 0) >>> 0, e[1][1] = x >>> 0, x = e[2][1] + be, e[2][0] = e[2][0] + ge + (x / 4294967296 >>> 0) >>> 0, e[2][1] = x >>> 0, x = e[3][1] + xe, e[3][0] = e[3][0] + Ee + (x / 4294967296 >>> 0) >>> 0, e[3][1] = x >>> 0, x = e[4][1] + Ne, e[4][0] = e[4][0] + Le + (x / 4294967296 >>> 0) >>> 0, e[4][1] = x >>> 0, x = e[5][1] + Xe, e[5][0] = e[5][0] + Re + (x / 4294967296 >>> 0) >>> 0, e[5][1] = x >>> 0, x = e[6][1] + O, e[6][0] = e[6][0] + pe + (x / 4294967296 >>> 0) >>> 0, e[6][1] = x >>> 0, x = e[7][1] + c, e[7][0] = e[7][0] + E + (x / 4294967296 >>> 0) >>> 0, e[7][1] = x >>> 0, p -= 128;
  }
}
var asn1Validator$1 = {}, forge$6 = forge$D, asn1$1 = forge$6.asn1;
asn1Validator$1.privateKeyValidator = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.OID,
      constructed: !1,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.OCTETSTRING,
    constructed: !1,
    capture: "privateKey"
  }]
};
asn1Validator$1.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "subjectPublicKeyInfo",
  value: [
    {
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: !1,
        capture: "publicKeyOid"
      }]
    },
    // capture group for ed25519PublicKey
    {
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.BITSTRING,
      constructed: !1,
      composed: !0,
      captureBitStringValue: "ed25519PublicKey"
    }
    // FIXME: this is capture group for rsaPublicKey, use it in this API or
    // discard?
    /* {
      // subjectPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      value: [{
        // RSAPublicKey
        name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: 'rsaPublicKey'
      }]
    } */
  ]
};
var forge$5 = forge$D, asn1Validator = asn1Validator$1, publicKeyValidator = asn1Validator.publicKeyValidator, privateKeyValidator = asn1Validator.privateKeyValidator;
if (typeof BigInteger$1 > "u")
  var BigInteger$1 = forge$5.jsbn.BigInteger;
var ByteBuffer = forge$5.util.ByteBuffer, NativeBuffer = typeof buffer$1.Buffer > "u" ? Uint8Array : buffer$1.Buffer;
forge$5.pki = forge$5.pki || {};
forge$5.pki.ed25519 = forge$5.ed25519 = forge$5.ed25519 || {};
var ed25519 = forge$5.ed25519;
ed25519.constants = {};
ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
ed25519.constants.SEED_BYTE_LENGTH = 32;
ed25519.constants.SIGN_BYTE_LENGTH = 64;
ed25519.constants.HASH_BYTE_LENGTH = 64;
ed25519.generateKeyPair = function(e) {
  e = e || {};
  var t = e.seed;
  if (t === void 0)
    t = forge$5.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
  else if (typeof t == "string") {
    if (t.length !== ed25519.constants.SEED_BYTE_LENGTH)
      throw new TypeError(
        '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
      );
  } else if (!(t instanceof Uint8Array))
    throw new TypeError(
      '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
    );
  t = messageToNativeBuffer({ message: t, encoding: "binary" });
  for (var a = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH), n = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH), u = 0; u < 32; ++u)
    n[u] = t[u];
  return crypto_sign_keypair(a, n), { publicKey: a, privateKey: n };
};
ed25519.privateKeyFromAsn1 = function(e) {
  var t = {}, a = [], n = forge$5.asn1.validate(e, privateKeyValidator, t, a);
  if (!n) {
    var u = new Error("Invalid Key.");
    throw u.errors = a, u;
  }
  var o = forge$5.asn1.derToOid(t.privateKeyOid), l = forge$5.oids.EdDSA25519;
  if (o !== l)
    throw new Error('Invalid OID "' + o + '"; OID must be "' + l + '".');
  var h = t.privateKey, y = messageToNativeBuffer({
    message: forge$5.asn1.fromDer(h).value,
    encoding: "binary"
  });
  return { privateKeyBytes: y };
};
ed25519.publicKeyFromAsn1 = function(e) {
  var t = {}, a = [], n = forge$5.asn1.validate(e, publicKeyValidator, t, a);
  if (!n) {
    var u = new Error("Invalid Key.");
    throw u.errors = a, u;
  }
  var o = forge$5.asn1.derToOid(t.publicKeyOid), l = forge$5.oids.EdDSA25519;
  if (o !== l)
    throw new Error('Invalid OID "' + o + '"; OID must be "' + l + '".');
  var h = t.ed25519PublicKey;
  if (h.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH)
    throw new Error("Key length is invalid.");
  return messageToNativeBuffer({
    message: h,
    encoding: "binary"
  });
};
ed25519.publicKeyFromPrivateKey = function(e) {
  e = e || {};
  var t = messageToNativeBuffer({
    message: e.privateKey,
    encoding: "binary"
  });
  if (t.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH)
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  for (var a = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH), n = 0; n < a.length; ++n)
    a[n] = t[32 + n];
  return a;
};
ed25519.sign = function(e) {
  e = e || {};
  var t = messageToNativeBuffer(e), a = messageToNativeBuffer({
    message: e.privateKey,
    encoding: "binary"
  });
  if (a.length === ed25519.constants.SEED_BYTE_LENGTH) {
    var n = ed25519.generateKeyPair({ seed: a });
    a = n.privateKey;
  } else if (a.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH)
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  var u = new NativeBuffer(
    ed25519.constants.SIGN_BYTE_LENGTH + t.length
  );
  crypto_sign(u, t, t.length, a);
  for (var o = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH), l = 0; l < o.length; ++l)
    o[l] = u[l];
  return o;
};
ed25519.verify = function(e) {
  e = e || {};
  var t = messageToNativeBuffer(e);
  if (e.signature === void 0)
    throw new TypeError(
      '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
    );
  var a = messageToNativeBuffer({
    message: e.signature,
    encoding: "binary"
  });
  if (a.length !== ed25519.constants.SIGN_BYTE_LENGTH)
    throw new TypeError(
      '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
    );
  var n = messageToNativeBuffer({
    message: e.publicKey,
    encoding: "binary"
  });
  if (n.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH)
    throw new TypeError(
      '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
    );
  var u = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + t.length), o = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + t.length), l;
  for (l = 0; l < ed25519.constants.SIGN_BYTE_LENGTH; ++l)
    u[l] = a[l];
  for (l = 0; l < t.length; ++l)
    u[l + ed25519.constants.SIGN_BYTE_LENGTH] = t[l];
  return crypto_sign_open(o, u, u.length, n) >= 0;
};
function messageToNativeBuffer(e) {
  var t = e.message;
  if (t instanceof Uint8Array || t instanceof NativeBuffer)
    return t;
  var a = e.encoding;
  if (t === void 0)
    if (e.md)
      t = e.md.digest().getBytes(), a = "binary";
    else
      throw new TypeError('"options.message" or "options.md" not specified.');
  if (typeof t == "string" && !a)
    throw new TypeError('"options.encoding" must be "binary" or "utf8".');
  if (typeof t == "string") {
    if (typeof buffer$1.Buffer < "u")
      return buffer$1.Buffer.from(t, a);
    t = new ByteBuffer(t, a);
  } else if (!(t instanceof ByteBuffer))
    throw new TypeError(
      '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
    );
  for (var n = new NativeBuffer(t.length()), u = 0; u < n.length; ++u)
    n[u] = t.at(u);
  return n;
}
var gf0 = gf(), gf1 = gf([1]), D = gf([
  30883,
  4953,
  19914,
  30187,
  55467,
  16705,
  2637,
  112,
  59544,
  30585,
  16505,
  36039,
  65139,
  11119,
  27886,
  20995
]), D2 = gf([
  61785,
  9906,
  39828,
  60374,
  45398,
  33411,
  5274,
  224,
  53552,
  61171,
  33010,
  6542,
  64743,
  22239,
  55772,
  9222
]), X = gf([
  54554,
  36645,
  11616,
  51542,
  42930,
  38181,
  51040,
  26924,
  56412,
  64982,
  57905,
  49316,
  21502,
  52590,
  14035,
  8553
]), Y = gf([
  26200,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214
]), L = new Float64Array([
  237,
  211,
  245,
  92,
  26,
  99,
  18,
  88,
  214,
  156,
  247,
  162,
  222,
  249,
  222,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16
]), I = gf([
  41136,
  18958,
  6951,
  50414,
  58488,
  44335,
  6150,
  12099,
  55207,
  15867,
  153,
  11085,
  57099,
  20417,
  9344,
  11139
]);
function sha512(e, t) {
  var a = forge$5.md.sha512.create(), n = new ByteBuffer(e);
  a.update(n.getBytes(t), "binary");
  var u = a.digest().getBytes();
  if (typeof buffer$1.Buffer < "u")
    return buffer$1.Buffer.from(u, "binary");
  for (var o = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH), l = 0; l < 64; ++l)
    o[l] = u.charCodeAt(l);
  return o;
}
function crypto_sign_keypair(e, t) {
  var a = [gf(), gf(), gf(), gf()], n, u = sha512(t, 32);
  for (u[0] &= 248, u[31] &= 127, u[31] |= 64, scalarbase(a, u), pack(e, a), n = 0; n < 32; ++n)
    t[n + 32] = e[n];
  return 0;
}
function crypto_sign(e, t, a, n) {
  var u, o, l = new Float64Array(64), h = [gf(), gf(), gf(), gf()], y = sha512(n, 32);
  y[0] &= 248, y[31] &= 127, y[31] |= 64;
  var _ = a + 64;
  for (u = 0; u < a; ++u)
    e[64 + u] = t[u];
  for (u = 0; u < 32; ++u)
    e[32 + u] = y[32 + u];
  var d = sha512(e.subarray(32), a + 32);
  for (reduce(d), scalarbase(h, d), pack(e, h), u = 32; u < 64; ++u)
    e[u] = n[u];
  var $ = sha512(e, a + 64);
  for (reduce($), u = 32; u < 64; ++u)
    l[u] = 0;
  for (u = 0; u < 32; ++u)
    l[u] = d[u];
  for (u = 0; u < 32; ++u)
    for (o = 0; o < 32; o++)
      l[u + o] += $[u] * y[o];
  return modL(e.subarray(32), l), _;
}
function crypto_sign_open(e, t, a, n) {
  var u, o, l = new NativeBuffer(32), h = [gf(), gf(), gf(), gf()], y = [gf(), gf(), gf(), gf()];
  if (o = -1, a < 64 || unpackneg(y, n))
    return -1;
  for (u = 0; u < a; ++u)
    e[u] = t[u];
  for (u = 0; u < 32; ++u)
    e[u + 32] = n[u];
  var _ = sha512(e, a);
  if (reduce(_), scalarmult(h, y, _), scalarbase(y, t.subarray(32)), add(h, y), pack(l, h), a -= 64, crypto_verify_32(t, 0, l, 0)) {
    for (u = 0; u < a; ++u)
      e[u] = 0;
    return -1;
  }
  for (u = 0; u < a; ++u)
    e[u] = t[u + 64];
  return o = a, o;
}
function modL(e, t) {
  var a, n, u, o;
  for (n = 63; n >= 32; --n) {
    for (a = 0, u = n - 32, o = n - 12; u < o; ++u)
      t[u] += a - 16 * t[n] * L[u - (n - 32)], a = t[u] + 128 >> 8, t[u] -= a * 256;
    t[u] += a, t[n] = 0;
  }
  for (a = 0, u = 0; u < 32; ++u)
    t[u] += a - (t[31] >> 4) * L[u], a = t[u] >> 8, t[u] &= 255;
  for (u = 0; u < 32; ++u)
    t[u] -= a * L[u];
  for (n = 0; n < 32; ++n)
    t[n + 1] += t[n] >> 8, e[n] = t[n] & 255;
}
function reduce(e) {
  for (var t = new Float64Array(64), a = 0; a < 64; ++a)
    t[a] = e[a], e[a] = 0;
  modL(e, t);
}
function add(e, t) {
  var a = gf(), n = gf(), u = gf(), o = gf(), l = gf(), h = gf(), y = gf(), _ = gf(), d = gf();
  Z(a, e[1], e[0]), Z(d, t[1], t[0]), M(a, a, d), A(n, e[0], e[1]), A(d, t[0], t[1]), M(n, n, d), M(u, e[3], t[3]), M(u, u, D2), M(o, e[2], t[2]), A(o, o, o), Z(l, n, a), Z(h, o, u), A(y, o, u), A(_, n, a), M(e[0], l, h), M(e[1], _, y), M(e[2], y, h), M(e[3], l, _);
}
function cswap(e, t, a) {
  for (var n = 0; n < 4; ++n)
    sel25519(e[n], t[n], a);
}
function pack(e, t) {
  var a = gf(), n = gf(), u = gf();
  inv25519(u, t[2]), M(a, t[0], u), M(n, t[1], u), pack25519(e, n), e[31] ^= par25519(a) << 7;
}
function pack25519(e, t) {
  var a, n, u, o = gf(), l = gf();
  for (a = 0; a < 16; ++a)
    l[a] = t[a];
  for (car25519(l), car25519(l), car25519(l), n = 0; n < 2; ++n) {
    for (o[0] = l[0] - 65517, a = 1; a < 15; ++a)
      o[a] = l[a] - 65535 - (o[a - 1] >> 16 & 1), o[a - 1] &= 65535;
    o[15] = l[15] - 32767 - (o[14] >> 16 & 1), u = o[15] >> 16 & 1, o[14] &= 65535, sel25519(l, o, 1 - u);
  }
  for (a = 0; a < 16; a++)
    e[2 * a] = l[a] & 255, e[2 * a + 1] = l[a] >> 8;
}
function unpackneg(e, t) {
  var a = gf(), n = gf(), u = gf(), o = gf(), l = gf(), h = gf(), y = gf();
  return set25519(e[2], gf1), unpack25519(e[1], t), S(u, e[1]), M(o, u, D), Z(u, u, e[2]), A(o, e[2], o), S(l, o), S(h, l), M(y, h, l), M(a, y, u), M(a, a, o), pow2523(a, a), M(a, a, u), M(a, a, o), M(a, a, o), M(e[0], a, o), S(n, e[0]), M(n, n, o), neq25519(n, u) && M(e[0], e[0], I), S(n, e[0]), M(n, n, o), neq25519(n, u) ? -1 : (par25519(e[0]) === t[31] >> 7 && Z(e[0], gf0, e[0]), M(e[3], e[0], e[1]), 0);
}
function unpack25519(e, t) {
  var a;
  for (a = 0; a < 16; ++a)
    e[a] = t[2 * a] + (t[2 * a + 1] << 8);
  e[15] &= 32767;
}
function pow2523(e, t) {
  var a = gf(), n;
  for (n = 0; n < 16; ++n)
    a[n] = t[n];
  for (n = 250; n >= 0; --n)
    S(a, a), n !== 1 && M(a, a, t);
  for (n = 0; n < 16; ++n)
    e[n] = a[n];
}
function neq25519(e, t) {
  var a = new NativeBuffer(32), n = new NativeBuffer(32);
  return pack25519(a, e), pack25519(n, t), crypto_verify_32(a, 0, n, 0);
}
function crypto_verify_32(e, t, a, n) {
  return vn(e, t, a, n, 32);
}
function vn(e, t, a, n, u) {
  var o, l = 0;
  for (o = 0; o < u; ++o)
    l |= e[t + o] ^ a[n + o];
  return (1 & l - 1 >>> 8) - 1;
}
function par25519(e) {
  var t = new NativeBuffer(32);
  return pack25519(t, e), t[0] & 1;
}
function scalarmult(e, t, a) {
  var n, u;
  for (set25519(e[0], gf0), set25519(e[1], gf1), set25519(e[2], gf1), set25519(e[3], gf0), u = 255; u >= 0; --u)
    n = a[u / 8 | 0] >> (u & 7) & 1, cswap(e, t, n), add(t, e), add(e, e), cswap(e, t, n);
}
function scalarbase(e, t) {
  var a = [gf(), gf(), gf(), gf()];
  set25519(a[0], X), set25519(a[1], Y), set25519(a[2], gf1), M(a[3], X, Y), scalarmult(e, a, t);
}
function set25519(e, t) {
  var a;
  for (a = 0; a < 16; a++)
    e[a] = t[a] | 0;
}
function inv25519(e, t) {
  var a = gf(), n;
  for (n = 0; n < 16; ++n)
    a[n] = t[n];
  for (n = 253; n >= 0; --n)
    S(a, a), n !== 2 && n !== 4 && M(a, a, t);
  for (n = 0; n < 16; ++n)
    e[n] = a[n];
}
function car25519(e) {
  var t, a, n = 1;
  for (t = 0; t < 16; ++t)
    a = e[t] + n + 65535, n = Math.floor(a / 65536), e[t] = a - n * 65536;
  e[0] += n - 1 + 37 * (n - 1);
}
function sel25519(e, t, a) {
  for (var n, u = ~(a - 1), o = 0; o < 16; ++o)
    n = u & (e[o] ^ t[o]), e[o] ^= n, t[o] ^= n;
}
function gf(e) {
  var t, a = new Float64Array(16);
  if (e)
    for (t = 0; t < e.length; ++t)
      a[t] = e[t];
  return a;
}
function A(e, t, a) {
  for (var n = 0; n < 16; ++n)
    e[n] = t[n] + a[n];
}
function Z(e, t, a) {
  for (var n = 0; n < 16; ++n)
    e[n] = t[n] - a[n];
}
function S(e, t) {
  M(e, t, t);
}
function M(e, t, a) {
  var n, u, o = 0, l = 0, h = 0, y = 0, _ = 0, d = 0, $ = 0, N = 0, U = 0, V = 0, Q = 0, ie = 0, ee = 0, ne = 0, ge = 0, be = 0, Ee = 0, xe = 0, Le = 0, Ne = 0, Re = 0, Xe = 0, pe = 0, O = 0, E = 0, c = 0, b = 0, C = 0, x = 0, B = 0, k = 0, w = a[0], T = a[1], p = a[2], F = a[3], ye = a[4], _e = a[5], de = a[6], P = a[7], H = a[8], he = a[9], me = a[10], fe = a[11], re = a[12], we = a[13], ke = a[14], Oe = a[15];
  n = t[0], o += n * w, l += n * T, h += n * p, y += n * F, _ += n * ye, d += n * _e, $ += n * de, N += n * P, U += n * H, V += n * he, Q += n * me, ie += n * fe, ee += n * re, ne += n * we, ge += n * ke, be += n * Oe, n = t[1], l += n * w, h += n * T, y += n * p, _ += n * F, d += n * ye, $ += n * _e, N += n * de, U += n * P, V += n * H, Q += n * he, ie += n * me, ee += n * fe, ne += n * re, ge += n * we, be += n * ke, Ee += n * Oe, n = t[2], h += n * w, y += n * T, _ += n * p, d += n * F, $ += n * ye, N += n * _e, U += n * de, V += n * P, Q += n * H, ie += n * he, ee += n * me, ne += n * fe, ge += n * re, be += n * we, Ee += n * ke, xe += n * Oe, n = t[3], y += n * w, _ += n * T, d += n * p, $ += n * F, N += n * ye, U += n * _e, V += n * de, Q += n * P, ie += n * H, ee += n * he, ne += n * me, ge += n * fe, be += n * re, Ee += n * we, xe += n * ke, Le += n * Oe, n = t[4], _ += n * w, d += n * T, $ += n * p, N += n * F, U += n * ye, V += n * _e, Q += n * de, ie += n * P, ee += n * H, ne += n * he, ge += n * me, be += n * fe, Ee += n * re, xe += n * we, Le += n * ke, Ne += n * Oe, n = t[5], d += n * w, $ += n * T, N += n * p, U += n * F, V += n * ye, Q += n * _e, ie += n * de, ee += n * P, ne += n * H, ge += n * he, be += n * me, Ee += n * fe, xe += n * re, Le += n * we, Ne += n * ke, Re += n * Oe, n = t[6], $ += n * w, N += n * T, U += n * p, V += n * F, Q += n * ye, ie += n * _e, ee += n * de, ne += n * P, ge += n * H, be += n * he, Ee += n * me, xe += n * fe, Le += n * re, Ne += n * we, Re += n * ke, Xe += n * Oe, n = t[7], N += n * w, U += n * T, V += n * p, Q += n * F, ie += n * ye, ee += n * _e, ne += n * de, ge += n * P, be += n * H, Ee += n * he, xe += n * me, Le += n * fe, Ne += n * re, Re += n * we, Xe += n * ke, pe += n * Oe, n = t[8], U += n * w, V += n * T, Q += n * p, ie += n * F, ee += n * ye, ne += n * _e, ge += n * de, be += n * P, Ee += n * H, xe += n * he, Le += n * me, Ne += n * fe, Re += n * re, Xe += n * we, pe += n * ke, O += n * Oe, n = t[9], V += n * w, Q += n * T, ie += n * p, ee += n * F, ne += n * ye, ge += n * _e, be += n * de, Ee += n * P, xe += n * H, Le += n * he, Ne += n * me, Re += n * fe, Xe += n * re, pe += n * we, O += n * ke, E += n * Oe, n = t[10], Q += n * w, ie += n * T, ee += n * p, ne += n * F, ge += n * ye, be += n * _e, Ee += n * de, xe += n * P, Le += n * H, Ne += n * he, Re += n * me, Xe += n * fe, pe += n * re, O += n * we, E += n * ke, c += n * Oe, n = t[11], ie += n * w, ee += n * T, ne += n * p, ge += n * F, be += n * ye, Ee += n * _e, xe += n * de, Le += n * P, Ne += n * H, Re += n * he, Xe += n * me, pe += n * fe, O += n * re, E += n * we, c += n * ke, b += n * Oe, n = t[12], ee += n * w, ne += n * T, ge += n * p, be += n * F, Ee += n * ye, xe += n * _e, Le += n * de, Ne += n * P, Re += n * H, Xe += n * he, pe += n * me, O += n * fe, E += n * re, c += n * we, b += n * ke, C += n * Oe, n = t[13], ne += n * w, ge += n * T, be += n * p, Ee += n * F, xe += n * ye, Le += n * _e, Ne += n * de, Re += n * P, Xe += n * H, pe += n * he, O += n * me, E += n * fe, c += n * re, b += n * we, C += n * ke, x += n * Oe, n = t[14], ge += n * w, be += n * T, Ee += n * p, xe += n * F, Le += n * ye, Ne += n * _e, Re += n * de, Xe += n * P, pe += n * H, O += n * he, E += n * me, c += n * fe, b += n * re, C += n * we, x += n * ke, B += n * Oe, n = t[15], be += n * w, Ee += n * T, xe += n * p, Le += n * F, Ne += n * ye, Re += n * _e, Xe += n * de, pe += n * P, O += n * H, E += n * he, c += n * me, b += n * fe, C += n * re, x += n * we, B += n * ke, k += n * Oe, o += 38 * Ee, l += 38 * xe, h += 38 * Le, y += 38 * Ne, _ += 38 * Re, d += 38 * Xe, $ += 38 * pe, N += 38 * O, U += 38 * E, V += 38 * c, Q += 38 * b, ie += 38 * C, ee += 38 * x, ne += 38 * B, ge += 38 * k, u = 1, n = o + u + 65535, u = Math.floor(n / 65536), o = n - u * 65536, n = l + u + 65535, u = Math.floor(n / 65536), l = n - u * 65536, n = h + u + 65535, u = Math.floor(n / 65536), h = n - u * 65536, n = y + u + 65535, u = Math.floor(n / 65536), y = n - u * 65536, n = _ + u + 65535, u = Math.floor(n / 65536), _ = n - u * 65536, n = d + u + 65535, u = Math.floor(n / 65536), d = n - u * 65536, n = $ + u + 65535, u = Math.floor(n / 65536), $ = n - u * 65536, n = N + u + 65535, u = Math.floor(n / 65536), N = n - u * 65536, n = U + u + 65535, u = Math.floor(n / 65536), U = n - u * 65536, n = V + u + 65535, u = Math.floor(n / 65536), V = n - u * 65536, n = Q + u + 65535, u = Math.floor(n / 65536), Q = n - u * 65536, n = ie + u + 65535, u = Math.floor(n / 65536), ie = n - u * 65536, n = ee + u + 65535, u = Math.floor(n / 65536), ee = n - u * 65536, n = ne + u + 65535, u = Math.floor(n / 65536), ne = n - u * 65536, n = ge + u + 65535, u = Math.floor(n / 65536), ge = n - u * 65536, n = be + u + 65535, u = Math.floor(n / 65536), be = n - u * 65536, o += u - 1 + 37 * (u - 1), u = 1, n = o + u + 65535, u = Math.floor(n / 65536), o = n - u * 65536, n = l + u + 65535, u = Math.floor(n / 65536), l = n - u * 65536, n = h + u + 65535, u = Math.floor(n / 65536), h = n - u * 65536, n = y + u + 65535, u = Math.floor(n / 65536), y = n - u * 65536, n = _ + u + 65535, u = Math.floor(n / 65536), _ = n - u * 65536, n = d + u + 65535, u = Math.floor(n / 65536), d = n - u * 65536, n = $ + u + 65535, u = Math.floor(n / 65536), $ = n - u * 65536, n = N + u + 65535, u = Math.floor(n / 65536), N = n - u * 65536, n = U + u + 65535, u = Math.floor(n / 65536), U = n - u * 65536, n = V + u + 65535, u = Math.floor(n / 65536), V = n - u * 65536, n = Q + u + 65535, u = Math.floor(n / 65536), Q = n - u * 65536, n = ie + u + 65535, u = Math.floor(n / 65536), ie = n - u * 65536, n = ee + u + 65535, u = Math.floor(n / 65536), ee = n - u * 65536, n = ne + u + 65535, u = Math.floor(n / 65536), ne = n - u * 65536, n = ge + u + 65535, u = Math.floor(n / 65536), ge = n - u * 65536, n = be + u + 65535, u = Math.floor(n / 65536), be = n - u * 65536, o += u - 1 + 37 * (u - 1), e[0] = o, e[1] = l, e[2] = h, e[3] = y, e[4] = _, e[5] = d, e[6] = $, e[7] = N, e[8] = U, e[9] = V, e[10] = Q, e[11] = ie, e[12] = ee, e[13] = ne, e[14] = ge, e[15] = be;
}
var forge$4 = forge$D;
forge$4.kem = forge$4.kem || {};
var BigInteger = forge$4.jsbn.BigInteger;
forge$4.kem.rsa = {};
forge$4.kem.rsa.create = function(e, t) {
  t = t || {};
  var a = t.prng || forge$4.random, n = {};
  return n.encrypt = function(u, o) {
    var l = Math.ceil(u.n.bitLength() / 8), h;
    do
      h = new BigInteger(
        forge$4.util.bytesToHex(a.getBytesSync(l)),
        16
      ).mod(u.n);
    while (h.compareTo(BigInteger.ONE) <= 0);
    h = forge$4.util.hexToBytes(h.toString(16));
    var y = l - h.length;
    y > 0 && (h = forge$4.util.fillString(String.fromCharCode(0), y) + h);
    var _ = u.encrypt(h, "NONE"), d = e.generate(h, o);
    return { encapsulation: _, key: d };
  }, n.decrypt = function(u, o, l) {
    var h = u.decrypt(o, "NONE");
    return e.generate(h, l);
  }, n;
};
forge$4.kem.kdf1 = function(e, t) {
  _createKDF(this, e, 0, t || e.digestLength);
};
forge$4.kem.kdf2 = function(e, t) {
  _createKDF(this, e, 1, t || e.digestLength);
};
function _createKDF(e, t, a, n) {
  e.generate = function(u, o) {
    for (var l = new forge$4.util.ByteBuffer(), h = Math.ceil(o / n) + a, y = new forge$4.util.ByteBuffer(), _ = a; _ < h; ++_) {
      y.putInt32(_), t.start(), t.update(u + y.getBytes());
      var d = t.digest();
      l.putBytes(d.getBytes(n));
    }
    return l.truncate(l.length() - o), l.getBytes();
  };
}
var forge$3 = forge$D;
forge$3.log = forge$3.log || {};
forge$3.log.levels = [
  "none",
  "error",
  "warning",
  "info",
  "debug",
  "verbose",
  "max"
];
var sLevelInfo = {}, sLoggers = [], sConsoleLogger = null;
forge$3.log.LEVEL_LOCKED = 2;
forge$3.log.NO_LEVEL_CHECK = 4;
forge$3.log.INTERPOLATE = 8;
for (var i = 0; i < forge$3.log.levels.length; ++i) {
  var level = forge$3.log.levels[i];
  sLevelInfo[level] = {
    index: i,
    name: level.toUpperCase()
  };
}
forge$3.log.logMessage = function(e) {
  for (var t = sLevelInfo[e.level].index, a = 0; a < sLoggers.length; ++a) {
    var n = sLoggers[a];
    if (n.flags & forge$3.log.NO_LEVEL_CHECK)
      n.f(e);
    else {
      var u = sLevelInfo[n.level].index;
      t <= u && n.f(n, e);
    }
  }
};
forge$3.log.prepareStandard = function(e) {
  "standard" in e || (e.standard = sLevelInfo[e.level].name + //' ' + +message.timestamp +
  " [" + e.category + "] " + e.message);
};
forge$3.log.prepareFull = function(e) {
  if (!("full" in e)) {
    var t = [e.message];
    t = t.concat([]), e.full = forge$3.util.format.apply(this, t);
  }
};
forge$3.log.prepareStandardFull = function(e) {
  "standardFull" in e || (forge$3.log.prepareStandard(e), e.standardFull = e.standard);
};
for (var levels = ["error", "warning", "info", "debug", "verbose"], i = 0; i < levels.length; ++i)
  (function(t) {
    forge$3.log[t] = function(a, n) {
      var u = Array.prototype.slice.call(arguments).slice(2), o = {
        timestamp: /* @__PURE__ */ new Date(),
        level: t,
        category: a,
        message: n,
        arguments: u
        /*standard*/
        /*full*/
        /*fullMessage*/
      };
      forge$3.log.logMessage(o);
    };
  })(levels[i]);
forge$3.log.makeLogger = function(e) {
  var t = {
    flags: 0,
    f: e
  };
  return forge$3.log.setLevel(t, "none"), t;
};
forge$3.log.setLevel = function(e, t) {
  var a = !1;
  if (e && !(e.flags & forge$3.log.LEVEL_LOCKED))
    for (var n = 0; n < forge$3.log.levels.length; ++n) {
      var u = forge$3.log.levels[n];
      if (t == u) {
        e.level = t, a = !0;
        break;
      }
    }
  return a;
};
forge$3.log.lock = function(e, t) {
  typeof t > "u" || t ? e.flags |= forge$3.log.LEVEL_LOCKED : e.flags &= ~forge$3.log.LEVEL_LOCKED;
};
forge$3.log.addLogger = function(e) {
  sLoggers.push(e);
};
if (typeof console < "u" && "log" in console) {
  var logger;
  if (console.error && console.warn && console.info && console.debug) {
    var levelHandlers = {
      error: console.error,
      warning: console.warn,
      info: console.info,
      debug: console.debug,
      verbose: console.debug
    }, f = function(e, t) {
      forge$3.log.prepareStandard(t);
      var a = levelHandlers[t.level], n = [t.standard];
      n = n.concat(t.arguments.slice()), a.apply(console, n);
    };
    logger = forge$3.log.makeLogger(f);
  } else {
    var f = function(t, a) {
      forge$3.log.prepareStandardFull(a), console.log(a.standardFull);
    };
    logger = forge$3.log.makeLogger(f);
  }
  forge$3.log.setLevel(logger, "debug"), forge$3.log.addLogger(logger), sConsoleLogger = logger;
} else
  console = {
    log: function() {
    }
  };
if (sConsoleLogger !== null && typeof window < "u" && window.location) {
  var query = new URL(window.location.href).searchParams;
  if (query.has("console.level") && forge$3.log.setLevel(
    sConsoleLogger,
    query.get("console.level").slice(-1)[0]
  ), query.has("console.lock")) {
    var lock = query.get("console.lock").slice(-1)[0];
    lock == "true" && forge$3.log.lock(sConsoleLogger);
  }
}
forge$3.log.consoleLogger = sConsoleLogger;
var forge$2 = forge$D, asn1 = forge$2.asn1, p7 = forge$2.pkcs7 = forge$2.pkcs7 || {};
p7.messageFromPem = function(e) {
  var t = forge$2.pem.decode(e)[0];
  if (t.type !== "PKCS7") {
    var a = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
    throw a.headerType = t.type, a;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
  var n = asn1.fromDer(t.body);
  return p7.messageFromAsn1(n);
};
p7.messageToPem = function(e, t) {
  var a = {
    type: "PKCS7",
    body: asn1.toDer(e.toAsn1()).getBytes()
  };
  return forge$2.pem.encode(a, { maxline: t });
};
p7.messageFromAsn1 = function(e) {
  var t = {}, a = [];
  if (!asn1.validate(e, p7.asn1.contentInfoValidator, t, a)) {
    var n = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
    throw n.errors = a, n;
  }
  var u = asn1.derToOid(t.contentType), o;
  switch (u) {
    case forge$2.pki.oids.envelopedData:
      o = p7.createEnvelopedData();
      break;
    case forge$2.pki.oids.encryptedData:
      o = p7.createEncryptedData();
      break;
    case forge$2.pki.oids.signedData:
      o = p7.createSignedData();
      break;
    default:
      throw new Error("Cannot read PKCS#7 message. ContentType with OID " + u + " is not (yet) supported.");
  }
  return o.fromAsn1(t.content.value[0]), o;
};
p7.createSignedData = function() {
  var e = null;
  return e = {
    type: forge$2.pki.oids.signedData,
    version: 1,
    certificates: [],
    crls: [],
    // TODO: add json-formatted signer stuff here?
    signers: [],
    // populated during sign()
    digestAlgorithmIdentifiers: [],
    contentInfo: null,
    signerInfos: [],
    fromAsn1: function(n) {
      if (_fromAsn1(e, n, p7.asn1.signedDataValidator), e.certificates = [], e.crls = [], e.digestAlgorithmIdentifiers = [], e.contentInfo = null, e.signerInfos = [], e.rawCapture.certificates)
        for (var u = e.rawCapture.certificates.value, o = 0; o < u.length; ++o)
          e.certificates.push(forge$2.pki.certificateFromAsn1(u[o]));
    },
    toAsn1: function() {
      e.contentInfo || e.sign();
      for (var n = [], u = 0; u < e.certificates.length; ++u)
        n.push(forge$2.pki.certificateToAsn1(e.certificates[u]));
      var o = [], l = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
          // Version
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            !1,
            asn1.integerToDer(e.version).getBytes()
          ),
          // DigestAlgorithmIdentifiers
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SET,
            !0,
            e.digestAlgorithmIdentifiers
          ),
          // ContentInfo
          e.contentInfo
        ])
      ]);
      return n.length > 0 && l.value[0].value.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, n)
      ), o.length > 0 && l.value[0].value.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, o)
      ), l.value[0].value.push(
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SET,
          !0,
          e.signerInfos
        )
      ), asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        !0,
        [
          // ContentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            !1,
            asn1.oidToDer(e.type).getBytes()
          ),
          // [0] SignedData
          l
        ]
      );
    },
    /**
     * Add (another) entity to list of signers.
     *
     * Note: If authenticatedAttributes are provided, then, per RFC 2315,
     * they must include at least two attributes: content type and
     * message digest. The message digest attribute value will be
     * auto-calculated during signing and will be ignored if provided.
     *
     * Here's an example of providing these two attributes:
     *
     * forge.pkcs7.createSignedData();
     * p7.addSigner({
     *   issuer: cert.issuer.attributes,
     *   serialNumber: cert.serialNumber,
     *   key: privateKey,
     *   digestAlgorithm: forge.pki.oids.sha1,
     *   authenticatedAttributes: [{
     *     type: forge.pki.oids.contentType,
     *     value: forge.pki.oids.data
     *   }, {
     *     type: forge.pki.oids.messageDigest
     *   }]
     * });
     *
     * TODO: Support [subjectKeyIdentifier] as signer's ID.
     *
     * @param signer the signer information:
     *          key the signer's private key.
     *          [certificate] a certificate containing the public key
     *            associated with the signer's private key; use this option as
     *            an alternative to specifying signer.issuer and
     *            signer.serialNumber.
     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
     *          [serialNumber] the signer's certificate's serial number in
     *           hexadecimal (eg: cert.serialNumber).
     *          [digestAlgorithm] the message digest OID, as a string, to use
     *            (eg: forge.pki.oids.sha1).
     *          [authenticatedAttributes] an optional array of attributes
     *            to also sign along with the content.
     */
    addSigner: function(n) {
      var u = n.issuer, o = n.serialNumber;
      if (n.certificate) {
        var l = n.certificate;
        typeof l == "string" && (l = forge$2.pki.certificateFromPem(l)), u = l.issuer.attributes, o = l.serialNumber;
      }
      var h = n.key;
      if (!h)
        throw new Error(
          "Could not add PKCS#7 signer; no private key specified."
        );
      typeof h == "string" && (h = forge$2.pki.privateKeyFromPem(h));
      var y = n.digestAlgorithm || forge$2.pki.oids.sha1;
      switch (y) {
        case forge$2.pki.oids.sha1:
        case forge$2.pki.oids.sha256:
        case forge$2.pki.oids.sha384:
        case forge$2.pki.oids.sha512:
        case forge$2.pki.oids.md5:
          break;
        default:
          throw new Error(
            "Could not add PKCS#7 signer; unknown message digest algorithm: " + y
          );
      }
      var _ = n.authenticatedAttributes || [];
      if (_.length > 0) {
        for (var d = !1, $ = !1, N = 0; N < _.length; ++N) {
          var U = _[N];
          if (!d && U.type === forge$2.pki.oids.contentType) {
            if (d = !0, $)
              break;
            continue;
          }
          if (!$ && U.type === forge$2.pki.oids.messageDigest) {
            if ($ = !0, d)
              break;
            continue;
          }
        }
        if (!d || !$)
          throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
      }
      e.signers.push({
        key: h,
        version: 1,
        issuer: u,
        serialNumber: o,
        digestAlgorithm: y,
        signatureAlgorithm: forge$2.pki.oids.rsaEncryption,
        signature: null,
        authenticatedAttributes: _,
        unauthenticatedAttributes: []
      });
    },
    /**
     * Signs the content.
     * @param options Options to apply when signing:
     *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
     */
    sign: function(n) {
      if (n = n || {}, (typeof e.content != "object" || e.contentInfo === null) && (e.contentInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        !0,
        [
          // ContentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            !1,
            asn1.oidToDer(forge$2.pki.oids.data).getBytes()
          )
        ]
      ), "content" in e)) {
        var u;
        e.content instanceof forge$2.util.ByteBuffer ? u = e.content.bytes() : typeof e.content == "string" && (u = forge$2.util.encodeUtf8(e.content)), n.detached ? e.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, u) : e.contentInfo.value.push(
          // [0] EXPLICIT content
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              !1,
              u
            )
          ])
        );
      }
      if (e.signers.length !== 0) {
        var o = t();
        a(o);
      }
    },
    verify: function() {
      throw new Error("PKCS#7 signature verification not yet implemented.");
    },
    /**
     * Add a certificate.
     *
     * @param cert the certificate to add.
     */
    addCertificate: function(n) {
      typeof n == "string" && (n = forge$2.pki.certificateFromPem(n)), e.certificates.push(n);
    },
    /**
     * Add a certificate revokation list.
     *
     * @param crl the certificate revokation list to add.
     */
    addCertificateRevokationList: function(n) {
      throw new Error("PKCS#7 CRL support not yet implemented.");
    }
  }, e;
  function t() {
    for (var n = {}, u = 0; u < e.signers.length; ++u) {
      var o = e.signers[u], l = o.digestAlgorithm;
      l in n || (n[l] = forge$2.md[forge$2.pki.oids[l]].create()), o.authenticatedAttributes.length === 0 ? o.md = n[l] : o.md = forge$2.md[forge$2.pki.oids[l]].create();
    }
    e.digestAlgorithmIdentifiers = [];
    for (var l in n)
      e.digestAlgorithmIdentifiers.push(
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            !1,
            asn1.oidToDer(l).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")
        ])
      );
    return n;
  }
  function a(n) {
    var u;
    if (e.detachedContent ? u = e.detachedContent : (u = e.contentInfo.value[1], u = u.value[0]), !u)
      throw new Error(
        "Could not sign PKCS#7 message; there is no content to sign."
      );
    var o = asn1.derToOid(e.contentInfo.value[0].value), l = asn1.toDer(u);
    l.getByte(), asn1.getBerValueLength(l), l = l.getBytes();
    for (var h in n)
      n[h].start().update(l);
    for (var y = /* @__PURE__ */ new Date(), _ = 0; _ < e.signers.length; ++_) {
      var d = e.signers[_];
      if (d.authenticatedAttributes.length === 0) {
        if (o !== forge$2.pki.oids.data)
          throw new Error(
            "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
          );
      } else {
        d.authenticatedAttributesAsn1 = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          !0,
          []
        );
        for (var $ = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SET,
          !0,
          []
        ), N = 0; N < d.authenticatedAttributes.length; ++N) {
          var U = d.authenticatedAttributes[N];
          U.type === forge$2.pki.oids.messageDigest ? U.value = n[d.digestAlgorithm].digest() : U.type === forge$2.pki.oids.signingTime && (U.value || (U.value = y)), $.value.push(_attributeToAsn1(U)), d.authenticatedAttributesAsn1.value.push(_attributeToAsn1(U));
        }
        l = asn1.toDer($).getBytes(), d.md.start().update(l);
      }
      d.signature = d.key.sign(d.md, "RSASSA-PKCS1-V1_5");
    }
    e.signerInfos = _signersToAsn1(e.signers);
  }
};
p7.createEncryptedData = function() {
  var e = null;
  return e = {
    type: forge$2.pki.oids.encryptedData,
    version: 0,
    encryptedContent: {
      algorithm: forge$2.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EncryptedData content block (in ASN.1 format)
     *
     * @param obj The ASN.1 representation of the EncryptedData content block
     */
    fromAsn1: function(t) {
      _fromAsn1(e, t, p7.asn1.encryptedDataValidator);
    },
    /**
     * Decrypt encrypted content
     *
     * @param key The (symmetric) key as a byte buffer
     */
    decrypt: function(t) {
      t !== void 0 && (e.encryptedContent.key = t), _decryptContent(e);
    }
  }, e;
};
p7.createEnvelopedData = function() {
  var e = null;
  return e = {
    type: forge$2.pki.oids.envelopedData,
    version: 0,
    recipients: [],
    encryptedContent: {
      algorithm: forge$2.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EnvelopedData content block (in ASN.1 format)
     *
     * @param obj the ASN.1 representation of the EnvelopedData content block.
     */
    fromAsn1: function(t) {
      var a = _fromAsn1(e, t, p7.asn1.envelopedDataValidator);
      e.recipients = _recipientsFromAsn1(a.recipientInfos.value);
    },
    toAsn1: function() {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
        // ContentType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          !1,
          asn1.oidToDer(e.type).getBytes()
        ),
        // [0] EnvelopedData
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
            // Version
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              !1,
              asn1.integerToDer(e.version).getBytes()
            ),
            // RecipientInfos
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              !0,
              _recipientsToAsn1(e.recipients)
            ),
            // EncryptedContentInfo
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              !0,
              _encryptedContentToAsn1(e.encryptedContent)
            )
          ])
        ])
      ]);
    },
    /**
     * Find recipient by X.509 certificate's issuer.
     *
     * @param cert the certificate with the issuer to look for.
     *
     * @return the recipient object.
     */
    findRecipient: function(t) {
      for (var a = t.issuer.attributes, n = 0; n < e.recipients.length; ++n) {
        var u = e.recipients[n], o = u.issuer;
        if (u.serialNumber === t.serialNumber && o.length === a.length) {
          for (var l = !0, h = 0; h < a.length; ++h)
            if (o[h].type !== a[h].type || o[h].value !== a[h].value) {
              l = !1;
              break;
            }
          if (l)
            return u;
        }
      }
      return null;
    },
    /**
     * Decrypt enveloped content
     *
     * @param recipient The recipient object related to the private key
     * @param privKey The (RSA) private key object
     */
    decrypt: function(t, a) {
      if (e.encryptedContent.key === void 0 && t !== void 0 && a !== void 0)
        switch (t.encryptedContent.algorithm) {
          case forge$2.pki.oids.rsaEncryption:
          case forge$2.pki.oids.desCBC:
            var n = a.decrypt(t.encryptedContent.content);
            e.encryptedContent.key = forge$2.util.createBuffer(n);
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + t.encryptedContent.algorithm);
        }
      _decryptContent(e);
    },
    /**
     * Add (another) entity to list of recipients.
     *
     * @param cert The certificate of the entity to add.
     */
    addRecipient: function(t) {
      e.recipients.push({
        version: 0,
        issuer: t.issuer.attributes,
        serialNumber: t.serialNumber,
        encryptedContent: {
          // We simply assume rsaEncryption here, since forge.pki only
          // supports RSA so far.  If the PKI module supports other
          // ciphers one day, we need to modify this one as well.
          algorithm: forge$2.pki.oids.rsaEncryption,
          key: t.publicKey
        }
      });
    },
    /**
     * Encrypt enveloped content.
     *
     * This function supports two optional arguments, cipher and key, which
     * can be used to influence symmetric encryption.  Unless cipher is
     * provided, the cipher specified in encryptedContent.algorithm is used
     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
     * is (re-)used.  If that one's not set, a random key will be generated
     * automatically.
     *
     * @param [key] The key to be used for symmetric encryption.
     * @param [cipher] The OID of the symmetric cipher to use.
     */
    encrypt: function(t, a) {
      if (e.encryptedContent.content === void 0) {
        a = a || e.encryptedContent.algorithm, t = t || e.encryptedContent.key;
        var n, u, o;
        switch (a) {
          case forge$2.pki.oids["aes128-CBC"]:
            n = 16, u = 16, o = forge$2.aes.createEncryptionCipher;
            break;
          case forge$2.pki.oids["aes192-CBC"]:
            n = 24, u = 16, o = forge$2.aes.createEncryptionCipher;
            break;
          case forge$2.pki.oids["aes256-CBC"]:
            n = 32, u = 16, o = forge$2.aes.createEncryptionCipher;
            break;
          case forge$2.pki.oids["des-EDE3-CBC"]:
            n = 24, u = 8, o = forge$2.des.createEncryptionCipher;
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + a);
        }
        if (t === void 0)
          t = forge$2.util.createBuffer(forge$2.random.getBytes(n));
        else if (t.length() != n)
          throw new Error("Symmetric key has wrong length; got " + t.length() + " bytes, expected " + n + ".");
        e.encryptedContent.algorithm = a, e.encryptedContent.key = t, e.encryptedContent.parameter = forge$2.util.createBuffer(
          forge$2.random.getBytes(u)
        );
        var l = o(t);
        if (l.start(e.encryptedContent.parameter.copy()), l.update(e.content), !l.finish())
          throw new Error("Symmetric encryption failed.");
        e.encryptedContent.content = l.output;
      }
      for (var h = 0; h < e.recipients.length; ++h) {
        var y = e.recipients[h];
        if (y.encryptedContent.content === void 0)
          switch (y.encryptedContent.algorithm) {
            case forge$2.pki.oids.rsaEncryption:
              y.encryptedContent.content = y.encryptedContent.key.encrypt(
                e.encryptedContent.key.data
              );
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + y.encryptedContent.algorithm);
          }
      }
    }
  }, e;
};
function _recipientFromAsn1(e) {
  var t = {}, a = [];
  if (!asn1.validate(e, p7.asn1.recipientInfoValidator, t, a)) {
    var n = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
    throw n.errors = a, n;
  }
  return {
    version: t.version.charCodeAt(0),
    issuer: forge$2.pki.RDNAttributesAsArray(t.issuer),
    serialNumber: forge$2.util.createBuffer(t.serial).toHex(),
    encryptedContent: {
      algorithm: asn1.derToOid(t.encAlgorithm),
      parameter: t.encParameter ? t.encParameter.value : void 0,
      content: t.encKey
    }
  };
}
function _recipientToAsn1(e) {
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
    // Version
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      !1,
      asn1.integerToDer(e.version).getBytes()
    ),
    // IssuerAndSerialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
      // Name
      forge$2.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
      // Serial
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.INTEGER,
        !1,
        forge$2.util.hexToBytes(e.serialNumber)
      )
    ]),
    // KeyEncryptionAlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
      // Algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        !1,
        asn1.oidToDer(e.encryptedContent.algorithm).getBytes()
      ),
      // Parameter, force NULL, only RSA supported for now.
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")
    ]),
    // EncryptedKey
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      !1,
      e.encryptedContent.content
    )
  ]);
}
function _recipientsFromAsn1(e) {
  for (var t = [], a = 0; a < e.length; ++a)
    t.push(_recipientFromAsn1(e[a]));
  return t;
}
function _recipientsToAsn1(e) {
  for (var t = [], a = 0; a < e.length; ++a)
    t.push(_recipientToAsn1(e[a]));
  return t;
}
function _signerToAsn1(e) {
  var t = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
    // version
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      !1,
      asn1.integerToDer(e.version).getBytes()
    ),
    // issuerAndSerialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
      // name
      forge$2.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
      // serial
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.INTEGER,
        !1,
        forge$2.util.hexToBytes(e.serialNumber)
      )
    ]),
    // digestAlgorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
      // algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        !1,
        asn1.oidToDer(e.digestAlgorithm).getBytes()
      ),
      // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")
    ])
  ]);
  if (e.authenticatedAttributesAsn1 && t.value.push(e.authenticatedAttributesAsn1), t.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
    // algorithm
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      !1,
      asn1.oidToDer(e.signatureAlgorithm).getBytes()
    ),
    // parameters (null)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")
  ])), t.value.push(asn1.create(
    asn1.Class.UNIVERSAL,
    asn1.Type.OCTETSTRING,
    !1,
    e.signature
  )), e.unauthenticatedAttributes.length > 0) {
    for (var a = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, []), n = 0; n < e.unauthenticatedAttributes.length; ++n) {
      var u = e.unauthenticatedAttributes[n];
      a.values.push(_attributeToAsn1(u));
    }
    t.value.push(a);
  }
  return t;
}
function _signersToAsn1(e) {
  for (var t = [], a = 0; a < e.length; ++a)
    t.push(_signerToAsn1(e[a]));
  return t;
}
function _attributeToAsn1(e) {
  var t;
  if (e.type === forge$2.pki.oids.contentType)
    t = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      !1,
      asn1.oidToDer(e.value).getBytes()
    );
  else if (e.type === forge$2.pki.oids.messageDigest)
    t = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      !1,
      e.value.bytes()
    );
  else if (e.type === forge$2.pki.oids.signingTime) {
    var a = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), n = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z"), u = e.value;
    if (typeof u == "string") {
      var o = Date.parse(u);
      isNaN(o) ? u.length === 13 ? u = asn1.utcTimeToDate(u) : u = asn1.generalizedTimeToDate(u) : u = new Date(o);
    }
    u >= a && u < n ? t = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.UTCTIME,
      !1,
      asn1.dateToUtcTime(u)
    ) : t = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.GENERALIZEDTIME,
      !1,
      asn1.dateToGeneralizedTime(u)
    );
  }
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
    // AttributeType
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      !1,
      asn1.oidToDer(e.type).getBytes()
    ),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [
      // AttributeValue
      t
    ])
  ]);
}
function _encryptedContentToAsn1(e) {
  return [
    // ContentType, always Data for the moment
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      !1,
      asn1.oidToDer(forge$2.pki.oids.data).getBytes()
    ),
    // ContentEncryptionAlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
      // Algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        !1,
        asn1.oidToDer(e.algorithm).getBytes()
      ),
      // Parameters (IV)
      e.parameter ? asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        !1,
        e.parameter.getBytes()
      ) : void 0
    ]),
    // [0] EncryptedContent
    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        !1,
        e.content.getBytes()
      )
    ])
  ];
}
function _fromAsn1(e, t, a) {
  var n = {}, u = [];
  if (!asn1.validate(t, a, n, u)) {
    var o = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
    throw o.errors = o, o;
  }
  var l = asn1.derToOid(n.contentType);
  if (l !== forge$2.pki.oids.data)
    throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
  if (n.encryptedContent) {
    var h = "";
    if (forge$2.util.isArray(n.encryptedContent))
      for (var y = 0; y < n.encryptedContent.length; ++y) {
        if (n.encryptedContent[y].type !== asn1.Type.OCTETSTRING)
          throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
        h += n.encryptedContent[y].value;
      }
    else
      h = n.encryptedContent;
    e.encryptedContent = {
      algorithm: asn1.derToOid(n.encAlgorithm),
      parameter: forge$2.util.createBuffer(n.encParameter.value),
      content: forge$2.util.createBuffer(h)
    };
  }
  if (n.content) {
    var h = "";
    if (forge$2.util.isArray(n.content))
      for (var y = 0; y < n.content.length; ++y) {
        if (n.content[y].type !== asn1.Type.OCTETSTRING)
          throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
        h += n.content[y].value;
      }
    else
      h = n.content;
    e.content = forge$2.util.createBuffer(h);
  }
  return e.version = n.version.charCodeAt(0), e.rawCapture = n, n;
}
function _decryptContent(e) {
  if (e.encryptedContent.key === void 0)
    throw new Error("Symmetric key not available.");
  if (e.content === void 0) {
    var t;
    switch (e.encryptedContent.algorithm) {
      case forge$2.pki.oids["aes128-CBC"]:
      case forge$2.pki.oids["aes192-CBC"]:
      case forge$2.pki.oids["aes256-CBC"]:
        t = forge$2.aes.createDecryptionCipher(e.encryptedContent.key);
        break;
      case forge$2.pki.oids.desCBC:
      case forge$2.pki.oids["des-EDE3-CBC"]:
        t = forge$2.des.createDecryptionCipher(e.encryptedContent.key);
        break;
      default:
        throw new Error("Unsupported symmetric cipher, OID " + e.encryptedContent.algorithm);
    }
    if (t.start(e.encryptedContent.parameter), t.update(e.encryptedContent.content), !t.finish())
      throw new Error("Symmetric decryption failed.");
    e.content = t.output;
  }
}
var forge$1 = forge$D, ssh = forge$1.ssh = forge$1.ssh || {};
ssh.privateKeyToPutty = function(e, t, a) {
  a = a || "", t = t || "";
  var n = "ssh-rsa", u = t === "" ? "none" : "aes256-cbc", o = "PuTTY-User-Key-File-2: " + n + `\r
`;
  o += "Encryption: " + u + `\r
`, o += "Comment: " + a + `\r
`;
  var l = forge$1.util.createBuffer();
  _addStringToBuffer(l, n), _addBigIntegerToBuffer(l, e.e), _addBigIntegerToBuffer(l, e.n);
  var h = forge$1.util.encode64(l.bytes(), 64), y = Math.floor(h.length / 66) + 1;
  o += "Public-Lines: " + y + `\r
`, o += h;
  var _ = forge$1.util.createBuffer();
  _addBigIntegerToBuffer(_, e.d), _addBigIntegerToBuffer(_, e.p), _addBigIntegerToBuffer(_, e.q), _addBigIntegerToBuffer(_, e.qInv);
  var d;
  if (!t)
    d = forge$1.util.encode64(_.bytes(), 64);
  else {
    var $ = _.length() + 16 - 1;
    $ -= $ % 16;
    var N = _sha1(_.bytes());
    N.truncate(N.length() - $ + _.length()), _.putBuffer(N);
    var U = forge$1.util.createBuffer();
    U.putBuffer(_sha1("\0\0\0\0", t)), U.putBuffer(_sha1("\0\0\0", t));
    var V = forge$1.aes.createEncryptionCipher(U.truncate(8), "CBC");
    V.start(forge$1.util.createBuffer().fillWithByte(0, 16)), V.update(_.copy()), V.finish();
    var Q = V.output;
    Q.truncate(16), d = forge$1.util.encode64(Q.bytes(), 64);
  }
  y = Math.floor(d.length / 66) + 1, o += `\r
Private-Lines: ` + y + `\r
`, o += d;
  var ie = _sha1("putty-private-key-file-mac-key", t), ee = forge$1.util.createBuffer();
  _addStringToBuffer(ee, n), _addStringToBuffer(ee, u), _addStringToBuffer(ee, a), ee.putInt32(l.length()), ee.putBuffer(l), ee.putInt32(_.length()), ee.putBuffer(_);
  var ne = forge$1.hmac.create();
  return ne.start("sha1", ie), ne.update(ee.bytes()), o += `\r
Private-MAC: ` + ne.digest().toHex() + `\r
`, o;
};
ssh.publicKeyToOpenSSH = function(e, t) {
  var a = "ssh-rsa";
  t = t || "";
  var n = forge$1.util.createBuffer();
  return _addStringToBuffer(n, a), _addBigIntegerToBuffer(n, e.e), _addBigIntegerToBuffer(n, e.n), a + " " + forge$1.util.encode64(n.bytes()) + " " + t;
};
ssh.privateKeyToOpenSSH = function(e, t) {
  return t ? forge$1.pki.encryptRsaPrivateKey(
    e,
    t,
    { legacy: !0, algorithm: "aes128" }
  ) : forge$1.pki.privateKeyToPem(e);
};
ssh.getPublicKeyFingerprint = function(e, t) {
  t = t || {};
  var a = t.md || forge$1.md.md5.create(), n = "ssh-rsa", u = forge$1.util.createBuffer();
  _addStringToBuffer(u, n), _addBigIntegerToBuffer(u, e.e), _addBigIntegerToBuffer(u, e.n), a.start(), a.update(u.getBytes());
  var o = a.digest();
  if (t.encoding === "hex") {
    var l = o.toHex();
    return t.delimiter ? l.match(/.{2}/g).join(t.delimiter) : l;
  } else {
    if (t.encoding === "binary")
      return o.getBytes();
    if (t.encoding)
      throw new Error('Unknown encoding "' + t.encoding + '".');
  }
  return o;
};
function _addBigIntegerToBuffer(e, t) {
  var a = t.toString(16);
  a[0] >= "8" && (a = "00" + a);
  var n = forge$1.util.hexToBytes(a);
  e.putInt32(n.length), e.putBytes(n);
}
function _addStringToBuffer(e, t) {
  e.putInt32(t.length), e.putString(t);
}
function _sha1() {
  for (var e = forge$1.md.sha1.create(), t = arguments.length, a = 0; a < t; ++a)
    e.update(arguments[a]);
  return e.digest();
}
var lib = forge$D;
const forge = /* @__PURE__ */ getDefaultExportFromCjs(lib), DEFAULT_BYTE_LENGTH = 32, DEFAULT_PBKDF2_ITERATIONS = 1e5;
async function deriveKey(e, t, a) {
  const n = await _hkdfSalt(a, t);
  return _pbkdf2Passphrase(e, n);
}
function encryptRSAWithJWK(e, t) {
  if (e.alg !== "RSA-OAEP-256")
    throw new Error("Public key algorithm was not RSA-OAEP-256");
  if (e.kty !== "RSA")
    throw new Error("Public key type was not RSA");
  if (!e.key_ops || !e.key_ops.find((h) => h === "encrypt"))
    throw new Error('Public key does not have "encrypt" op');
  if (!e.n || !e.e)
    throw new Error("Public key is missing parameters");
  const a = encodeURIComponent(t), n = _b64UrlToBigInt(e.n), u = _b64UrlToBigInt(e.e), l = forge.rsa.setPublicKey(n, u).encrypt(a, "RSA-OAEP", {
    md: forge.md.sha256.create()
  });
  return forge.util.bytesToHex(l);
}
function decryptRSAWithJWK(e, t) {
  if (!e.n || !e.e || !e.d || !e.p || !e.q || !e.dp || !e.dq || !e.qi)
    throw new Error("Private key is missing parameters");
  const a = _b64UrlToBigInt(e.n), n = _b64UrlToBigInt(e.e), u = _b64UrlToBigInt(e.d), o = _b64UrlToBigInt(e.p), l = _b64UrlToBigInt(e.q), h = _b64UrlToBigInt(e.dp), y = _b64UrlToBigInt(e.dq), _ = _b64UrlToBigInt(e.qi), d = forge.rsa.setPrivateKey(a, n, u, o, l, h, y, _), $ = forge.util.hexToBytes(t), N = d.decrypt($, "RSA-OAEP", {
    md: forge.md.sha256.create()
  });
  return decodeURIComponent(N);
}
function reEncryptRSAWithJWK(e, t, a) {
  const n = decryptRSAWithJWK(e, a);
  return encryptRSAWithJWK(t, n);
}
function encryptAES(e, t, a = "") {
  const n = typeof e == "string" ? e : _b64UrlToHex(e.k || ""), u = forge.util.hexToBytes(n), o = forge.random.getBytesSync(12), l = forge.cipher.createCipher("AES-GCM", u), h = encodeURIComponent(t);
  return l.start({ additionalData: a, iv: o, tagLength: 128 }), l.update(forge.util.createBuffer(h)), l.finish(), {
    iv: forge.util.bytesToHex(o),
    // @ts-expect-error node-forge typings are incomplete
    t: forge.util.bytesToHex(l.mode.tag),
    // @ts-expect-error node-forge typings are incomplete
    d: forge.util.bytesToHex(l.output),
    ad: forge.util.bytesToHex(a)
  };
}
function decryptAES(e, t) {
  const a = typeof e == "string" ? e : _b64UrlToHex(e.k || ""), n = forge.util.hexToBytes(a), u = forge.cipher.createDecipher("AES-GCM", n);
  if (u.start({
    iv: forge.util.hexToBytes(t.iv),
    tagLength: t.t.length * 4,
    // @ts-expect-error node-forge typings are incomplete
    tag: forge.util.hexToBytes(t.t),
    additionalData: forge.util.hexToBytes(t.ad)
  }), u.update(forge.util.createBuffer(forge.util.hexToBytes(t.d))), u.finish())
    return decodeURIComponent(u.output.toString());
  throw new Error("Failed to decrypt data");
}
function reEncryptAES(e, t, a) {
  const n = decryptAES(e, a);
  return encryptAES(t, n);
}
function getRandomHex(e = DEFAULT_BYTE_LENGTH) {
  return forge.util.bytesToHex(forge.random.getBytesSync(e));
}
function generateAccountId() {
  return `act_${getRandomHex(DEFAULT_BYTE_LENGTH)}`;
}
async function srpGenKey() {
  return (await genKey()).toString("hex");
}
async function generateAES256Key() {
  const e = window.crypto, t = e ? e.subtle : null;
  if (t) {
    console.log("-- Using Native AES Key Generation --");
    const a = await t.generateKey(
      { name: "AES-GCM", length: 256 },
      !0,
      ["encrypt", "decrypt"]
    );
    return t.exportKey("jwk", a);
  } else {
    console.log("-- Using Falback Forge AES Key Generation --");
    const a = forge.util.bytesToHex(forge.random.getBytesSync(32));
    return {
      kty: "oct",
      alg: "A256GCM",
      ext: !0,
      key_ops: ["encrypt", "decrypt"],
      k: _hexToB64Url(a)
    };
  }
}
async function generateKeyPairJWK() {
  const e = window.crypto && window.crypto.subtle;
  if (e) {
    console.log("-- Using Native RSA Generation --");
    const t = await e.generateKey(
      {
        name: "RSA-OAEP",
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: 2048,
        hash: "SHA-256"
      },
      !0,
      ["encrypt", "decrypt"]
    );
    if (!t.publicKey || !t.privateKey)
      throw new Error("Unexpected error generating a keypair.");
    return {
      publicKey: await e.exportKey("jwk", t.publicKey),
      privateKey: await e.exportKey("jwk", t.privateKey)
    };
  } else {
    console.log("-- Using Forge RSA Generation --");
    const t = forge.pki.rsa.generateKeyPair({ bits: 2048, e: 65537 }), a = {
      alg: "RSA-OAEP-256",
      kty: "RSA",
      key_ops: ["decrypt"],
      ext: !0,
      d: _bigIntToB64Url(t.privateKey.d),
      dp: _bigIntToB64Url(t.privateKey.dP),
      dq: _bigIntToB64Url(t.privateKey.dQ),
      e: _bigIntToB64Url(t.privateKey.e),
      n: _bigIntToB64Url(t.privateKey.n),
      p: _bigIntToB64Url(t.privateKey.p),
      q: _bigIntToB64Url(t.privateKey.q),
      qi: _bigIntToB64Url(t.privateKey.qInv)
    }, n = {
      alg: "RSA-OAEP-256",
      kty: "RSA",
      key_ops: ["encrypt"],
      e: _bigIntToB64Url(t.publicKey.e),
      n: _bigIntToB64Url(t.publicKey.n)
    };
    return { privateKey: a, publicKey: n };
  }
}
function _hkdfSalt(e, t) {
  return new Promise((a) => {
    new HKDF("sha256", e, t).derive(
      "",
      DEFAULT_BYTE_LENGTH,
      (u) => a(u.toString("hex"))
    );
  });
}
function _bigIntToB64Url(e) {
  return _hexToB64Url(e.toString(16));
}
function _hexToB64Url(e) {
  const t = forge.util.hexToBytes(e);
  return btoa(t).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function _b64UrlToBigInt(e) {
  return new forge.jsbn.BigInteger(_b64UrlToHex(e), 16);
}
function _b64UrlToHex(e) {
  const t = e.replace(/-/g, "+").replace(/_/g, "/");
  return forge.util.bytesToHex(atob(t));
}
async function _pbkdf2Passphrase(e, t) {
  if (typeof window < "u" && (!window.crypto || !window.crypto.subtle))
    return pbkdf2PassphraseForge(e, t);
  try {
    console.log("-- Using native PBKDF2 --");
    const a = await window.crypto.subtle.importKey(
      "raw",
      buffer$1.Buffer.from(e, "utf8"),
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ), n = {
      name: "PBKDF2",
      salt: buffer$1.Buffer.from(t, "hex"),
      iterations: DEFAULT_PBKDF2_ITERATIONS,
      hash: "SHA-256"
    }, u = await window.crypto.subtle.deriveBits(
      n,
      a,
      DEFAULT_BYTE_LENGTH * 8
    );
    return buffer$1.Buffer.from(u).toString("hex");
  } catch (a) {
    return console.error("Unexpectedly falling back to Forge due to error:", a), pbkdf2PassphraseForge(e, t);
  }
}
async function pbkdf2PassphraseForge(e, t) {
  console.log("-- Using Forge PBKDF2 --");
  const a = forge.pkcs5.pbkdf2(
    e,
    forge.util.hexToBytes(t),
    DEFAULT_PBKDF2_ITERATIONS,
    DEFAULT_BYTE_LENGTH,
    forge.md.sha256.create()
  );
  return forge.util.bytesToHex(a);
}
function encryptAESBuffer(e, t, a = "") {
  const n = typeof e == "string" ? e : _b64UrlToHex(e.k || ""), u = forge.util.hexToBytes(n), o = forge.random.getBytesSync(12), l = forge.cipher.createCipher("AES-GCM", u);
  return l.start({
    additionalData: a,
    iv: o,
    tagLength: 128
  }), l.update(forge.util.createBuffer(t)), l.finish(), {
    iv: forge.util.bytesToHex(o),
    // @ts-expect-error -- TSCONVERSION needs to be converted to string
    t: forge.util.bytesToHex(l.mode.tag),
    ad: forge.util.bytesToHex(a),
    // @ts-expect-error -- TSCONVERSION needs to be converted to string
    d: forge.util.bytesToHex(l.output)
  };
}
function decryptAESToBuffer(e, t) {
  const a = typeof e == "string" ? e : _b64UrlToHex(e.k || ""), n = forge.util.hexToBytes(a), u = forge.cipher.createDecipher("AES-GCM", n);
  if (u.start({
    iv: forge.util.hexToBytes(t.iv),
    tagLength: t.t.length * 4,
    // @ts-expect-error -- TSCONVERSION needs to be converted to string
    tag: forge.util.hexToBytes(t.t),
    additionalData: forge.util.hexToBytes(t.ad)
  }), u.update(forge.util.createBuffer(forge.util.hexToBytes(t.d))), u.finish())
    return buffer$1.Buffer.from(forge.util.bytesToHex(u.output), "hex");
  throw new Error("Failed to decrypt data");
}
export {
  Client,
  HKDF,
  Server,
  computeVerifier,
  decodeBase64,
  decodeBox,
  decryptAES,
  decryptAESToBuffer,
  decryptRSAWithJWK,
  deriveKey,
  encodeBase64,
  encodeBox,
  encryptAES,
  encryptAESBuffer,
  encryptRSAWithJWK,
  genKey,
  generateAES256Key,
  generateAccountId,
  generateKeyPairJWK,
  getRandomHex,
  keyPair,
  open,
  overheadLength,
  params,
  reEncryptAES,
  reEncryptRSAWithJWK,
  seal,
  srpGenKey
};
